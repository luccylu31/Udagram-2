{"ast":null,"code":"import _toConsumableArray from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectWithoutProperties from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _excluded = [\"modal\", \"popover\"];\n\nvar _DomController, _Platform, _NavController, _Config, _AngularDelegate, _IonRouterOutlet, _RoutedComponentInputBinder, _RouterLinkDelegateDirective, _RouterLinkWithHrefDelegateDirective, _IonTabs, _ValueAccessor;\n\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, InjectionToken, inject, NgZone, ApplicationRef, Injector, createComponent, TemplateRef, Directive, ContentChild, EventEmitter, ViewContainerRef, EnvironmentInjector, Attribute, SkipSelf, Input, Output, reflectComponentType, HostListener, ElementRef, ViewChild } from '@angular/core';\nimport * as i3 from '@angular/router';\nimport { NavigationStart, PRIMARY_OUTLET, ChildrenOutletContexts, ActivatedRoute, Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, componentOnReady } from '@ionic/core/components';\nimport { Subject, fromEvent, BehaviorSubject, combineLatest, of } from 'rxjs';\nimport { __decorate } from 'tslib';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { NgControl } from '@angular/forms';\nvar _c0 = [\"tabsInner\"];\n\nvar MenuController = /*#__PURE__*/function () {\n  function MenuController(menuController) {\n    _classCallCheck(this, MenuController);\n\n    _defineProperty(this, \"menuController\", void 0);\n\n    this.menuController = menuController;\n  }\n  /**\n   * Programmatically open the Menu.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu is fully opened\n   */\n\n\n  return _createClass(MenuController, [{\n    key: \"open\",\n    value: function open(menuId) {\n      return this.menuController.open(menuId);\n    }\n    /**\n     * Programmatically close the Menu. If no `menuId` is given as the first\n     * argument then it'll close any menu which is open. If a `menuId`\n     * is given then it'll close that exact menu.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu is fully closed\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(menuId) {\n      return this.menuController.close(menuId);\n    }\n    /**\n     * Toggle the menu. If it's closed, it will open, and if opened, it\n     * will close.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu has been toggled\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(menuId) {\n      return this.menuController.toggle(menuId);\n    }\n    /**\n     * Used to enable or disable a menu. For example, there could be multiple\n     * left menus, but only one of them should be able to be opened at the same\n     * time. If there are multiple menus on the same side, then enabling one menu\n     * will also automatically disable all the others that are on the same side.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable(shouldEnable, menuId) {\n      return this.menuController.enable(shouldEnable, menuId);\n    }\n    /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @param shouldEnable  True if it should be swipe-able, false if not.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n\n  }, {\n    key: \"swipeGesture\",\n    value: function swipeGesture(shouldEnable, menuId) {\n      return this.menuController.swipeGesture(shouldEnable, menuId);\n    }\n    /**\n     * @param [menuId] Optionally get the menu by its id, or side.\n     * @return Returns true if the specified menu is currently open, otherwise false.\n     * If the menuId is not specified, it returns true if ANY menu is currenly open.\n     */\n\n  }, {\n    key: \"isOpen\",\n    value: function isOpen(menuId) {\n      return this.menuController.isOpen(menuId);\n    }\n    /**\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns true if the menu is currently enabled, otherwise false.\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled(menuId) {\n      return this.menuController.isEnabled(menuId);\n    }\n    /**\n     * Used to get a menu instance. If a `menuId` is not provided then it'll\n     * return the first menu found. If a `menuId` is `left` or `right`, then\n     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n     * provided, then it'll try to find the menu using the menu's `id`\n     * property. If a menu is not found then it'll return `null`.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu if found, otherwise `null`.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(menuId) {\n      return this.menuController.get(menuId);\n    }\n    /**\n     * @return Returns the instance of the menu already opened, otherwise `null`.\n     */\n\n  }, {\n    key: \"getOpen\",\n    value: function getOpen() {\n      return this.menuController.getOpen();\n    }\n    /**\n     * @return Returns an array of all menu instances.\n     */\n\n  }, {\n    key: \"getMenus\",\n    value: function getMenus() {\n      return this.menuController.getMenus();\n    }\n  }, {\n    key: \"registerAnimation\",\n    value: function registerAnimation(name, animation) {\n      return this.menuController.registerAnimation(name, animation);\n    }\n  }, {\n    key: \"isAnimating\",\n    value: function isAnimating() {\n      return this.menuController.isAnimating();\n    }\n  }, {\n    key: \"_getOpenSync\",\n    value: function _getOpenSync() {\n      return this.menuController._getOpenSync();\n    }\n  }, {\n    key: \"_createAnimation\",\n    value: function _createAnimation(type, menuCmp) {\n      return this.menuController._createAnimation(type, menuCmp);\n    }\n  }, {\n    key: \"_register\",\n    value: function _register(menu) {\n      return this.menuController._register(menu);\n    }\n  }, {\n    key: \"_unregister\",\n    value: function _unregister(menu) {\n      return this.menuController._unregister(menu);\n    }\n  }, {\n    key: \"_setOpen\",\n    value: function _setOpen(menu, shouldOpen, animated) {\n      return this.menuController._setOpen(menu, shouldOpen, animated);\n    }\n  }]);\n}();\n\nvar DomController = /*#__PURE__*/function () {\n  function DomController() {\n    _classCallCheck(this, DomController);\n  }\n\n  return _createClass(DomController, [{\n    key: \"read\",\n    value:\n    /**\n     * Schedules a task to run during the READ phase of the next frame.\n     * This task should only read the DOM, but never modify it.\n     */\n    function read(cb) {\n      getQueue().read(cb);\n    }\n    /**\n     * Schedules a task to run during the WRITE phase of the next frame.\n     * This task should write the DOM, but never READ it.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(cb) {\n      getQueue().write(cb);\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_DomController = DomController;\n\n_defineProperty(DomController, \"\\u0275fac\", function _DomController_Factory(t) {\n  return new (t || _DomController)();\n});\n\n/** @nocollapse */\n_defineProperty(DomController, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _DomController,\n  factory: _DomController.ɵfac,\n  providedIn: 'root'\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar getQueue = function getQueue() {\n  var win = typeof window !== 'undefined' ? window : null;\n\n  if (win != null) {\n    var Ionic = win.Ionic;\n\n    if (Ionic !== null && Ionic !== void 0 && Ionic.queue) {\n      return Ionic.queue;\n    }\n\n    return {\n      read: function read(cb) {\n        return win.requestAnimationFrame(cb);\n      },\n      write: function write(cb) {\n        return win.requestAnimationFrame(cb);\n      }\n    };\n  }\n\n  return {\n    read: function read(cb) {\n      return cb();\n    },\n    write: function write(cb) {\n      return cb();\n    }\n  };\n};\n\nvar Platform = /*#__PURE__*/function () {\n  function Platform(doc, zone) {\n    var _this = this;\n\n    _classCallCheck(this, Platform);\n\n    _defineProperty(this, \"doc\", void 0);\n\n    _defineProperty(this, \"_readyPromise\", void 0);\n\n    _defineProperty(this, \"win\", void 0);\n\n    /**\n     * @hidden\n     */\n    _defineProperty(this, \"backButton\", new Subject());\n\n    /**\n     * The keyboardDidShow event emits when the\n     * on-screen keyboard is presented.\n     */\n    _defineProperty(this, \"keyboardDidShow\", new Subject());\n\n    /**\n     * The keyboardDidHide event emits when the\n     * on-screen keyboard is hidden.\n     */\n    _defineProperty(this, \"keyboardDidHide\", new Subject());\n\n    /**\n     * The pause event emits when the native platform puts the application\n     * into the background, typically when the user switches to a different\n     * application. This event would emit when a Cordova app is put into\n     * the background, however, it would not fire on a standard web browser.\n     */\n    _defineProperty(this, \"pause\", new Subject());\n\n    /**\n     * The resume event emits when the native platform pulls the application\n     * out from the background. This event would emit when a Cordova app comes\n     * out from the background, however, it would not fire on a standard web browser.\n     */\n    _defineProperty(this, \"resume\", new Subject());\n\n    /**\n     * The resize event emits when the browser window has changed dimensions. This\n     * could be from a browser window being physically resized, or from a device\n     * changing orientation.\n     */\n    _defineProperty(this, \"resize\", new Subject());\n\n    this.doc = doc;\n    zone.run(function () {\n      var _this$win;\n\n      _this.win = doc.defaultView;\n\n      _this.backButton.subscribeWithPriority = function (priority, callback) {\n        return this.subscribe(function (ev) {\n          return ev.register(priority, function (processNextHandler) {\n            return zone.run(function () {\n              return callback(processNextHandler);\n            });\n          });\n        });\n      };\n\n      proxyEvent(_this.pause, doc, 'pause', zone);\n      proxyEvent(_this.resume, doc, 'resume', zone);\n      proxyEvent(_this.backButton, doc, 'ionBackButton', zone);\n      proxyEvent(_this.resize, _this.win, 'resize', zone);\n      proxyEvent(_this.keyboardDidShow, _this.win, 'ionKeyboardDidShow', zone);\n      proxyEvent(_this.keyboardDidHide, _this.win, 'ionKeyboardDidHide', zone);\n      var readyResolve;\n      _this._readyPromise = new Promise(function (res) {\n        readyResolve = res;\n      });\n\n      if ((_this$win = _this.win) !== null && _this$win !== void 0 && _this$win['cordova']) {\n        doc.addEventListener('deviceready', function () {\n          readyResolve('cordova');\n        }, {\n          once: true\n        });\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        readyResolve('dom');\n      }\n    });\n  }\n  /**\n   * @returns returns true/false based on platform.\n   * @description\n   * Depending on the platform the user is on, `is(platformName)` will\n   * return `true` or `false`. Note that the same app can return `true`\n   * for more than one platform name. For example, an app running from\n   * an iPad would return `true` for the platform names: `mobile`,\n   * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n   * from Cordova then `cordova` would be true, and if it was running\n   * from a web browser on the iPad then `mobileweb` would be `true`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     if (this.platform.is('ios')) {\n   *       // This will only print when on iOS\n   *       console.log('I am an iOS device!');\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * | Platform Name   | Description                        |\n   * |-----------------|------------------------------------|\n   * | android         | on a device running Android.       |\n   * | capacitor       | on a device running Capacitor.     |\n   * | cordova         | on a device running Cordova.       |\n   * | ios             | on a device running iOS.           |\n   * | ipad            | on an iPad device.                 |\n   * | iphone          | on an iPhone device.               |\n   * | phablet         | on a phablet device.               |\n   * | tablet          | on a tablet device.                |\n   * | electron        | in Electron on a desktop device.   |\n   * | pwa             | as a PWA app.                      |\n   * | mobile          | on a mobile device.                |\n   * | mobileweb       | on a mobile device in a browser.   |\n   * | desktop         | on a desktop device.               |\n   * | hybrid          | is a cordova or capacitor app.     |\n   *\n   */\n\n\n  return _createClass(Platform, [{\n    key: \"is\",\n    value: function is(platformName) {\n      return isPlatform(this.win, platformName);\n    }\n    /**\n     * @returns the array of platforms\n     * @description\n     * Depending on what device you are on, `platforms` can return multiple values.\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n     * it would return `mobile`, `ios`, and `iphone`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     // This will print an array of the current platforms\n     *     console.log(this.platform.platforms());\n     *   }\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"platforms\",\n    value: function platforms() {\n      return getPlatforms(this.win);\n    }\n    /**\n     * Returns a promise when the platform is ready and native functionality\n     * can be called. If the app is running from within a web browser, then\n     * the promise will resolve when the DOM is ready. When the app is running\n     * from an application engine such as Cordova, then the promise will\n     * resolve when Cordova triggers the `deviceready` event.\n     *\n     * The resolved value is the `readySource`, which states which platform\n     * ready was used. For example, when Cordova is ready, the resolved ready\n     * source is `cordova`. The default ready source value will be `dom`. The\n     * `readySource` is useful if different logic should run depending on the\n     * platform the app is running from. For example, only Cordova can execute\n     * the status bar plugin, so the web should not run status bar plugin logic.\n     *\n     * ```\n     * import { Component } from '@angular/core';\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyApp {\n     *   constructor(public platform: Platform) {\n     *     this.platform.ready().then((readySource) => {\n     *       console.log('Platform ready from', readySource);\n     *       // Platform now ready, execute any required native code\n     *     });\n     *   }\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      return this._readyPromise;\n    }\n    /**\n     * Returns if this app is using right-to-left language direction or not.\n     * We recommend the app's `index.html` file already has the correct `dir`\n     * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n     */\n\n  }, {\n    key: \"isRTL\",\n    get: function get() {\n      return this.doc.dir === 'rtl';\n    }\n    /**\n     * Get the query string parameter\n     */\n\n  }, {\n    key: \"getQueryParam\",\n    value: function getQueryParam(key) {\n      return readQueryParam(this.win.location.href, key);\n    }\n    /**\n     * Returns `true` if the app is in landscape mode.\n     */\n\n  }, {\n    key: \"isLandscape\",\n    value: function isLandscape() {\n      return !this.isPortrait();\n    }\n    /**\n     * Returns `true` if the app is in portrait mode.\n     */\n\n  }, {\n    key: \"isPortrait\",\n    value: function isPortrait() {\n      var _this$win$matchMedia, _this$win2;\n\n      return (_this$win$matchMedia = (_this$win2 = this.win).matchMedia) === null || _this$win$matchMedia === void 0 ? void 0 : _this$win$matchMedia.call(_this$win2, '(orientation: portrait)').matches;\n    }\n  }, {\n    key: \"testUserAgent\",\n    value: function testUserAgent(expression) {\n      var nav = this.win.navigator;\n      return !!(nav !== null && nav !== void 0 && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);\n    }\n    /**\n     * Get the current url.\n     */\n\n  }, {\n    key: \"url\",\n    value: function url() {\n      return this.win.location.href;\n    }\n    /**\n     * Gets the width of the platform's viewport using `window.innerWidth`.\n     */\n\n  }, {\n    key: \"width\",\n    value: function width() {\n      return this.win.innerWidth;\n    }\n    /**\n     * Gets the height of the platform's viewport using `window.innerHeight`.\n     */\n\n  }, {\n    key: \"height\",\n    value: function height() {\n      return this.win.innerHeight;\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_Platform = Platform;\n\n_defineProperty(Platform, \"\\u0275fac\", function _Platform_Factory(t) {\n  return new (t || _Platform)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone));\n});\n\n/** @nocollapse */\n_defineProperty(Platform, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _Platform,\n  factory: _Platform.ɵfac,\n  providedIn: 'root'\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar readQueryParam = function readQueryParam(url, key) {\n  key = key.replace(/[[\\]\\\\]/g, '\\\\$&');\n  var regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n  var results = regex.exec(url);\n  return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\n\nvar proxyEvent = function proxyEvent(emitter, el, eventName, zone) {\n  if (el) {\n    el.addEventListener(eventName, function (ev) {\n      /**\n       * `zone.run` is required to make sure that we are running inside the Angular zone\n       * at all times. This is necessary since an app that has Capacitor will\n       * override the `document.addEventListener` with its own implementation.\n       * The override causes the event to no longer be in the Angular zone.\n       */\n      zone.run(function () {\n        // ?? cordova might emit \"null\" events\n        var value = ev != null ? ev.detail : undefined;\n        emitter.next(value);\n      });\n    });\n  }\n};\n\nvar NavController = /*#__PURE__*/function () {\n  function NavController(platform, location, serializer, router) {\n    var _this2 = this;\n\n    _classCallCheck(this, NavController);\n\n    _defineProperty(this, \"location\", void 0);\n\n    _defineProperty(this, \"serializer\", void 0);\n\n    _defineProperty(this, \"router\", void 0);\n\n    _defineProperty(this, \"topOutlet\", void 0);\n\n    _defineProperty(this, \"direction\", DEFAULT_DIRECTION);\n\n    _defineProperty(this, \"animated\", DEFAULT_ANIMATED);\n\n    _defineProperty(this, \"animationBuilder\", void 0);\n\n    _defineProperty(this, \"guessDirection\", 'forward');\n\n    _defineProperty(this, \"guessAnimation\", void 0);\n\n    _defineProperty(this, \"lastNavId\", -1);\n\n    this.location = location;\n    this.serializer = serializer;\n    this.router = router; // Subscribe to router events to detect direction\n\n    if (router) {\n      router.events.subscribe(function (ev) {\n        if (ev instanceof NavigationStart) {\n          // restoredState is set if the browser back/forward button is used\n          var id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n          _this2.guessDirection = _this2.guessAnimation = id < _this2.lastNavId ? 'back' : 'forward';\n          _this2.lastNavId = _this2.guessDirection === 'forward' ? ev.id : id;\n        }\n      });\n    } // Subscribe to backButton events\n\n\n    platform.backButton.subscribeWithPriority(0, function (processNextHandler) {\n      _this2.pop();\n\n      processNextHandler();\n    });\n  }\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n   *\n   * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n   * and that it will show a \"forward\" animation by default.\n   *\n   * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n   * ```\n   */\n\n\n  return _createClass(NavController, [{\n    key: \"navigateForward\",\n    value: function navigateForward(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.setDirection('forward', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('back');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n     * and that it will show a \"back\" animation by default.\n     *\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n     * ```\n     */\n\n  }, {\n    key: \"navigateBack\",\n    value: function navigateBack(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.setDirection('back', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('root');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **root** means that all existing pages in the stack will be removed,\n     * and the navigated page will become the single page in the stack.\n     *\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n     * ```\n     */\n\n  }, {\n    key: \"navigateRoot\",\n    value: function navigateRoot(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.setDirection('root', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n     * by default.\n     */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        animated: true,\n        animationDirection: 'back'\n      };\n      this.setDirection('back', options.animated, options.animationDirection, options.animation);\n      return this.location.back();\n    }\n    /**\n     * This methods goes back in the context of Ionic's stack navigation.\n     *\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\n     *\n     * Resolves to `true` if it was able to pop.\n     */\n\n  }, {\n    key: \"pop\",\n    value: function () {\n      var _pop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var outlet;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              outlet = this.topOutlet;\n\n            case 1:\n              if (!outlet) {\n                _context.next = 11;\n                break;\n              }\n\n              _context.next = 4;\n              return outlet.pop();\n\n            case 4:\n              if (!_context.sent) {\n                _context.next = 8;\n                break;\n              }\n\n              return _context.abrupt(\"return\", true);\n\n            case 8:\n              outlet = outlet.parentOutlet;\n\n            case 9:\n              _context.next = 1;\n              break;\n\n            case 11:\n              return _context.abrupt(\"return\", false);\n\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n\n      function pop() {\n        return _pop.apply(this, arguments);\n      }\n\n      return pop;\n    }()\n    /**\n     * This methods specifies the direction of the next navigation performed by the Angular router.\n     *\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n     *\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n     */\n\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction, animated, animationDirection, animationBuilder) {\n      this.direction = direction;\n      this.animated = getAnimation(direction, animated, animationDirection);\n      this.animationBuilder = animationBuilder;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"setTopOutlet\",\n    value: function setTopOutlet(outlet) {\n      this.topOutlet = outlet;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"consumeTransition\",\n    value: function consumeTransition() {\n      var direction = 'root';\n      var animation;\n      var animationBuilder = this.animationBuilder;\n\n      if (this.direction === 'auto') {\n        direction = this.guessDirection;\n        animation = this.guessAnimation;\n      } else {\n        animation = this.animated;\n        direction = this.direction;\n      }\n\n      this.direction = DEFAULT_DIRECTION;\n      this.animated = DEFAULT_ANIMATED;\n      this.animationBuilder = undefined;\n      return {\n        direction: direction,\n        animation: animation,\n        animationBuilder: animationBuilder\n      };\n    }\n  }, {\n    key: \"navigate\",\n    value: function navigate(url, options) {\n      if (Array.isArray(url)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.router.navigate(url, options);\n      } else {\n        /**\n         * navigateByUrl ignores any properties that\n         * would change the url, so things like queryParams\n         * would be ignored unless we create a url tree\n         * More Info: https://github.com/angular/angular/issues/18798\n         */\n        var urlTree = this.serializer.parse(url.toString());\n\n        if (options.queryParams !== undefined) {\n          urlTree.queryParams = _objectSpread({}, options.queryParams);\n        }\n\n        if (options.fragment !== undefined) {\n          urlTree.fragment = options.fragment;\n        }\n        /**\n         * `navigateByUrl` will still apply `NavigationExtras` properties\n         * that do not modify the url, such as `replaceUrl` which is why\n         * `options` is passed in here.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n        return this.router.navigateByUrl(urlTree, options);\n      }\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_NavController = NavController;\n\n_defineProperty(NavController, \"\\u0275fac\", function _NavController_Factory(t) {\n  return new (t || _NavController)(i0.ɵɵinject(Platform), i0.ɵɵinject(i1.Location), i0.ɵɵinject(i3.UrlSerializer), i0.ɵɵinject(i3.Router, 8));\n});\n\n/** @nocollapse */\n_defineProperty(NavController, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _NavController,\n  factory: _NavController.ɵfac,\n  providedIn: 'root'\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar getAnimation = function getAnimation(direction, animated, animationDirection) {\n  if (animated === false) {\n    return undefined;\n  }\n\n  if (animationDirection !== undefined) {\n    return animationDirection;\n  }\n\n  if (direction === 'forward' || direction === 'back') {\n    return direction;\n  } else if (direction === 'root' && animated === true) {\n    return 'forward';\n  }\n\n  return undefined;\n};\n\nvar DEFAULT_DIRECTION = 'auto';\nvar DEFAULT_ANIMATED = undefined;\n\nvar Config = /*#__PURE__*/function () {\n  function Config() {\n    _classCallCheck(this, Config);\n  }\n\n  return _createClass(Config, [{\n    key: \"get\",\n    value: function get(key, fallback) {\n      var c = getConfig();\n\n      if (c) {\n        return c.get(key, fallback);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getBoolean\",\n    value: function getBoolean(key, fallback) {\n      var c = getConfig();\n\n      if (c) {\n        return c.getBoolean(key, fallback);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getNumber\",\n    value: function getNumber(key, fallback) {\n      var c = getConfig();\n\n      if (c) {\n        return c.getNumber(key, fallback);\n      }\n\n      return 0;\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_Config = Config;\n\n_defineProperty(Config, \"\\u0275fac\", function _Config_Factory(t) {\n  return new (t || _Config)();\n});\n\n/** @nocollapse */\n_defineProperty(Config, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _Config,\n  factory: _Config.ɵfac,\n  providedIn: 'root'\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ConfigToken = new InjectionToken('USERCONFIG');\n\nvar getConfig = function getConfig() {\n  if (typeof window !== 'undefined') {\n    var Ionic = window.Ionic;\n\n    if (Ionic !== null && Ionic !== void 0 && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n\n  return null;\n};\n/**\n * @description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * @usage\n * ```ts\n * import { NavParams } from '@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\n\n\nvar NavParams = /*#__PURE__*/function () {\n  function NavParams() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, NavParams);\n\n    _defineProperty(this, \"data\", void 0);\n\n    this.data = data;\n    console.warn(\"[Ionic Warning]: NavParams has been deprecated in favor of using Angular's input API. Developers should migrate to either the @Input decorator or the Signals-based input API.\");\n  }\n  /**\n   * Get the value of a nav-parameter for the current view\n   *\n   * ```ts\n   * import { NavParams } from 'ionic-angular';\n   *\n   * export class MyClass{\n   *  constructor(public navParams: NavParams){\n   *    // userParams is an object we have in our nav-parameters\n   *    this.navParams.get('userParams');\n   *  }\n   * }\n   * ```\n   *\n   * @param param Which param you want to look up\n   */\n\n\n  return _createClass(NavParams, [{\n    key: \"get\",\n    value: function get(param) {\n      return this.data[param];\n    }\n  }]);\n}(); // TODO(FW-2827): types\n\n\nvar AngularDelegate = /*#__PURE__*/function () {\n  function AngularDelegate() {\n    _classCallCheck(this, AngularDelegate);\n\n    _defineProperty(this, \"zone\", inject(NgZone));\n\n    _defineProperty(this, \"applicationRef\", inject(ApplicationRef));\n\n    _defineProperty(this, \"config\", inject(ConfigToken));\n  }\n\n  return _createClass(AngularDelegate, [{\n    key: \"create\",\n    value: function create(environmentInjector, injector, elementReferenceKey) {\n      var _this$config$useSetIn;\n\n      return new AngularFrameworkDelegate(environmentInjector, injector, this.applicationRef, this.zone, elementReferenceKey, (_this$config$useSetIn = this.config.useSetInputAPI) !== null && _this$config$useSetIn !== void 0 ? _this$config$useSetIn : false);\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_AngularDelegate = AngularDelegate;\n\n_defineProperty(AngularDelegate, \"\\u0275fac\", function _AngularDelegate_Factory(t) {\n  return new (t || _AngularDelegate)();\n});\n\n/** @nocollapse */\n_defineProperty(AngularDelegate, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _AngularDelegate,\n  factory: _AngularDelegate.ɵfac\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar AngularFrameworkDelegate = /*#__PURE__*/function () {\n  function AngularFrameworkDelegate(environmentInjector, injector, applicationRef, zone, elementReferenceKey, enableSignalsSupport) {\n    _classCallCheck(this, AngularFrameworkDelegate);\n\n    _defineProperty(this, \"environmentInjector\", void 0);\n\n    _defineProperty(this, \"injector\", void 0);\n\n    _defineProperty(this, \"applicationRef\", void 0);\n\n    _defineProperty(this, \"zone\", void 0);\n\n    _defineProperty(this, \"elementReferenceKey\", void 0);\n\n    _defineProperty(this, \"enableSignalsSupport\", void 0);\n\n    _defineProperty(this, \"elRefMap\", new WeakMap());\n\n    _defineProperty(this, \"elEventsMap\", new WeakMap());\n\n    this.environmentInjector = environmentInjector;\n    this.injector = injector;\n    this.applicationRef = applicationRef;\n    this.zone = zone;\n    this.elementReferenceKey = elementReferenceKey;\n    this.enableSignalsSupport = enableSignalsSupport;\n  }\n\n  return _createClass(AngularFrameworkDelegate, [{\n    key: \"attachViewToDom\",\n    value: function attachViewToDom(container, component, params, cssClasses) {\n      var _this3 = this;\n\n      return this.zone.run(function () {\n        return new Promise(function (resolve) {\n          var componentProps = _objectSpread({}, params);\n          /**\n           * Ionic Angular passes a reference to a modal\n           * or popover that can be accessed using a\n           * variable in the overlay component. If\n           * elementReferenceKey is defined, then we should\n           * pass a reference to the component using\n           * elementReferenceKey as the key.\n           */\n\n\n          if (_this3.elementReferenceKey !== undefined) {\n            componentProps[_this3.elementReferenceKey] = container;\n          }\n\n          var el = attachView(_this3.zone, _this3.environmentInjector, _this3.injector, _this3.applicationRef, _this3.elRefMap, _this3.elEventsMap, container, component, componentProps, cssClasses, _this3.elementReferenceKey, _this3.enableSignalsSupport);\n          resolve(el);\n        });\n      });\n    }\n  }, {\n    key: \"removeViewFromDom\",\n    value: function removeViewFromDom(_container, component) {\n      var _this4 = this;\n\n      return this.zone.run(function () {\n        return new Promise(function (resolve) {\n          var componentRef = _this4.elRefMap.get(component);\n\n          if (componentRef) {\n            componentRef.destroy();\n\n            _this4.elRefMap.delete(component);\n\n            var unbindEvents = _this4.elEventsMap.get(component);\n\n            if (unbindEvents) {\n              unbindEvents();\n\n              _this4.elEventsMap.delete(component);\n            }\n          }\n\n          resolve();\n        });\n      });\n    }\n  }]);\n}();\n\nvar attachView = function attachView(zone, environmentInjector, injector, applicationRef, elRefMap, elEventsMap, container, component, params, cssClasses, elementReferenceKey, enableSignalsSupport) {\n  /**\n   * Wraps the injector with a custom injector that\n   * provides NavParams to the component.\n   *\n   * NavParams is a legacy feature from Ionic v3 that allows\n   * Angular developers to provide data to a component\n   * and access it by providing NavParams as a dependency\n   * in the constructor.\n   *\n   * The modern approach is to access the data directly\n   * from the component's class instance.\n   */\n  var childInjector = Injector.create({\n    providers: getProviders(params),\n    parent: injector\n  });\n  var componentRef = createComponent(component, {\n    environmentInjector: environmentInjector,\n    elementInjector: childInjector\n  });\n  var instance = componentRef.instance;\n  var hostElement = componentRef.location.nativeElement;\n\n  if (params) {\n    /**\n     * For modals and popovers, a reference to the component is\n     * added to `params` during the call to attachViewToDom. If\n     * a reference using this name is already set, this means\n     * the app is trying to use the name as a component prop,\n     * which will cause collisions.\n     */\n    if (elementReferenceKey && instance[elementReferenceKey] !== undefined) {\n      console.error(\"[Ionic Error]: \".concat(elementReferenceKey, \" is a reserved property when using \").concat(container.tagName.toLowerCase(), \". Rename or remove the \\\"\").concat(elementReferenceKey, \"\\\" property from \").concat(component.name, \".\"));\n    }\n    /**\n     * Angular 14.1 added support for setInput\n     * so we need to fall back to Object.assign\n     * for Angular 14.0.\n     */\n\n\n    if (enableSignalsSupport === true && componentRef.setInput !== undefined) {\n      var modal = params.modal,\n          popover = params.popover,\n          otherParams = _objectWithoutProperties(params, _excluded);\n      /**\n       * Any key/value pairs set in componentProps\n       * must be set as inputs on the component instance.\n       */\n\n\n      for (var key in otherParams) {\n        componentRef.setInput(key, otherParams[key]);\n      }\n      /**\n       * Using setInput will cause an error when\n       * setting modal/popover on a component that\n       * does not define them as an input. For backwards\n       * compatibility purposes we fall back to using\n       * Object.assign for these properties.\n       */\n\n\n      if (modal !== undefined) {\n        Object.assign(instance, {\n          modal: modal\n        });\n      }\n\n      if (popover !== undefined) {\n        Object.assign(instance, {\n          popover: popover\n        });\n      }\n    } else {\n      Object.assign(instance, params);\n    }\n  }\n\n  if (cssClasses) {\n    var _iterator = _createForOfIteratorHelper(cssClasses),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var cssClass = _step.value;\n        hostElement.classList.add(cssClass);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n  container.appendChild(hostElement);\n  applicationRef.attachView(componentRef.hostView);\n  elRefMap.set(hostElement, componentRef);\n  elEventsMap.set(hostElement, unbindEvents);\n  return hostElement;\n};\n\nvar LIFECYCLES = [LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD];\n\nvar bindLifecycleEvents = function bindLifecycleEvents(zone, instance, element) {\n  return zone.run(function () {\n    var unregisters = LIFECYCLES.filter(function (eventName) {\n      return typeof instance[eventName] === 'function';\n    }).map(function (eventName) {\n      var handler = function handler(ev) {\n        return instance[eventName](ev.detail);\n      };\n\n      element.addEventListener(eventName, handler);\n      return function () {\n        return element.removeEventListener(eventName, handler);\n      };\n    });\n    return function () {\n      return unregisters.forEach(function (fn) {\n        return fn();\n      });\n    };\n  });\n};\n\nvar NavParamsToken = new InjectionToken('NavParamsToken');\n\nvar getProviders = function getProviders(params) {\n  return [{\n    provide: NavParamsToken,\n    useValue: params\n  }, {\n    provide: NavParams,\n    useFactory: provideNavParamsInjectable,\n    deps: [NavParamsToken]\n  }];\n};\n\nvar provideNavParamsInjectable = function provideNavParamsInjectable(params) {\n  return new NavParams(params);\n}; // TODO: Is there a way we can grab this from angular-component-lib instead?\n\n/* eslint-disable */\n\n/* tslint:disable */\n\n\nvar proxyInputs = function proxyInputs(Cmp, inputs) {\n  var Prototype = Cmp.prototype;\n  inputs.forEach(function (item) {\n    Object.defineProperty(Prototype, item, {\n      get: function get() {\n        return this.el[item];\n      },\n      set: function set(val) {\n        var _this5 = this;\n\n        this.z.runOutsideAngular(function () {\n          return _this5.el[item] = val;\n        });\n      }\n    });\n  });\n};\n\nvar proxyMethods = function proxyMethods(Cmp, methods) {\n  var Prototype = Cmp.prototype;\n  methods.forEach(function (methodName) {\n    Prototype[methodName] = function () {\n      var _this6 = this;\n\n      var args = arguments;\n      return this.z.runOutsideAngular(function () {\n        return _this6.el[methodName].apply(_this6.el, args);\n      });\n    };\n  });\n};\n\nvar proxyOutputs = function proxyOutputs(instance, el, events) {\n  events.forEach(function (eventName) {\n    return instance[eventName] = fromEvent(el, eventName);\n  });\n}; // tslint:disable-next-line: only-arrow-functions\n\n\nfunction ProxyCmp(opts) {\n  var decorator = function decorator(cls) {\n    var defineCustomElementFn = opts.defineCustomElementFn,\n        inputs = opts.inputs,\n        methods = opts.methods;\n\n    if (defineCustomElementFn !== undefined) {\n      defineCustomElementFn();\n    }\n\n    if (inputs) {\n      proxyInputs(cls, inputs);\n    }\n\n    if (methods) {\n      proxyMethods(cls, methods);\n    }\n\n    return cls;\n  };\n\n  return decorator;\n}\n\nvar POPOVER_INPUTS = ['alignment', 'animated', 'arrow', 'keepContentsMounted', 'backdropDismiss', 'cssClass', 'dismissOnSelect', 'enterAnimation', 'event', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'translucent', 'trigger', 'triggerAction', 'reference', 'size', 'side'];\nvar POPOVER_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss'];\nvar IonPopover = /*#__PURE__*/(function () {\n  var _IonPopover;\n\n  var IonPopover = (_IonPopover = /*#__PURE__*/_createClass(function IonPopover(c, r, z) {\n    var _this7 = this;\n\n    _classCallCheck(this, IonPopover);\n\n    _defineProperty(this, \"z\", void 0);\n\n    // TODO(FW-2827): type\n    _defineProperty(this, \"template\", void 0);\n\n    _defineProperty(this, \"isCmpOpen\", false);\n\n    _defineProperty(this, \"el\", void 0);\n\n    this.z = z;\n    this.el = r.nativeElement;\n    this.el.addEventListener('ionMount', function () {\n      _this7.isCmpOpen = true;\n      c.detectChanges();\n    });\n    this.el.addEventListener('didDismiss', function () {\n      _this7.isCmpOpen = false;\n      c.detectChanges();\n    });\n    proxyOutputs(this, this.el, ['ionPopoverDidPresent', 'ionPopoverWillPresent', 'ionPopoverWillDismiss', 'ionPopoverDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n  }\n  /** @nocollapse */\n  ), _defineProperty(_IonPopover, \"\\u0275fac\", function _IonPopover_Factory(t) {\n    return new (t || _IonPopover)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  }), _defineProperty(_IonPopover, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonPopover,\n    selectors: [[\"ion-popover\"]],\n    contentQueries: function _IonPopover_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      animated: \"animated\",\n      arrow: \"arrow\",\n      keepContentsMounted: \"keepContentsMounted\",\n      backdropDismiss: \"backdropDismiss\",\n      cssClass: \"cssClass\",\n      dismissOnSelect: \"dismissOnSelect\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      showBackdrop: \"showBackdrop\",\n      translucent: \"translucent\",\n      trigger: \"trigger\",\n      triggerAction: \"triggerAction\",\n      reference: \"reference\",\n      size: \"size\",\n      side: \"side\"\n    }\n  })), _IonPopover);\n  IonPopover = __decorate([ProxyCmp({\n    inputs: POPOVER_INPUTS,\n    methods: POPOVER_METHODS\n  })\n  /**\n   * @Component extends from @Directive\n   * so by defining the inputs here we\n   * do not need to re-define them for the\n   * lazy loaded popover.\n   */\n  ], IonPopover);\n  return IonPopover;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar MODAL_INPUTS = ['animated', 'keepContentsMounted', 'backdropBreakpoint', 'backdropDismiss', 'breakpoints', 'canDismiss', 'cssClass', 'enterAnimation', 'event', 'handle', 'handleBehavior', 'initialBreakpoint', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'translucent', 'trigger'];\nvar MODAL_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss', 'setCurrentBreakpoint', 'getCurrentBreakpoint'];\nvar IonModal = /*#__PURE__*/(function () {\n  var _IonModal;\n\n  var IonModal = (_IonModal = /*#__PURE__*/_createClass(function IonModal(c, r, z) {\n    var _this8 = this;\n\n    _classCallCheck(this, IonModal);\n\n    _defineProperty(this, \"z\", void 0);\n\n    // TODO(FW-2827): type\n    _defineProperty(this, \"template\", void 0);\n\n    _defineProperty(this, \"isCmpOpen\", false);\n\n    _defineProperty(this, \"el\", void 0);\n\n    this.z = z;\n    this.el = r.nativeElement;\n    this.el.addEventListener('ionMount', function () {\n      _this8.isCmpOpen = true;\n      c.detectChanges();\n    });\n    this.el.addEventListener('didDismiss', function () {\n      _this8.isCmpOpen = false;\n      c.detectChanges();\n    });\n    proxyOutputs(this, this.el, ['ionModalDidPresent', 'ionModalWillPresent', 'ionModalWillDismiss', 'ionModalDidDismiss', 'ionBreakpointDidChange', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n  }\n  /** @nocollapse */\n  ), _defineProperty(_IonModal, \"\\u0275fac\", function _IonModal_Factory(t) {\n    return new (t || _IonModal)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  }), _defineProperty(_IonModal, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonModal,\n    selectors: [[\"ion-modal\"]],\n    contentQueries: function _IonModal_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      animated: \"animated\",\n      keepContentsMounted: \"keepContentsMounted\",\n      backdropBreakpoint: \"backdropBreakpoint\",\n      backdropDismiss: \"backdropDismiss\",\n      breakpoints: \"breakpoints\",\n      canDismiss: \"canDismiss\",\n      cssClass: \"cssClass\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      handle: \"handle\",\n      handleBehavior: \"handleBehavior\",\n      initialBreakpoint: \"initialBreakpoint\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      presentingElement: \"presentingElement\",\n      showBackdrop: \"showBackdrop\",\n      translucent: \"translucent\",\n      trigger: \"trigger\"\n    }\n  })), _IonModal);\n  IonModal = __decorate([ProxyCmp({\n    inputs: MODAL_INPUTS,\n    methods: MODAL_METHODS\n  })\n  /**\n   * @Component extends from @Directive\n   * so by defining the inputs here we\n   * do not need to re-define them for the\n   * lazy loaded popover.\n   */\n  ], IonModal);\n  return IonModal;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar _insertView = function insertView(views, view, direction) {\n  if (direction === 'root') {\n    return setRoot(views, view);\n  } else if (direction === 'forward') {\n    return setForward(views, view);\n  } else {\n    return setBack(views, view);\n  }\n};\n\nvar setRoot = function setRoot(views, view) {\n  views = views.filter(function (v) {\n    return v.stackId !== view.stackId;\n  });\n  views.push(view);\n  return views;\n};\n\nvar setForward = function setForward(views, view) {\n  var index = views.indexOf(view);\n\n  if (index >= 0) {\n    views = views.filter(function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    views.push(view);\n  }\n\n  return views;\n};\n\nvar setBack = function setBack(views, view) {\n  var index = views.indexOf(view);\n\n  if (index >= 0) {\n    return views.filter(function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    return setRoot(views, view);\n  }\n};\n\nvar getUrl = function getUrl(router, activatedRoute) {\n  var urlTree = router.createUrlTree(['.'], {\n    relativeTo: activatedRoute\n  });\n  return router.serializeUrl(urlTree);\n};\n\nvar isTabSwitch = function isTabSwitch(enteringView, leavingView) {\n  if (!leavingView) {\n    return true;\n  }\n\n  return enteringView.stackId !== leavingView.stackId;\n};\n\nvar computeStackId = function computeStackId(prefixUrl, url) {\n  if (!prefixUrl) {\n    return undefined;\n  }\n\n  var segments = toSegments(url);\n\n  for (var i = 0; i < segments.length; i++) {\n    if (i >= prefixUrl.length) {\n      return segments[i];\n    }\n\n    if (segments[i] !== prefixUrl[i]) {\n      return undefined;\n    }\n  }\n\n  return undefined;\n};\n\nvar toSegments = function toSegments(path) {\n  return path.split('/').map(function (s) {\n    return s.trim();\n  }).filter(function (s) {\n    return s !== '';\n  });\n};\n\nvar destroyView = function destroyView(view) {\n  if (view) {\n    view.ref.destroy();\n    view.unlistenEvents();\n  }\n}; // TODO(FW-2827): types\n\n\nvar StackController = /*#__PURE__*/function () {\n  function StackController(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n    _classCallCheck(this, StackController);\n\n    _defineProperty(this, \"containerEl\", void 0);\n\n    _defineProperty(this, \"router\", void 0);\n\n    _defineProperty(this, \"navCtrl\", void 0);\n\n    _defineProperty(this, \"zone\", void 0);\n\n    _defineProperty(this, \"location\", void 0);\n\n    _defineProperty(this, \"views\", []);\n\n    _defineProperty(this, \"runningTask\", void 0);\n\n    _defineProperty(this, \"skipTransition\", false);\n\n    _defineProperty(this, \"tabsPrefix\", void 0);\n\n    _defineProperty(this, \"activeView\", void 0);\n\n    _defineProperty(this, \"nextId\", 0);\n\n    this.containerEl = containerEl;\n    this.router = router;\n    this.navCtrl = navCtrl;\n    this.zone = zone;\n    this.location = location;\n    this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n  }\n\n  return _createClass(StackController, [{\n    key: \"createView\",\n    value: function createView(ref, activatedRoute) {\n      var _ref$location;\n\n      var url = getUrl(this.router, activatedRoute);\n      var element = ref === null || ref === void 0 ? void 0 : (_ref$location = ref.location) === null || _ref$location === void 0 ? void 0 : _ref$location.nativeElement;\n      var unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n      return {\n        id: this.nextId++,\n        stackId: computeStackId(this.tabsPrefix, url),\n        unlistenEvents: unlistenEvents,\n        element: element,\n        ref: ref,\n        url: url\n      };\n    }\n  }, {\n    key: \"getExistingView\",\n    value: function getExistingView(activatedRoute) {\n      var activatedUrlKey = getUrl(this.router, activatedRoute);\n      var view = this.views.find(function (vw) {\n        return vw.url === activatedUrlKey;\n      });\n\n      if (view) {\n        view.ref.changeDetectorRef.reattach();\n      }\n\n      return view;\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive(enteringView) {\n      var _router$navigations,\n          _currentNavigation,\n          _currentNavigation$ex,\n          _this9 = this;\n\n      var consumeResult = this.navCtrl.consumeTransition();\n      var direction = consumeResult.direction,\n          animation = consumeResult.animation,\n          animationBuilder = consumeResult.animationBuilder;\n      var leavingView = this.activeView;\n      var tabSwitch = isTabSwitch(enteringView, leavingView);\n\n      if (tabSwitch) {\n        direction = 'back';\n        animation = undefined;\n      }\n\n      var viewsSnapshot = this.views.slice();\n      var currentNavigation;\n      var router = this.router; // Angular >= 7.2.0\n\n      if (router.getCurrentNavigation) {\n        currentNavigation = router.getCurrentNavigation(); // Angular < 7.2.0\n      } else if ((_router$navigations = router.navigations) !== null && _router$navigations !== void 0 && _router$navigations.value) {\n        currentNavigation = router.navigations.value;\n      }\n      /**\n       * If the navigation action\n       * sets `replaceUrl: true`\n       * then we need to make sure\n       * we remove the last item\n       * from our views stack\n       */\n\n\n      if ((_currentNavigation = currentNavigation) !== null && _currentNavigation !== void 0 && (_currentNavigation$ex = _currentNavigation.extras) !== null && _currentNavigation$ex !== void 0 && _currentNavigation$ex.replaceUrl) {\n        if (this.views.length > 0) {\n          this.views.splice(-1, 1);\n        }\n      }\n\n      var reused = this.views.includes(enteringView);\n      var views = this.insertView(enteringView, direction); // Trigger change detection before transition starts\n      // This will call ngOnInit() the first time too, just after the view\n      // was attached to the dom, but BEFORE the transition starts\n\n      if (!reused) {\n        enteringView.ref.changeDetectorRef.detectChanges();\n      }\n      /**\n       * If we are going back from a page that\n       * was presented using a custom animation\n       * we should default to using that\n       * unless the developer explicitly\n       * provided another animation.\n       */\n\n\n      var customAnimation = enteringView.animationBuilder;\n\n      if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\n        animationBuilder = customAnimation;\n      }\n      /**\n       * Save any custom animation so that navigating\n       * back will use this custom animation by default.\n       */\n\n\n      if (leavingView) {\n        leavingView.animationBuilder = animationBuilder;\n      } // Wait until previous transitions finish\n\n\n      return this.zone.runOutsideAngular(function () {\n        return _this9.wait(function () {\n          // disconnect leaving page from change detection to\n          // reduce jank during the page transition\n          if (leavingView) {\n            leavingView.ref.changeDetectorRef.detach();\n          } // In case the enteringView is the same as the leavingPage we need to reattach()\n\n\n          enteringView.ref.changeDetectorRef.reattach();\n          return _this9.transition(enteringView, leavingView, animation, _this9.canGoBack(1), false, animationBuilder).then(function () {\n            return cleanupAsync(enteringView, views, viewsSnapshot, _this9.location, _this9.zone);\n          }).then(function () {\n            return {\n              enteringView: enteringView,\n              direction: direction,\n              animation: animation,\n              tabSwitch: tabSwitch\n            };\n          });\n        });\n      });\n    }\n  }, {\n    key: \"canGoBack\",\n    value: function canGoBack(deep) {\n      var stackId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getActiveStackId();\n      return this.getStack(stackId).length > deep;\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(deep) {\n      var _this10 = this;\n\n      var stackId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getActiveStackId();\n      return this.zone.run(function () {\n        var views = _this10.getStack(stackId);\n\n        if (views.length <= deep) {\n          return Promise.resolve(false);\n        }\n\n        var view = views[views.length - deep - 1];\n        var url = view.url;\n        var viewSavedData = view.savedData;\n\n        if (viewSavedData) {\n          var _primaryOutlet$route, _primaryOutlet$route$;\n\n          var primaryOutlet = viewSavedData.get('primary');\n\n          if (primaryOutlet !== null && primaryOutlet !== void 0 && (_primaryOutlet$route = primaryOutlet.route) !== null && _primaryOutlet$route !== void 0 && (_primaryOutlet$route$ = _primaryOutlet$route._routerState) !== null && _primaryOutlet$route$ !== void 0 && _primaryOutlet$route$.snapshot.url) {\n            url = primaryOutlet.route._routerState.snapshot.url;\n          }\n        }\n\n        var _this10$navCtrl$consu = _this10.navCtrl.consumeTransition(),\n            animationBuilder = _this10$navCtrl$consu.animationBuilder;\n\n        return _this10.navCtrl.navigateBack(url, _objectSpread(_objectSpread({}, view.savedExtras), {}, {\n          animation: animationBuilder\n        })).then(function () {\n          return true;\n        });\n      });\n    }\n  }, {\n    key: \"startBackTransition\",\n    value: function startBackTransition() {\n      var _this11 = this;\n\n      var leavingView = this.activeView;\n\n      if (leavingView) {\n        var views = this.getStack(leavingView.stackId);\n        var enteringView = views[views.length - 2];\n        var customAnimation = enteringView.animationBuilder;\n        return this.wait(function () {\n          return _this11.transition(enteringView, // entering view\n          leavingView, // leaving view\n          'back', _this11.canGoBack(2), true, customAnimation);\n        });\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"endBackTransition\",\n    value: function endBackTransition(shouldComplete) {\n      if (shouldComplete) {\n        this.skipTransition = true;\n        this.pop(1);\n      } else if (this.activeView) {\n        cleanup(this.activeView, this.views, this.views, this.location, this.zone);\n      }\n    }\n  }, {\n    key: \"getLastUrl\",\n    value: function getLastUrl(stackId) {\n      var views = this.getStack(stackId);\n      return views.length > 0 ? views[views.length - 1] : undefined;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"getRootUrl\",\n    value: function getRootUrl(stackId) {\n      var views = this.getStack(stackId);\n      return views.length > 0 ? views[0] : undefined;\n    }\n  }, {\n    key: \"getActiveStackId\",\n    value: function getActiveStackId() {\n      return this.activeView ? this.activeView.stackId : undefined;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"getActiveView\",\n    value: function getActiveView() {\n      return this.activeView;\n    }\n  }, {\n    key: \"hasRunningTask\",\n    value: function hasRunningTask() {\n      return this.runningTask !== undefined;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.containerEl = undefined;\n      this.views.forEach(destroyView);\n      this.activeView = undefined;\n      this.views = [];\n    }\n  }, {\n    key: \"getStack\",\n    value: function getStack(stackId) {\n      return this.views.filter(function (v) {\n        return v.stackId === stackId;\n      });\n    }\n  }, {\n    key: \"insertView\",\n    value: function insertView(enteringView, direction) {\n      this.activeView = enteringView;\n      this.views = _insertView(this.views, enteringView, direction);\n      return this.views.slice();\n    }\n  }, {\n    key: \"transition\",\n    value: function transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\n      if (this.skipTransition) {\n        this.skipTransition = false;\n        return Promise.resolve(false);\n      }\n\n      if (leavingView === enteringView) {\n        return Promise.resolve(false);\n      }\n\n      var enteringEl = enteringView ? enteringView.element : undefined;\n      var leavingEl = leavingView ? leavingView.element : undefined;\n      var containerEl = this.containerEl;\n\n      if (enteringEl && enteringEl !== leavingEl) {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n\n        if (containerEl.commit) {\n          return containerEl.commit(enteringEl, leavingEl, {\n            duration: direction === undefined ? 0 : undefined,\n            direction: direction,\n            showGoBack: showGoBack,\n            progressAnimation: progressAnimation,\n            animationBuilder: animationBuilder\n          });\n        }\n      }\n\n      return Promise.resolve(false);\n    }\n  }, {\n    key: \"wait\",\n    value: function () {\n      var _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(task) {\n        var _this12 = this;\n\n        var promise;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this.runningTask !== undefined)) {\n                _context2.next = 4;\n                break;\n              }\n\n              _context2.next = 3;\n              return this.runningTask;\n\n            case 3:\n              this.runningTask = undefined;\n\n            case 4:\n              promise = this.runningTask = task();\n              promise.finally(function () {\n                return _this12.runningTask = undefined;\n              });\n              return _context2.abrupt(\"return\", promise);\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n\n      function wait(_x) {\n        return _wait.apply(this, arguments);\n      }\n\n      return wait;\n    }()\n  }]);\n}();\n\nvar cleanupAsync = function cleanupAsync(activeRoute, views, viewsSnapshot, location, zone) {\n  if (typeof requestAnimationFrame === 'function') {\n    return new Promise(function (resolve) {\n      requestAnimationFrame(function () {\n        cleanup(activeRoute, views, viewsSnapshot, location, zone);\n        resolve();\n      });\n    });\n  }\n\n  return Promise.resolve();\n};\n\nvar cleanup = function cleanup(activeRoute, views, viewsSnapshot, location, zone) {\n  /**\n   * Re-enter the Angular zone when destroying page components. This will allow\n   * lifecycle events (`ngOnDestroy`) to be run inside the Angular zone.\n   */\n  zone.run(function () {\n    return viewsSnapshot.filter(function (view) {\n      return !views.includes(view);\n    }).forEach(destroyView);\n  });\n  views.forEach(function (view) {\n    /**\n     * In the event that a user navigated multiple\n     * times in rapid succession, we want to make sure\n     * we don't pre-emptively detach a view while\n     * it is in mid-transition.\n     *\n     * In this instance we also do not care about query\n     * params or fragments as it will be the same view regardless\n     */\n    var locationWithoutParams = location.path().split('?')[0];\n    var locationWithoutFragment = locationWithoutParams.split('#')[0];\n\n    if (view !== activeRoute && view.url !== locationWithoutFragment) {\n      var element = view.element;\n      element.setAttribute('aria-hidden', 'true');\n      element.classList.add('ion-page-hidden');\n      view.ref.changeDetectorRef.detach();\n    }\n  });\n}; // TODO(FW-2827): types\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\n\n\nvar IonRouterOutlet = /*#__PURE__*/function () {\n  function IonRouterOutlet(name, tabs, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n    _classCallCheck(this, IonRouterOutlet);\n\n    _defineProperty(this, \"parentOutlet\", void 0);\n\n    _defineProperty(this, \"nativeEl\", void 0);\n\n    _defineProperty(this, \"activatedView\", null);\n\n    _defineProperty(this, \"tabsPrefix\", void 0);\n\n    _defineProperty(this, \"_swipeGesture\", void 0);\n\n    _defineProperty(this, \"stackCtrl\", void 0);\n\n    // Maintain map of activated route proxies for each component instance\n    _defineProperty(this, \"proxyMap\", new WeakMap());\n\n    // Keep the latest activated route in a subject for the proxy routes to switch map to\n    _defineProperty(this, \"currentActivatedRoute$\", new BehaviorSubject(null));\n\n    _defineProperty(this, \"activated\", null);\n\n    _defineProperty(this, \"_activatedRoute\", null);\n\n    /**\n     * The name of the outlet\n     */\n    _defineProperty(this, \"name\", PRIMARY_OUTLET);\n\n    /** @internal */\n    _defineProperty(this, \"stackWillChange\", new EventEmitter());\n\n    /** @internal */\n    _defineProperty(this, \"stackDidChange\", new EventEmitter());\n\n    // eslint-disable-next-line @angular-eslint/no-output-rename\n    _defineProperty(this, \"activateEvents\", new EventEmitter());\n\n    // eslint-disable-next-line @angular-eslint/no-output-rename\n    _defineProperty(this, \"deactivateEvents\", new EventEmitter());\n\n    _defineProperty(this, \"parentContexts\", inject(ChildrenOutletContexts));\n\n    _defineProperty(this, \"location\", inject(ViewContainerRef));\n\n    _defineProperty(this, \"environmentInjector\", inject(EnvironmentInjector));\n\n    _defineProperty(this, \"inputBinder\", inject(INPUT_BINDER, {\n      optional: true\n    }));\n\n    /** @nodoc */\n    _defineProperty(this, \"supportsBindingToComponentInputs\", true);\n\n    // Ionic providers\n    _defineProperty(this, \"config\", inject(Config));\n\n    _defineProperty(this, \"navCtrl\", inject(NavController));\n\n    this.parentOutlet = parentOutlet;\n    this.nativeEl = elementRef.nativeElement;\n    this.name = name || PRIMARY_OUTLET;\n    this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n    this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, this.navCtrl, zone, commonLocation);\n    this.parentContexts.onChildOutletCreated(this.name, this);\n  }\n\n  return _createClass(IonRouterOutlet, [{\n    key: \"activatedComponentRef\",\n    get:\n    /** @internal */\n    function get() {\n      return this.activated;\n    }\n  }, {\n    key: \"animation\",\n    set: function set(animation) {\n      this.nativeEl.animation = animation;\n    }\n  }, {\n    key: \"animated\",\n    set: function set(animated) {\n      this.nativeEl.animated = animated;\n    }\n  }, {\n    key: \"swipeGesture\",\n    set: function set(swipe) {\n      var _this13 = this;\n\n      this._swipeGesture = swipe;\n      this.nativeEl.swipeHandler = swipe ? {\n        canStart: function canStart() {\n          return _this13.stackCtrl.canGoBack(1) && !_this13.stackCtrl.hasRunningTask();\n        },\n        onStart: function onStart() {\n          return _this13.stackCtrl.startBackTransition();\n        },\n        onEnd: function onEnd(shouldContinue) {\n          return _this13.stackCtrl.endBackTransition(shouldContinue);\n        }\n      } : undefined;\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      var _this$inputBinder;\n\n      this.stackCtrl.destroy();\n      (_this$inputBinder = this.inputBinder) === null || _this$inputBinder === void 0 ? void 0 : _this$inputBinder.unsubscribeFromRouteData(this);\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.parentContexts.getContext(this.name);\n    }\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.initializeOutletWithName();\n    } // Note: Ionic deviates from the Angular Router implementation here\n\n  }, {\n    key: \"initializeOutletWithName\",\n    value: function initializeOutletWithName() {\n      var _this14 = this;\n\n      if (!this.activated) {\n        // If the outlet was not instantiated at the time the route got activated we need to populate\n        // the outlet when it is initialized (ie inside a NgIf)\n        var context = this.getContext();\n\n        if (context !== null && context !== void 0 && context.route) {\n          this.activateWith(context.route, context.injector);\n        }\n      }\n\n      new Promise(function (resolve) {\n        return componentOnReady(_this14.nativeEl, resolve);\n      }).then(function () {\n        if (_this14._swipeGesture === undefined) {\n          _this14.swipeGesture = _this14.config.getBoolean('swipeBackEnabled', _this14.nativeEl.mode === 'ios');\n        }\n      });\n    }\n  }, {\n    key: \"isActivated\",\n    get: function get() {\n      return !!this.activated;\n    }\n  }, {\n    key: \"component\",\n    get: function get() {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n\n      return this.activated.instance;\n    }\n  }, {\n    key: \"activatedRoute\",\n    get: function get() {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n\n      return this._activatedRoute;\n    }\n  }, {\n    key: \"activatedRouteData\",\n    get: function get() {\n      if (this._activatedRoute) {\n        return this._activatedRoute.snapshot.data;\n      }\n\n      return {};\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      throw new Error('incompatible reuse strategy');\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"attach\",\n    value: function attach(_ref, _activatedRoute) {\n      throw new Error('incompatible reuse strategy');\n    }\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      if (this.activated) {\n        if (this.activatedView) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          var context = this.getContext();\n          this.activatedView.savedData = new Map(context.children['contexts']);\n          /**\n           * Angular v11.2.10 introduced a change\n           * where this route context is cleared out when\n           * a router-outlet is deactivated, However,\n           * we need this route information in order to\n           * return a user back to the correct tab when\n           * leaving and then going back to the tab context.\n           */\n\n          var primaryOutlet = this.activatedView.savedData.get('primary');\n\n          if (primaryOutlet && context.route) {\n            primaryOutlet.route = _objectSpread({}, context.route);\n          }\n          /**\n           * Ensure we are saving the NavigationExtras\n           * data otherwise it will be lost\n           */\n\n\n          this.activatedView.savedExtras = {};\n\n          if (context.route) {\n            var contextSnapshot = context.route.snapshot;\n            this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n            this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n          }\n        }\n\n        var c = this.component;\n        this.activatedView = null;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.deactivateEvents.emit(c);\n      }\n    }\n  }, {\n    key: \"activateWith\",\n    value: function activateWith(activatedRoute, environmentInjector) {\n      var _this$inputBinder2,\n          _this15 = this;\n\n      if (this.isActivated) {\n        throw new Error('Cannot activate an already activated outlet');\n      }\n\n      this._activatedRoute = activatedRoute;\n      var cmpRef;\n      var enteringView = this.stackCtrl.getExistingView(activatedRoute);\n\n      if (enteringView) {\n        cmpRef = this.activated = enteringView.ref;\n        var saved = enteringView.savedData;\n\n        if (saved) {\n          // self-restore\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          var context = this.getContext();\n          context.children['contexts'] = saved;\n        } // Updated activated route proxy for this component\n\n\n        this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n      } else {\n        var _snapshot$routeConfig;\n\n        var snapshot = activatedRoute._futureSnapshot;\n        /**\n         * Angular 14 introduces a new `loadComponent` property to the route config.\n         * This function will assign a `component` property to the route snapshot.\n         * We check for the presence of this property to determine if the route is\n         * using standalone components.\n         */\n\n        var childContexts = this.parentContexts.getOrCreateContext(this.name).children; // We create an activated route proxy object that will maintain future updates for this component\n        // over its lifecycle in the stack.\n\n        var component$ = new BehaviorSubject(null);\n        var activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n        var injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        var component = (_snapshot$routeConfig = snapshot.routeConfig.component) !== null && _snapshot$routeConfig !== void 0 ? _snapshot$routeConfig : snapshot.component;\n        /**\n         * View components need to be added as a child of ion-router-outlet\n         * for page transitions and swipe to go back.\n         * However, createComponent mounts components as siblings of the\n         * ViewContainerRef. As a result, outletContent must reference\n         * an ng-container inside of ion-router-outlet and not\n         * ion-router-outlet itself.\n         */\n\n        cmpRef = this.activated = this.outletContent.createComponent(component, {\n          index: this.outletContent.length,\n          injector: injector,\n          environmentInjector: environmentInjector !== null && environmentInjector !== void 0 ? environmentInjector : this.environmentInjector\n        }); // Once the component is created we can push it to our local subject supplied to the proxy\n\n        component$.next(cmpRef.instance); // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n\n        /**\n         * At this point this.activated has been set earlier\n         * in this function, so it is guaranteed to be non-null.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        enteringView = this.stackCtrl.createView(this.activated, activatedRoute); // Store references to the proxy by component\n\n        this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n        this.currentActivatedRoute$.next({\n          component: cmpRef.instance,\n          activatedRoute: activatedRoute\n        });\n      }\n\n      (_this$inputBinder2 = this.inputBinder) === null || _this$inputBinder2 === void 0 ? void 0 : _this$inputBinder2.bindActivatedRouteToOutletComponent(this);\n      this.activatedView = enteringView;\n      /**\n       * The top outlet is set prior to the entering view's transition completing,\n       * so that when we have nested outlets (e.g. ion-tabs inside an ion-router-outlet),\n       * the tabs outlet will be assigned as the top outlet when a view inside tabs is\n       * activated.\n       *\n       * In this scenario, activeWith is called for both the tabs and the root router outlet.\n       * To avoid a race condition, we assign the top outlet synchronously.\n       */\n\n      this.navCtrl.setTopOutlet(this);\n      var leavingView = this.stackCtrl.getActiveView();\n      this.stackWillChange.emit({\n        enteringView: enteringView,\n        tabSwitch: isTabSwitch(enteringView, leavingView)\n      });\n      this.stackCtrl.setActive(enteringView).then(function (data) {\n        _this15.activateEvents.emit(cmpRef.instance);\n\n        _this15.stackDidChange.emit(data);\n      });\n    }\n    /**\n     * Returns `true` if there are pages in the stack to go back.\n     */\n\n  }, {\n    key: \"canGoBack\",\n    value: function canGoBack() {\n      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var stackId = arguments.length > 1 ? arguments[1] : undefined;\n      return this.stackCtrl.canGoBack(deep, stackId);\n    }\n    /**\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n     */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var stackId = arguments.length > 1 ? arguments[1] : undefined;\n      return this.stackCtrl.pop(deep, stackId);\n    }\n    /**\n     * Returns the URL of the active page of each stack.\n     */\n\n  }, {\n    key: \"getLastUrl\",\n    value: function getLastUrl(stackId) {\n      var active = this.stackCtrl.getLastUrl(stackId);\n      return active ? active.url : undefined;\n    }\n    /**\n     * Returns the RouteView of the active page of each stack.\n     * @internal\n     */\n\n  }, {\n    key: \"getLastRouteView\",\n    value: function getLastRouteView(stackId) {\n      return this.stackCtrl.getLastUrl(stackId);\n    }\n    /**\n     * Returns the root view in the tab stack.\n     * @internal\n     */\n\n  }, {\n    key: \"getRootView\",\n    value: function getRootView(stackId) {\n      return this.stackCtrl.getRootUrl(stackId);\n    }\n    /**\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n     */\n\n  }, {\n    key: \"getActiveStackId\",\n    value: function getActiveStackId() {\n      return this.stackCtrl.getActiveStackId();\n    }\n    /**\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n     */\n\n  }, {\n    key: \"createActivatedRouteProxy\",\n    value: function createActivatedRouteProxy(component$, activatedRoute) {\n      var proxy = new ActivatedRoute();\n      proxy._futureSnapshot = activatedRoute._futureSnapshot;\n      proxy._routerState = activatedRoute._routerState;\n      proxy.snapshot = activatedRoute.snapshot;\n      proxy.outlet = activatedRoute.outlet;\n      proxy.component = activatedRoute.component; // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n\n      proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n      proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n      proxy.url = this.proxyObservable(component$, 'url');\n      proxy.params = this.proxyObservable(component$, 'params');\n      proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n      proxy.fragment = this.proxyObservable(component$, 'fragment');\n      proxy.data = this.proxyObservable(component$, 'data');\n      return proxy;\n    }\n    /**\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\n     */\n\n  }, {\n    key: \"proxyObservable\",\n    value: function proxyObservable(component$, path) {\n      var _this16 = this;\n\n      return component$.pipe( // First wait until the component instance is pushed\n      filter(function (component) {\n        return !!component;\n      }), switchMap(function (component) {\n        return _this16.currentActivatedRoute$.pipe(filter(function (current) {\n          return current !== null && current.component === component;\n        }), switchMap(function (current) {\n          return current && current.activatedRoute[path];\n        }), distinctUntilChanged());\n      }));\n    }\n    /**\n     * Updates the activated route proxy for the given component to the new incoming router state\n     */\n\n  }, {\n    key: \"updateActivatedRouteProxy\",\n    value: function updateActivatedRouteProxy(component, activatedRoute) {\n      var proxy = this.proxyMap.get(component);\n\n      if (!proxy) {\n        throw new Error(\"Could not find activated route proxy for view\");\n      }\n\n      proxy._futureSnapshot = activatedRoute._futureSnapshot;\n      proxy._routerState = activatedRoute._routerState;\n      proxy.snapshot = activatedRoute.snapshot;\n      proxy.outlet = activatedRoute.outlet;\n      proxy.component = activatedRoute.component;\n      this.currentActivatedRoute$.next({\n        component: component,\n        activatedRoute: activatedRoute\n      });\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_IonRouterOutlet = IonRouterOutlet;\n\n_defineProperty(IonRouterOutlet, \"\\u0275fac\", function _IonRouterOutlet_Factory(t) {\n  return new (t || _IonRouterOutlet)(i0.ɵɵinjectAttribute('name'), i0.ɵɵinjectAttribute('tabs'), i0.ɵɵdirectiveInject(i1.Location), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.ActivatedRoute), i0.ɵɵdirectiveInject(_IonRouterOutlet, 12));\n});\n\n/** @nocollapse */\n_defineProperty(IonRouterOutlet, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: _IonRouterOutlet,\n  selectors: [[\"ion-router-outlet\"]],\n  inputs: {\n    animated: \"animated\",\n    animation: \"animation\",\n    mode: \"mode\",\n    swipeGesture: \"swipeGesture\",\n    name: \"name\"\n  },\n  outputs: {\n    stackWillChange: \"stackWillChange\",\n    stackDidChange: \"stackDidChange\",\n    activateEvents: \"activate\",\n    deactivateEvents: \"deactivate\"\n  },\n  exportAs: [\"outlet\"]\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar OutletInjector = /*#__PURE__*/function () {\n  function OutletInjector(route, childContexts, parent) {\n    _classCallCheck(this, OutletInjector);\n\n    _defineProperty(this, \"route\", void 0);\n\n    _defineProperty(this, \"childContexts\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n\n  return _createClass(OutletInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      if (token === ActivatedRoute) {\n        return this.route;\n      }\n\n      if (token === ChildrenOutletContexts) {\n        return this.childContexts;\n      }\n\n      return this.parent.get(token, notFoundValue);\n    }\n  }]);\n}(); // TODO: FW-4785 - Remove this once Angular 15 support is dropped\n\n\nvar INPUT_BINDER = new InjectionToken('');\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\n\nvar RoutedComponentInputBinder = /*#__PURE__*/function () {\n  function RoutedComponentInputBinder() {\n    _classCallCheck(this, RoutedComponentInputBinder);\n\n    _defineProperty(this, \"outletDataSubscriptions\", new Map());\n  }\n\n  return _createClass(RoutedComponentInputBinder, [{\n    key: \"bindActivatedRouteToOutletComponent\",\n    value: function bindActivatedRouteToOutletComponent(outlet) {\n      this.unsubscribeFromRouteData(outlet);\n      this.subscribeToRouteData(outlet);\n    }\n  }, {\n    key: \"unsubscribeFromRouteData\",\n    value: function unsubscribeFromRouteData(outlet) {\n      var _this$outletDataSubsc;\n\n      (_this$outletDataSubsc = this.outletDataSubscriptions.get(outlet)) === null || _this$outletDataSubsc === void 0 ? void 0 : _this$outletDataSubsc.unsubscribe();\n      this.outletDataSubscriptions.delete(outlet);\n    }\n  }, {\n    key: \"subscribeToRouteData\",\n    value: function subscribeToRouteData(outlet) {\n      var _this17 = this;\n\n      var activatedRoute = outlet.activatedRoute;\n      var dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(function (_ref2, index) {\n        var _ref3 = _slicedToArray(_ref2, 3),\n            queryParams = _ref3[0],\n            params = _ref3[1],\n            data = _ref3[2];\n\n        data = _objectSpread(_objectSpread(_objectSpread({}, queryParams), params), data); // Get the first result from the data subscription synchronously so it's available to\n        // the component as soon as possible (and doesn't require a second change detection).\n\n        if (index === 0) {\n          return of(data);\n        } // Promise.resolve is used to avoid synchronously writing the wrong data when\n        // two of the Observables in the `combineLatest` stream emit one after\n        // another.\n\n\n        return Promise.resolve(data);\n      })).subscribe(function (data) {\n        // Outlet may have been deactivated or changed names to be associated with a different\n        // route\n        if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n          _this17.unsubscribeFromRouteData(outlet);\n\n          return;\n        }\n\n        var mirror = reflectComponentType(activatedRoute.component);\n\n        if (!mirror) {\n          _this17.unsubscribeFromRouteData(outlet);\n\n          return;\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(mirror.inputs),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var templateName = _step2.value.templateName;\n            outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      });\n      this.outletDataSubscriptions.set(outlet, dataSubscription);\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_RoutedComponentInputBinder = RoutedComponentInputBinder;\n\n_defineProperty(RoutedComponentInputBinder, \"\\u0275fac\", function _RoutedComponentInputBinder_Factory(t) {\n  return new (t || _RoutedComponentInputBinder)();\n});\n\n/** @nocollapse */\n_defineProperty(RoutedComponentInputBinder, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _RoutedComponentInputBinder,\n  factory: _RoutedComponentInputBinder.ɵfac\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar provideComponentInputBinding = function provideComponentInputBinding() {\n  return {\n    provide: INPUT_BINDER,\n    useFactory: componentInputBindingFactory,\n    deps: [Router]\n  };\n};\n\nfunction componentInputBindingFactory(router) {\n  /**\n   * We cast the router to any here, since the componentInputBindingEnabled\n   * property is not available until Angular v16.\n   */\n  if (router !== null && router !== void 0 && router.componentInputBindingEnabled) {\n    return new RoutedComponentInputBinder();\n  }\n\n  return null;\n}\n\nvar BACK_BUTTON_INPUTS = ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type'];\nvar IonBackButton = /*#__PURE__*/(function () {\n  var _IonBackButton;\n\n  var IonBackButton = (_IonBackButton = /*#__PURE__*/function () {\n    function IonBackButton(routerOutlet, navCtrl, config, r, z, c) {\n      _classCallCheck(this, IonBackButton);\n\n      _defineProperty(this, \"routerOutlet\", void 0);\n\n      _defineProperty(this, \"navCtrl\", void 0);\n\n      _defineProperty(this, \"config\", void 0);\n\n      _defineProperty(this, \"r\", void 0);\n\n      _defineProperty(this, \"z\", void 0);\n\n      _defineProperty(this, \"el\", void 0);\n\n      this.routerOutlet = routerOutlet;\n      this.navCtrl = navCtrl;\n      this.config = config;\n      this.r = r;\n      this.z = z;\n      c.detach();\n      this.el = this.r.nativeElement;\n    }\n    /**\n     * @internal\n     */\n\n\n    return _createClass(IonBackButton, [{\n      key: \"onClick\",\n      value: function onClick(ev) {\n        var _this$routerOutlet;\n\n        var defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\n\n        if ((_this$routerOutlet = this.routerOutlet) !== null && _this$routerOutlet !== void 0 && _this$routerOutlet.canGoBack()) {\n          this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\n          this.routerOutlet.pop();\n          ev.preventDefault();\n        } else if (defaultHref != null) {\n          this.navCtrl.navigateBack(defaultHref, {\n            animation: this.routerAnimation\n          });\n          ev.preventDefault();\n        }\n      }\n      /** @nocollapse */\n\n    }]);\n  }(), _defineProperty(_IonBackButton, \"\\u0275fac\", function _IonBackButton_Factory(t) {\n    return new (t || _IonBackButton)(i0.ɵɵdirectiveInject(IonRouterOutlet, 8), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(Config), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  }), _defineProperty(_IonBackButton, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonBackButton,\n    hostBindings: function _IonBackButton_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _IonBackButton_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      color: \"color\",\n      defaultHref: \"defaultHref\",\n      disabled: \"disabled\",\n      icon: \"icon\",\n      mode: \"mode\",\n      routerAnimation: \"routerAnimation\",\n      text: \"text\",\n      type: \"type\"\n    }\n  })), _IonBackButton);\n  IonBackButton = __decorate([ProxyCmp({\n    inputs: BACK_BUTTON_INPUTS\n  })], IonBackButton);\n  return IonBackButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Adds support for Ionic routing directions and animations to the base Angular router link directive.\n *\n * When the router link is clicked, the directive will assign the direction and\n * animation so that the routing integration will transition correctly.\n */\n\n\nvar RouterLinkDelegateDirective = /*#__PURE__*/function () {\n  function RouterLinkDelegateDirective(locationStrategy, navCtrl, elementRef, router, routerLink) {\n    _classCallCheck(this, RouterLinkDelegateDirective);\n\n    _defineProperty(this, \"locationStrategy\", void 0);\n\n    _defineProperty(this, \"navCtrl\", void 0);\n\n    _defineProperty(this, \"elementRef\", void 0);\n\n    _defineProperty(this, \"router\", void 0);\n\n    _defineProperty(this, \"routerLink\", void 0);\n\n    _defineProperty(this, \"routerDirection\", 'forward');\n\n    _defineProperty(this, \"routerAnimation\", void 0);\n\n    this.locationStrategy = locationStrategy;\n    this.navCtrl = navCtrl;\n    this.elementRef = elementRef;\n    this.router = router;\n    this.routerLink = routerLink;\n  }\n\n  return _createClass(RouterLinkDelegateDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.updateTargetUrlAndHref();\n    }\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges() {\n      this.updateTargetUrlAndHref();\n    }\n  }, {\n    key: \"updateTargetUrlAndHref\",\n    value: function updateTargetUrlAndHref() {\n      var _this$routerLink;\n\n      if ((_this$routerLink = this.routerLink) !== null && _this$routerLink !== void 0 && _this$routerLink.urlTree) {\n        var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n        this.elementRef.nativeElement.href = href;\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"onClick\",\n    value: function onClick(ev) {\n      this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n      /**\n       * This prevents the browser from\n       * performing a page reload when pressing\n       * an Ionic component with routerLink.\n       * The page reload interferes with routing\n       * and causes ion-back-button to disappear\n       * since the local history is wiped on reload.\n       */\n\n      ev.preventDefault();\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_RouterLinkDelegateDirective = RouterLinkDelegateDirective;\n\n_defineProperty(RouterLinkDelegateDirective, \"\\u0275fac\", function _RouterLinkDelegateDirective_Factory(t) {\n  return new (t || _RouterLinkDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n});\n\n/** @nocollapse */\n_defineProperty(RouterLinkDelegateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: _RouterLinkDelegateDirective,\n  selectors: [[\"\", \"routerLink\", \"\", 5, \"a\", 5, \"area\"]],\n  hostBindings: function _RouterLinkDelegateDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"click\", function _RouterLinkDelegateDirective_click_HostBindingHandler($event) {\n        return ctx.onClick($event);\n      });\n    }\n  },\n  inputs: {\n    routerDirection: \"routerDirection\",\n    routerAnimation: \"routerAnimation\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar RouterLinkWithHrefDelegateDirective = /*#__PURE__*/function () {\n  function RouterLinkWithHrefDelegateDirective(locationStrategy, navCtrl, elementRef, router, routerLink) {\n    _classCallCheck(this, RouterLinkWithHrefDelegateDirective);\n\n    _defineProperty(this, \"locationStrategy\", void 0);\n\n    _defineProperty(this, \"navCtrl\", void 0);\n\n    _defineProperty(this, \"elementRef\", void 0);\n\n    _defineProperty(this, \"router\", void 0);\n\n    _defineProperty(this, \"routerLink\", void 0);\n\n    _defineProperty(this, \"routerDirection\", 'forward');\n\n    _defineProperty(this, \"routerAnimation\", void 0);\n\n    this.locationStrategy = locationStrategy;\n    this.navCtrl = navCtrl;\n    this.elementRef = elementRef;\n    this.router = router;\n    this.routerLink = routerLink;\n  }\n\n  return _createClass(RouterLinkWithHrefDelegateDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.updateTargetUrlAndHref();\n    }\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges() {\n      this.updateTargetUrlAndHref();\n    }\n  }, {\n    key: \"updateTargetUrlAndHref\",\n    value: function updateTargetUrlAndHref() {\n      var _this$routerLink2;\n\n      if ((_this$routerLink2 = this.routerLink) !== null && _this$routerLink2 !== void 0 && _this$routerLink2.urlTree) {\n        var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n        this.elementRef.nativeElement.href = href;\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"onClick\",\n    value: function onClick() {\n      this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_RouterLinkWithHrefDelegateDirective = RouterLinkWithHrefDelegateDirective;\n\n_defineProperty(RouterLinkWithHrefDelegateDirective, \"\\u0275fac\", function _RouterLinkWithHrefDelegateDirective_Factory(t) {\n  return new (t || _RouterLinkWithHrefDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n});\n\n/** @nocollapse */\n_defineProperty(RouterLinkWithHrefDelegateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: _RouterLinkWithHrefDelegateDirective,\n  selectors: [[\"a\", \"routerLink\", \"\"], [\"area\", \"routerLink\", \"\"]],\n  hostBindings: function _RouterLinkWithHrefDelegateDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"click\", function _RouterLinkWithHrefDelegateDirective_click_HostBindingHandler() {\n        return ctx.onClick();\n      });\n    }\n  },\n  inputs: {\n    routerDirection: \"routerDirection\",\n    routerAnimation: \"routerAnimation\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar NAV_INPUTS = ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'];\nvar NAV_METHODS = ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious'];\nvar IonNav = /*#__PURE__*/(function () {\n  var _IonNav;\n\n  var IonNav = (_IonNav = /*#__PURE__*/_createClass(function IonNav(ref, environmentInjector, injector, angularDelegate, z, c) {\n    _classCallCheck(this, IonNav);\n\n    _defineProperty(this, \"z\", void 0);\n\n    _defineProperty(this, \"el\", void 0);\n\n    this.z = z;\n    c.detach();\n    this.el = ref.nativeElement;\n    ref.nativeElement.delegate = angularDelegate.create(environmentInjector, injector);\n    proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\n  }\n  /** @nocollapse */\n  ), _defineProperty(_IonNav, \"\\u0275fac\", function _IonNav_Factory(t) {\n    return new (t || _IonNav)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.EnvironmentInjector), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(AngularDelegate), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  }), _defineProperty(_IonNav, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonNav,\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      root: \"root\",\n      rootParams: \"rootParams\",\n      swipeGesture: \"swipeGesture\"\n    }\n  })), _IonNav);\n  IonNav = __decorate([ProxyCmp({\n    inputs: NAV_INPUTS,\n    methods: NAV_METHODS\n  })], IonNav);\n  return IonNav;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line @angular-eslint/directive-class-suffix\n\n\nvar IonTabs = /*#__PURE__*/function () {\n  function IonTabs(navCtrl) {\n    _classCallCheck(this, IonTabs);\n\n    _defineProperty(this, \"navCtrl\", void 0);\n\n    _defineProperty(this, \"tabsInner\", void 0);\n\n    /**\n     * Emitted before the tab view is changed.\n     */\n    _defineProperty(this, \"ionTabsWillChange\", new EventEmitter());\n\n    /**\n     * Emitted after the tab view is changed.\n     */\n    _defineProperty(this, \"ionTabsDidChange\", new EventEmitter());\n\n    _defineProperty(this, \"tabBarSlot\", 'bottom');\n\n    this.navCtrl = navCtrl;\n  }\n\n  return _createClass(IonTabs, [{\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      this.detectSlotChanges();\n    }\n  }, {\n    key: \"ngAfterContentChecked\",\n    value: function ngAfterContentChecked() {\n      this.detectSlotChanges();\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"onStackWillChange\",\n    value: function onStackWillChange(_ref4) {\n      var enteringView = _ref4.enteringView,\n          tabSwitch = _ref4.tabSwitch;\n      var stackId = enteringView.stackId;\n\n      if (tabSwitch && stackId !== undefined) {\n        this.ionTabsWillChange.emit({\n          tab: stackId\n        });\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"onStackDidChange\",\n    value: function onStackDidChange(_ref5) {\n      var enteringView = _ref5.enteringView,\n          tabSwitch = _ref5.tabSwitch;\n      var stackId = enteringView.stackId;\n\n      if (tabSwitch && stackId !== undefined) {\n        if (this.tabBar) {\n          this.tabBar.selectedTab = stackId;\n        }\n\n        this.ionTabsDidChange.emit({\n          tab: stackId\n        });\n      }\n    }\n    /**\n     * When a tab button is clicked, there are several scenarios:\n     * 1. If the selected tab is currently active (the tab button has been clicked\n     *    again), then it should go to the root view for that tab.\n     *\n     *   a. Get the saved root view from the router outlet. If the saved root view\n     *      matches the tabRootUrl, set the route view to this view including the\n     *      navigation extras.\n     *   b. If the saved root view from the router outlet does\n     *      not match, navigate to the tabRootUrl. No navigation extras are\n     *      included.\n     *\n     * 2. If the current tab tab is not currently selected, get the last route\n     *    view from the router outlet.\n     *\n     *   a. If the last route view exists, navigate to that view including any\n     *      navigation extras\n     *   b. If the last route view doesn't exist, then navigate\n     *      to the default tabRootUrl\n     */\n\n  }, {\n    key: \"select\",\n    value: function select(tabOrEvent) {\n      var isTabString = typeof tabOrEvent === 'string';\n      var tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;\n      var alreadySelected = this.outlet.getActiveStackId() === tab;\n      var tabRootUrl = \"\".concat(this.outlet.tabsPrefix, \"/\").concat(tab);\n      /**\n       * If this is a nested tab, prevent the event\n       * from bubbling otherwise the outer tabs\n       * will respond to this event too, causing\n       * the app to get directed to the wrong place.\n       */\n\n      if (!isTabString) {\n        tabOrEvent.stopPropagation();\n      }\n\n      if (alreadySelected) {\n        var activeStackId = this.outlet.getActiveStackId();\n        var activeView = this.outlet.getLastRouteView(activeStackId); // If on root tab, do not navigate to root tab again\n\n        if ((activeView === null || activeView === void 0 ? void 0 : activeView.url) === tabRootUrl) {\n          return;\n        }\n\n        var rootView = this.outlet.getRootView(tab);\n        var navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\n        return this.navCtrl.navigateRoot(tabRootUrl, _objectSpread(_objectSpread({}, navigationExtras), {}, {\n          animated: true,\n          animationDirection: 'back'\n        }));\n      } else {\n        var lastRoute = this.outlet.getLastRouteView(tab);\n        /**\n         * If there is a lastRoute, goto that, otherwise goto the fallback url of the\n         * selected tab\n         */\n\n        var url = (lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.url) || tabRootUrl;\n\n        var _navigationExtras = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.savedExtras;\n\n        return this.navCtrl.navigateRoot(url, _objectSpread(_objectSpread({}, _navigationExtras), {}, {\n          animated: true,\n          animationDirection: 'back'\n        }));\n      }\n    }\n  }, {\n    key: \"getSelected\",\n    value: function getSelected() {\n      return this.outlet.getActiveStackId();\n    }\n    /**\n     * Detects changes to the slot attribute of the tab bar.\n     *\n     * If the slot attribute has changed, then the tab bar\n     * should be relocated to the new slot position.\n     */\n\n  }, {\n    key: \"detectSlotChanges\",\n    value: function detectSlotChanges() {\n      var _this18 = this;\n\n      this.tabBars.forEach(function (tabBar) {\n        // el is a protected attribute from the generated component wrapper\n        var currentSlot = tabBar.el.getAttribute('slot');\n\n        if (currentSlot !== _this18.tabBarSlot) {\n          _this18.tabBarSlot = currentSlot;\n\n          _this18.relocateTabBar();\n        }\n      });\n    }\n    /**\n     * Relocates the tab bar to the new slot position.\n     */\n\n  }, {\n    key: \"relocateTabBar\",\n    value: function relocateTabBar() {\n      /**\n       * `el` is a protected attribute from the generated component wrapper.\n       * To avoid having to manually create the wrapper for tab bar, we\n       * cast the tab bar to any and access the protected attribute.\n       */\n      var tabBar = this.tabBar.el;\n\n      if (this.tabBarSlot === 'top') {\n        /**\n         * A tab bar with a slot of \"top\" should be inserted\n         * at the top of the container.\n         */\n        this.tabsInner.nativeElement.before(tabBar);\n      } else {\n        /**\n         * A tab bar with a slot of \"bottom\" or without a slot\n         * should be inserted at the end of the container.\n         */\n        this.tabsInner.nativeElement.after(tabBar);\n      }\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_IonTabs = IonTabs;\n\n_defineProperty(IonTabs, \"\\u0275fac\", function _IonTabs_Factory(t) {\n  return new (t || _IonTabs)(i0.ɵɵdirectiveInject(NavController));\n});\n\n/** @nocollapse */\n_defineProperty(IonTabs, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: _IonTabs,\n  selectors: [[\"ion-tabs\"]],\n  viewQuery: function _IonTabs_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 7, ElementRef);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabsInner = _t.first);\n    }\n  },\n  hostBindings: function _IonTabs_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"ionTabButtonClick\", function _IonTabs_ionTabButtonClick_HostBindingHandler($event) {\n        return ctx.select($event);\n      });\n    }\n  },\n  outputs: {\n    ionTabsWillChange: \"ionTabsWillChange\",\n    ionTabsDidChange: \"ionTabsDidChange\"\n  }\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar raf = function raf(h) {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n\n  return setTimeout(h);\n}; // TODO(FW-2827): types\n\n\nvar ValueAccessor = /*#__PURE__*/function () {\n  function ValueAccessor(injector, elementRef) {\n    _classCallCheck(this, ValueAccessor);\n\n    _defineProperty(this, \"injector\", void 0);\n\n    _defineProperty(this, \"elementRef\", void 0);\n\n    _defineProperty(this, \"onChange\", function () {\n      /**/\n    });\n\n    _defineProperty(this, \"onTouched\", function () {\n      /**/\n    });\n\n    _defineProperty(this, \"lastValue\", void 0);\n\n    _defineProperty(this, \"statusChanges\", void 0);\n\n    this.injector = injector;\n    this.elementRef = elementRef;\n  }\n\n  return _createClass(ValueAccessor, [{\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      this.elementRef.nativeElement.value = this.lastValue = value;\n      setIonicClasses(this.elementRef);\n    }\n    /**\n     * Notifies the ControlValueAccessor of a change in the value of the control.\n     *\n     * This is called by each of the ValueAccessor directives when we want to update\n     * the status and validity of the form control. For example with text components this\n     * is called when the ionInput event is fired. For select components this is called\n     * when the ionChange event is fired.\n     *\n     * This also updates the Ionic form status classes on the element.\n     *\n     * @param el The component element.\n     * @param value The new value of the control.\n     */\n\n  }, {\n    key: \"handleValueChange\",\n    value: function handleValueChange(el, value) {\n      if (el === this.elementRef.nativeElement) {\n        if (value !== this.lastValue) {\n          this.lastValue = value;\n          this.onChange(value);\n        }\n\n        setIonicClasses(this.elementRef);\n      }\n    }\n  }, {\n    key: \"_handleBlurEvent\",\n    value: function _handleBlurEvent(el) {\n      if (el === this.elementRef.nativeElement) {\n        this.onTouched();\n        setIonicClasses(this.elementRef);\n      }\n    }\n  }, {\n    key: \"registerOnChange\",\n    value: function registerOnChange(fn) {\n      this.onChange = fn;\n    }\n  }, {\n    key: \"registerOnTouched\",\n    value: function registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n  }, {\n    key: \"setDisabledState\",\n    value: function setDisabledState(isDisabled) {\n      this.elementRef.nativeElement.disabled = isDisabled;\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.statusChanges) {\n        this.statusChanges.unsubscribe();\n      }\n    }\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      var _this19 = this;\n\n      var ngControl;\n\n      try {\n        ngControl = this.injector.get(NgControl);\n      } catch (_unused) {\n        /* No FormControl or ngModel binding */\n      }\n\n      if (!ngControl) {\n        return;\n      } // Listen for changes in validity, disabled, or pending states\n\n\n      if (ngControl.statusChanges) {\n        this.statusChanges = ngControl.statusChanges.subscribe(function () {\n          return setIonicClasses(_this19.elementRef);\n        });\n      }\n      /**\n       * TODO FW-2787: Remove this in favor of https://github.com/angular/angular/issues/10887\n       * whenever it is implemented.\n       */\n\n\n      var formControl = ngControl.control;\n\n      if (formControl) {\n        var methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\n        methodsToPatch.forEach(function (method) {\n          if (typeof formControl[method] !== 'undefined') {\n            var oldFn = formControl[method].bind(formControl);\n\n            formControl[method] = function () {\n              oldFn.apply(void 0, arguments);\n              setIonicClasses(_this19.elementRef);\n            };\n          }\n        });\n      }\n    }\n    /** @nocollapse */\n\n  }]);\n}();\n\n_ValueAccessor = ValueAccessor;\n\n_defineProperty(ValueAccessor, \"\\u0275fac\", function _ValueAccessor_Factory(t) {\n  return new (t || _ValueAccessor)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n});\n\n/** @nocollapse */\n_defineProperty(ValueAccessor, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: _ValueAccessor,\n  hostBindings: function _ValueAccessor_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"ionBlur\", function _ValueAccessor_ionBlur_HostBindingHandler($event) {\n        return ctx._handleBlurEvent($event.target);\n      });\n    }\n  }\n}));\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar setIonicClasses = function setIonicClasses(element) {\n  raf(function () {\n    var input = element.nativeElement;\n    var hasValue = input.value != null && input.value.toString().length > 0;\n    var classes = getClasses(input);\n    setClasses(input, classes);\n    var item = input.closest('ion-item');\n\n    if (item) {\n      if (hasValue) {\n        setClasses(item, [].concat(_toConsumableArray(classes), ['item-has-value']));\n      } else {\n        setClasses(item, classes);\n      }\n    }\n  });\n};\n\nvar getClasses = function getClasses(element) {\n  var classList = element.classList;\n  var classes = [];\n\n  for (var i = 0; i < classList.length; i++) {\n    var item = classList.item(i);\n\n    if (item !== null && startsWith(item, 'ng-')) {\n      classes.push(\"ion-\".concat(item.substring(3)));\n    }\n  }\n\n  return classes;\n};\n\nvar setClasses = function setClasses(element, classes) {\n  var classList = element.classList;\n  classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');\n  classList.add.apply(classList, _toConsumableArray(classes));\n};\n\nvar startsWith = function startsWith(input, search) {\n  return input.substring(0, search.length) === search;\n};\n/**\n * Provides a way to customize when activated routes get reused.\n */\n\n\nvar IonicRouteStrategy = /*#__PURE__*/function () {\n  function IonicRouteStrategy() {\n    _classCallCheck(this, IonicRouteStrategy);\n  }\n\n  return _createClass(IonicRouteStrategy, [{\n    key: \"shouldDetach\",\n    value:\n    /**\n     * Whether the given route should detach for later reuse.\n     */\n    function shouldDetach(_route) {\n      return false;\n    }\n    /**\n     * Returns `false`, meaning the route (and its subtree) is never reattached\n     */\n\n  }, {\n    key: \"shouldAttach\",\n    value: function shouldAttach(_route) {\n      return false;\n    }\n    /**\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(_route, _detachedTree) {\n      return;\n    }\n    /**\n     * Returns `null` because this strategy does not store routes for later re-use.\n     */\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(_route) {\n      return null;\n    }\n    /**\n     * Determines if a route should be reused.\n     * This strategy returns `true` when the future route config and\n     * current route config are identical and all route parameters are identical.\n     */\n\n  }, {\n    key: \"shouldReuseRoute\",\n    value: function shouldReuseRoute(future, curr) {\n      if (future.routeConfig !== curr.routeConfig) {\n        return false;\n      } // checking router params\n\n\n      var futureParams = future.params;\n      var currentParams = curr.params;\n      var keysA = Object.keys(futureParams);\n      var keysB = Object.keys(currentParams);\n\n      if (keysA.length !== keysB.length) {\n        return false;\n      } // Test for A's keys different from B.\n\n\n      for (var _i = 0, _keysA = keysA; _i < _keysA.length; _i++) {\n        var key = _keysA[_i];\n\n        if (currentParams[key] !== futureParams[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n}(); // TODO(FW-2827): types\n\n\nvar OverlayBaseController = /*#__PURE__*/function () {\n  function OverlayBaseController(ctrl) {\n    _classCallCheck(this, OverlayBaseController);\n\n    _defineProperty(this, \"ctrl\", void 0);\n\n    this.ctrl = ctrl;\n  }\n  /**\n   * Creates a new overlay\n   */\n\n\n  return _createClass(OverlayBaseController, [{\n    key: \"create\",\n    value: function create(opts) {\n      return this.ctrl.create(opts || {});\n    }\n    /**\n     * When `id` is not provided, it dismisses the top overlay.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role, id) {\n      return this.ctrl.dismiss(data, role, id);\n    }\n    /**\n     * Returns the top overlay.\n     */\n\n  }, {\n    key: \"getTop\",\n    value: function getTop() {\n      return this.ctrl.getTop();\n    }\n  }]);\n}();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularDelegate, Config, ConfigToken, DomController, IonBackButton, IonModal, IonNav, IonPopover, IonRouterOutlet, IonTabs, IonicRouteStrategy, MenuController, NavController, NavParams, OverlayBaseController, Platform, ProxyCmp, RouterLinkDelegateDirective, RouterLinkWithHrefDelegateDirective, ValueAccessor, bindLifecycleEvents, provideComponentInputBinding, raf, setIonicClasses }; //# sourceMappingURL=ionic-angular-common.mjs.map","map":null,"metadata":{},"sourceType":"module"}