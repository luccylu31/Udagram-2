{"ast":null,"code":"import _possibleConstructorReturn from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _isNativeReflectConstruct from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\";\nimport _getPrototypeOf from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _wrapNativeSuper from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _regeneratorRuntime from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createClass from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n\n/*\n Stencil Client Platform v4.19.2 | MIT Licensed | https://stenciljs.com\n */\nvar __defProp = Object.defineProperty;\n\nvar __export = function __export(target, all) {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n}; // src/client/client-build.ts\n\n\nimport { BUILD } from \"@stencil/core/internal/app-data\";\nvar Build = {\n  isDev: BUILD.isDev ? true : false,\n  isBrowser: true,\n  isServer: false,\n  isTesting: BUILD.isTesting ? true : false\n}; // src/client/client-host-ref.ts\n\nimport { BUILD as BUILD2 } from \"@stencil/core/internal/app-data\";\nvar hostRefs = BUILD2.hotModuleReplacement ? window.__STENCIL_HOSTREFS__ || (window.__STENCIL_HOSTREFS__ = /* @__PURE__ */new WeakMap()) : /* @__PURE__ */new WeakMap();\n\nvar getHostRef = function getHostRef(ref) {\n  return hostRefs.get(ref);\n};\n\nvar registerInstance = function registerInstance(lazyInstance, hostRef) {\n  return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\n};\n\nvar registerHost = function registerHost(hostElement, cmpMeta) {\n  var hostRef = {\n    $flags$: 0,\n    $hostElement$: hostElement,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: /* @__PURE__ */new Map()\n  };\n\n  if (BUILD2.isDev) {\n    hostRef.$renderCount$ = 0;\n  }\n\n  if (BUILD2.method && BUILD2.lazyLoad) {\n    hostRef.$onInstancePromise$ = new Promise(function (r) {\n      return hostRef.$onInstanceResolve$ = r;\n    });\n  }\n\n  if (BUILD2.asyncLoading) {\n    hostRef.$onReadyPromise$ = new Promise(function (r) {\n      return hostRef.$onReadyResolve$ = r;\n    });\n    hostElement[\"s-p\"] = [];\n    hostElement[\"s-rc\"] = [];\n  }\n\n  return hostRefs.set(hostElement, hostRef);\n};\n\nvar isMemberInElement = function isMemberInElement(elm, memberName) {\n  return memberName in elm;\n}; // src/client/client-load-module.ts\n\n\nimport { BUILD as BUILD4 } from \"@stencil/core/internal/app-data\"; // src/client/client-log.ts\n\nimport { BUILD as BUILD3 } from \"@stencil/core/internal/app-data\";\nvar customError;\n\nvar consoleError = function consoleError(e, el) {\n  return (customError || console.error)(e, el);\n};\n\nvar STENCIL_DEV_MODE = BUILD3.isTesting ? [\"STENCIL:\"] : [\"%cstencil\", \"color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px\"];\n\nvar consoleDevError = function consoleDevError() {\n  var _console;\n\n  for (var _len = arguments.length, m = new Array(_len), _key = 0; _key < _len; _key++) {\n    m[_key] = arguments[_key];\n  }\n\n  return (_console = console).error.apply(_console, STENCIL_DEV_MODE.concat(m));\n};\n\nvar consoleDevWarn = function consoleDevWarn() {\n  var _console2;\n\n  for (var _len2 = arguments.length, m = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    m[_key2] = arguments[_key2];\n  }\n\n  return (_console2 = console).warn.apply(_console2, STENCIL_DEV_MODE.concat(m));\n};\n\nvar consoleDevInfo = function consoleDevInfo() {\n  var _console3;\n\n  for (var _len3 = arguments.length, m = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    m[_key3] = arguments[_key3];\n  }\n\n  return (_console3 = console).info.apply(_console3, STENCIL_DEV_MODE.concat(m));\n};\n\nvar setErrorHandler = function setErrorHandler(handler) {\n  return customError = handler;\n}; // src/client/client-load-module.ts\n\n\nvar cmpModules = /* @__PURE__ */new Map();\nvar MODULE_IMPORT_PREFIX = \"./\";\n\nvar loadModule = function loadModule(cmpMeta, hostRef, hmrVersionId) {\n  var exportName = cmpMeta.$tagName$.replace(/-/g, \"_\");\n  var bundleId = cmpMeta.$lazyBundleId$;\n\n  if (BUILD4.isDev && typeof bundleId !== \"string\") {\n    consoleDevError(\"Trying to lazily load component <\".concat(cmpMeta.$tagName$, \"> with style mode \\\"\").concat(hostRef.$modeName$, \"\\\", but it does not exist.\"));\n    return void 0;\n  } else if (!bundleId) {\n    return void 0;\n  }\n\n  var module = !BUILD4.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n\n  if (module) {\n    return module[exportName];\n  }\n  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/\n\n\n  return import(\n  /* @vite-ignore */\n\n  /* webpackInclude: /\\.entry\\.js$/ */\n\n  /* webpackExclude: /\\.system\\.entry\\.js$/ */\n\n  /* webpackMode: \"lazy\" */\n  \"./\".concat(bundleId, \".entry.js\").concat(BUILD4.hotModuleReplacement && hmrVersionId ? \"?s-hmr=\" + hmrVersionId : \"\")).then(function (importedModule) {\n    if (!BUILD4.hotModuleReplacement) {\n      cmpModules.set(bundleId, importedModule);\n    }\n\n    return importedModule[exportName];\n  }, consoleError);\n}; // src/client/client-style.ts\n\n\nvar styles = /* @__PURE__ */new Map();\nvar modeResolutionChain = []; // src/client/client-task-queue.ts\n\nimport { BUILD as BUILD6 } from \"@stencil/core/internal/app-data\"; // src/runtime/runtime-constants.ts\n\nvar CONTENT_REF_ID = \"r\";\nvar ORG_LOCATION_ID = \"o\";\nvar SLOT_NODE_ID = \"s\";\nvar TEXT_NODE_ID = \"t\";\nvar HYDRATE_ID = \"s-id\";\nvar HYDRATED_STYLE_ID = \"sty-id\";\nvar HYDRATE_CHILD_ID = \"c-id\";\nvar HYDRATED_CSS = \"{visibility:hidden}.hydrated{visibility:inherit}\";\nvar SLOT_FB_CSS = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\";\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\";\nvar FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS = [\"formAssociatedCallback\", \"formResetCallback\", \"formDisabledCallback\", \"formStateRestoreCallback\"]; // src/client/client-window.ts\n\nimport { BUILD as BUILD5 } from \"@stencil/core/internal/app-data\";\nvar win = typeof window !== \"undefined\" ? window : {};\nvar doc = win.document || {\n  head: {}\n};\n\nvar H = win.HTMLElement || /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n  }\n\n  return _createClass(_class);\n}();\n\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: \"\",\n  jmp: function jmp(h2) {\n    return h2();\n  },\n  raf: function raf(h2) {\n    return requestAnimationFrame(h2);\n  },\n  ael: function ael(el, eventName, listener, opts) {\n    return el.addEventListener(eventName, listener, opts);\n  },\n  rel: function rel(el, eventName, listener, opts) {\n    return el.removeEventListener(eventName, listener, opts);\n  },\n  ce: function ce(eventName, opts) {\n    return new CustomEvent(eventName, opts);\n  }\n};\n\nvar setPlatformHelpers = function setPlatformHelpers(helpers) {\n  Object.assign(plt, helpers);\n};\n\nvar supportsShadow = BUILD5.shadowDom;\n\nvar supportsListenerOptions = /* @__PURE__ */function () {\n  var supportsListenerOptions2 = false;\n\n  try {\n    doc.addEventListener(\"e\", null, Object.defineProperty({}, \"passive\", {\n      get: function get() {\n        supportsListenerOptions2 = true;\n      }\n    }));\n  } catch (e) {}\n\n  return supportsListenerOptions2;\n}();\n\nvar promiseResolve = function promiseResolve(v) {\n  return Promise.resolve(v);\n};\n\nvar supportsConstructableStylesheets = BUILD5.constructableCSS ? /* @__PURE__ */function () {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === \"function\";\n  } catch (e) {}\n\n  return false;\n}() : false; // src/client/client-task-queue.ts\n\nvar queueCongestion = 0;\nvar queuePending = false;\nvar queueDomReads = [];\nvar queueDomWrites = [];\nvar queueDomWritesLow = [];\n\nvar queueTask = function queueTask(queue, write) {\n  return function (cb) {\n    queue.push(cb);\n\n    if (!queuePending) {\n      queuePending = true;\n\n      if (write && plt.$flags$ & 4\n      /* queueSync */\n      ) {\n        nextTick(flush);\n      } else {\n        plt.raf(flush);\n      }\n    }\n  };\n};\n\nvar consume = function consume(queue) {\n  for (var i2 = 0; i2 < queue.length; i2++) {\n    try {\n      queue[i2](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  queue.length = 0;\n};\n\nvar consumeTimeout = function consumeTimeout(queue, timeout) {\n  var i2 = 0;\n  var ts = 0;\n\n  while (i2 < queue.length && (ts = performance.now()) < timeout) {\n    try {\n      queue[i2++](ts);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  if (i2 === queue.length) {\n    queue.length = 0;\n  } else if (i2 !== 0) {\n    queue.splice(0, i2);\n  }\n};\n\nvar flush = function flush() {\n  if (BUILD6.asyncQueue) {\n    queueCongestion++;\n  }\n\n  consume(queueDomReads);\n\n  if (BUILD6.asyncQueue) {\n    var timeout = (plt.$flags$ & 6\n    /* queueMask */\n    ) === 2\n    /* appLoaded */\n    ? performance.now() + 14 * Math.ceil(queueCongestion * (1 / 10)) : Infinity;\n    consumeTimeout(queueDomWrites, timeout);\n    consumeTimeout(queueDomWritesLow, timeout);\n\n    if (queueDomWrites.length > 0) {\n      queueDomWritesLow.push.apply(queueDomWritesLow, queueDomWrites);\n      queueDomWrites.length = 0;\n    }\n\n    if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {\n      plt.raf(flush);\n    } else {\n      queueCongestion = 0;\n    }\n  } else {\n    consume(queueDomWrites);\n\n    if (queuePending = queueDomReads.length > 0) {\n      plt.raf(flush);\n    }\n  }\n};\n\nvar nextTick = function nextTick(cb) {\n  return promiseResolve().then(cb);\n};\n\nvar readTask = /* @__PURE__ */queueTask(queueDomReads, false);\nvar writeTask = /* @__PURE__ */queueTask(queueDomWrites, true); // src/client/index.ts\n\nimport { BUILD as BUILD27, Env, NAMESPACE as NAMESPACE2 } from \"@stencil/core/internal/app-data\"; // src/runtime/asset-path.ts\n\nvar getAssetPath = function getAssetPath(path) {\n  var assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\n\nvar setAssetPath = function setAssetPath(path) {\n  return plt.$resourcesUrl$ = path;\n}; // src/runtime/bootstrap-custom-element.ts\n\n\nimport { BUILD as BUILD24 } from \"@stencil/core/internal/app-data\"; // src/utils/constants.ts\n\nvar EMPTY_OBJ = {};\nvar SVG_NS = \"http://www.w3.org/2000/svg\";\nvar HTML_NS = \"http://www.w3.org/1999/xhtml\"; // src/utils/helpers.ts\n\nvar isDef = function isDef(v) {\n  return v != null;\n};\n\nvar isComplexType = function isComplexType(o) {\n  o = typeof o;\n  return o === \"object\" || o === \"function\";\n}; // src/utils/query-nonce-meta-tag-content.ts\n\n\nfunction queryNonceMetaTagContent(doc2) {\n  var _a, _b, _c;\n\n  return (_c = (_b = (_a = doc2.head) == null ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) == null ? void 0 : _b.getAttribute(\"content\")) != null ? _c : void 0;\n} // src/utils/result.ts\n\n\nvar result_exports = {};\n\n__export(result_exports, {\n  err: function err() {\n    return _err;\n  },\n  map: function map() {\n    return _map;\n  },\n  ok: function ok() {\n    return _ok;\n  },\n  unwrap: function unwrap() {\n    return _unwrap;\n  },\n  unwrapErr: function unwrapErr() {\n    return _unwrapErr;\n  }\n});\n\nvar _ok = function _ok(value) {\n  return {\n    isOk: true,\n    isErr: false,\n    value: value\n  };\n};\n\nvar _err = function _err(value) {\n  return {\n    isOk: false,\n    isErr: true,\n    value: value\n  };\n};\n\nfunction _map(result, fn) {\n  if (result.isOk) {\n    var val = fn(result.value);\n\n    if (val instanceof Promise) {\n      return val.then(function (newVal) {\n        return _ok(newVal);\n      });\n    } else {\n      return _ok(val);\n    }\n  }\n\n  if (result.isErr) {\n    var value = result.value;\n    return _err(value);\n  }\n\n  throw \"should never get here\";\n}\n\nvar _unwrap = function _unwrap(result) {\n  if (result.isOk) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\nvar _unwrapErr = function _unwrapErr(result) {\n  if (result.isErr) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n}; // src/runtime/connected-callback.ts\n\n\nimport { BUILD as BUILD21 } from \"@stencil/core/internal/app-data\"; // src/runtime/client-hydrate.ts\n\nimport { BUILD as BUILD9 } from \"@stencil/core/internal/app-data\"; // src/runtime/profile.ts\n\nimport { BUILD as BUILD7 } from \"@stencil/core/internal/app-data\";\nvar i = 0;\n\nvar createTime = function createTime(fnName) {\n  var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n  if (BUILD7.profile && performance.mark) {\n    var key = \"st:\".concat(fnName, \":\").concat(tagName, \":\").concat(i++);\n    performance.mark(key);\n    return function () {\n      return performance.measure(\"[Stencil] \".concat(fnName, \"() <\").concat(tagName, \">\"), key);\n    };\n  } else {\n    return function () {\n      return;\n    };\n  }\n};\n\nvar uniqueTime = function uniqueTime(key, measureText) {\n  if (BUILD7.profile && performance.mark) {\n    if (performance.getEntriesByName(key, \"mark\").length === 0) {\n      performance.mark(key);\n    }\n\n    return function () {\n      if (performance.getEntriesByName(measureText, \"measure\").length === 0) {\n        performance.measure(measureText, key);\n      }\n    };\n  } else {\n    return function () {\n      return;\n    };\n  }\n};\n\nvar inspect = function inspect(ref) {\n  var hostRef = getHostRef(ref);\n\n  if (!hostRef) {\n    return void 0;\n  }\n\n  var flags = hostRef.$flags$;\n  var hostElement = hostRef.$hostElement$;\n  return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({\n    renderCount: hostRef.$renderCount$,\n    flags: {\n      hasRendered: !!(flags & 2\n      /* hasRendered */\n      ),\n      hasConnected: !!(flags & 1\n      /* hasConnected */\n      ),\n      isWaitingForChildren: !!(flags & 4\n      /* isWaitingForChildren */\n      ),\n      isConstructingInstance: !!(flags & 8\n      /* isConstructingInstance */\n      ),\n      isQueuedForUpdate: !!(flags & 16\n      /* isQueuedForUpdate */\n      ),\n      hasInitializedComponent: !!(flags & 32\n      /* hasInitializedComponent */\n      ),\n      hasLoadedComponent: !!(flags & 64\n      /* hasLoadedComponent */\n      ),\n      isWatchReady: !!(flags & 128\n      /* isWatchReady */\n      ),\n      isListenReady: !!(flags & 256\n      /* isListenReady */\n      ),\n      needsRerender: !!(flags & 512\n      /* needsRerender */\n      )\n    },\n    instanceValues: hostRef.$instanceValues$,\n    ancestorComponent: hostRef.$ancestorComponent$,\n    hostElement: hostElement,\n    lazyInstance: hostRef.$lazyInstance$,\n    vnode: hostRef.$vnode$,\n    modeName: hostRef.$modeName$,\n    onReadyPromise: hostRef.$onReadyPromise$,\n    onReadyResolve: hostRef.$onReadyResolve$,\n    onInstancePromise: hostRef.$onInstancePromise$,\n    onInstanceResolve: hostRef.$onInstanceResolve$,\n    onRenderResolve: hostRef.$onRenderResolve$,\n    queuedListeners: hostRef.$queuedListeners$,\n    rmListeners: hostRef.$rmListeners$\n  }, \"s-id\", hostElement[\"s-id\"]), \"s-cr\", hostElement[\"s-cr\"]), \"s-lr\", hostElement[\"s-lr\"]), \"s-p\", hostElement[\"s-p\"]), \"s-rc\", hostElement[\"s-rc\"]), \"s-sc\", hostElement[\"s-sc\"]);\n};\n\nvar installDevTools = function installDevTools() {\n  if (BUILD7.devTools) {\n    var stencil = win.stencil = win.stencil || {};\n    var originalInspect = stencil.inspect;\n\n    stencil.inspect = function (ref) {\n      var result = inspect(ref);\n\n      if (!result && typeof originalInspect === \"function\") {\n        result = originalInspect(ref);\n      }\n\n      return result;\n    };\n  }\n}; // src/runtime/vdom/h.ts\n\n\nimport { BUILD as BUILD8 } from \"@stencil/core/internal/app-data\";\n\nvar h = function h(nodeName, vnodeData) {\n  var child = null;\n  var key = null;\n  var slotName = null;\n  var simple = false;\n  var lastSimple = false;\n  var vNodeChildren = [];\n\n  var walk = function walk(c) {\n    for (var i2 = 0; i2 < c.length; i2++) {\n      child = c[i2];\n\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== \"boolean\") {\n        if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n          child = String(child);\n        } else if (BUILD8.isDev && typeof nodeName !== \"function\" && child.$flags$ === void 0) {\n          consoleDevError(\"vNode passed as children has unexpected type.\\nMake sure it's using the correct h() function.\\nEmpty objects can also be the cause, look for JSX comments that became objects.\");\n        }\n\n        if (simple && lastSimple) {\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n\n        lastSimple = simple;\n      }\n    }\n  };\n\n  for (var _len4 = arguments.length, children = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    children[_key4 - 2] = arguments[_key4];\n  }\n\n  walk(children);\n\n  if (vnodeData) {\n    if (BUILD8.isDev && nodeName === \"input\") {\n      validateInputProperties(vnodeData);\n    }\n\n    if (BUILD8.vdomKey && vnodeData.key) {\n      key = vnodeData.key;\n    }\n\n    if (BUILD8.slotRelocation && vnodeData.name) {\n      slotName = vnodeData.name;\n    }\n\n    if (BUILD8.vdomClass) {\n      var classData = vnodeData.className || vnodeData.class;\n\n      if (classData) {\n        vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter(function (k) {\n          return classData[k];\n        }).join(\" \");\n      }\n    }\n  }\n\n  if (BUILD8.isDev && vNodeChildren.some(isHost)) {\n    consoleDevError(\"The <Host> must be the single root component. Make sure:\\n- You are NOT using hostData() and <Host> in the same component.\\n- <Host> is used once, and it's the single root component of the render() function.\");\n  }\n\n  if (BUILD8.vdomFunctional && typeof nodeName === \"function\") {\n    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n  }\n\n  var vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n\n  if (BUILD8.vdomKey) {\n    vnode.$key$ = key;\n  }\n\n  if (BUILD8.slotRelocation) {\n    vnode.$name$ = slotName;\n  }\n\n  return vnode;\n};\n\nvar newVNode = function newVNode(tag, text) {\n  var vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n\n  if (BUILD8.vdomAttribute) {\n    vnode.$attrs$ = null;\n  }\n\n  if (BUILD8.vdomKey) {\n    vnode.$key$ = null;\n  }\n\n  if (BUILD8.slotRelocation) {\n    vnode.$name$ = null;\n  }\n\n  return vnode;\n};\n\nvar Host = {};\n\nvar isHost = function isHost(node) {\n  return node && node.$tag$ === Host;\n};\n\nvar vdomFnUtils = {\n  forEach: function forEach(children, cb) {\n    return children.map(convertToPublic).forEach(cb);\n  },\n  map: function map(children, cb) {\n    return children.map(convertToPublic).map(cb).map(convertToPrivate);\n  }\n};\n\nvar convertToPublic = function convertToPublic(node) {\n  return {\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$\n  };\n};\n\nvar convertToPrivate = function convertToPrivate(node) {\n  if (typeof node.vtag === \"function\") {\n    var vnodeData = _objectSpread({}, node.vattrs);\n\n    if (node.vkey) {\n      vnodeData.key = node.vkey;\n    }\n\n    if (node.vname) {\n      vnodeData.name = node.vname;\n    }\n\n    return h.apply(void 0, [node.vtag, vnodeData].concat(_toConsumableArray(node.vchildren || [])));\n  }\n\n  var vnode = newVNode(node.vtag, node.vtext);\n  vnode.$attrs$ = node.vattrs;\n  vnode.$children$ = node.vchildren;\n  vnode.$key$ = node.vkey;\n  vnode.$name$ = node.vname;\n  return vnode;\n};\n\nvar validateInputProperties = function validateInputProperties(inputElm) {\n  var props = Object.keys(inputElm);\n  var value = props.indexOf(\"value\");\n\n  if (value === -1) {\n    return;\n  }\n\n  var typeIndex = props.indexOf(\"type\");\n  var minIndex = props.indexOf(\"min\");\n  var maxIndex = props.indexOf(\"max\");\n  var stepIndex = props.indexOf(\"step\");\n\n  if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n    consoleDevWarn(\"The \\\"value\\\" prop of <input> should be set after \\\"min\\\", \\\"max\\\", \\\"type\\\" and \\\"step\\\"\");\n  }\n}; // src/runtime/client-hydrate.ts\n\n\nvar initializeClientHydrate = function initializeClientHydrate(hostElm, tagName, hostId, hostRef) {\n  var endHydrate = createTime(\"hydrateClient\", tagName);\n  var shadowRoot = hostElm.shadowRoot;\n  var childRenderNodes = [];\n  var slotNodes = [];\n  var shadowRootNodes = BUILD9.shadowDom && shadowRoot ? [] : null;\n  var vnode = hostRef.$vnode$ = newVNode(tagName, null);\n\n  if (!plt.$orgLocNodes$) {\n    initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */new Map());\n  }\n\n  hostElm[HYDRATE_ID] = hostId;\n  hostElm.removeAttribute(HYDRATE_ID);\n  clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n  childRenderNodes.map(function (c) {\n    var orgLocationId = c.$hostId$ + \".\" + c.$nodeId$;\n    var orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n    var node = c.$elm$;\n\n    if (orgLocationNode && supportsShadow && orgLocationNode[\"s-en\"] === \"\") {\n      orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n    }\n\n    if (!shadowRoot) {\n      node[\"s-hn\"] = tagName;\n\n      if (orgLocationNode) {\n        node[\"s-ol\"] = orgLocationNode;\n        node[\"s-ol\"][\"s-nr\"] = node;\n      }\n    }\n\n    plt.$orgLocNodes$.delete(orgLocationId);\n  });\n\n  if (BUILD9.shadowDom && shadowRoot) {\n    shadowRootNodes.map(function (shadowRootNode) {\n      if (shadowRootNode) {\n        shadowRoot.appendChild(shadowRootNode);\n      }\n    });\n  }\n\n  endHydrate();\n};\n\nvar clientHydrate = function clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) {\n  var childNodeType;\n  var childIdSplt;\n  var childVNode;\n  var i2;\n\n  if (node.nodeType === 1\n  /* ElementNode */\n  ) {\n    childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n\n    if (childNodeType) {\n      childIdSplt = childNodeType.split(\".\");\n\n      if (childIdSplt[0] === hostId || childIdSplt[0] === \"0\") {\n        childVNode = {\n          $flags$: 0,\n          $hostId$: childIdSplt[0],\n          $nodeId$: childIdSplt[1],\n          $depth$: childIdSplt[2],\n          $index$: childIdSplt[3],\n          $tag$: node.tagName.toLowerCase(),\n          $elm$: node,\n          $attrs$: null,\n          $children$: null,\n          $key$: null,\n          $name$: null,\n          $text$: null\n        };\n        childRenderNodes.push(childVNode);\n        node.removeAttribute(HYDRATE_CHILD_ID);\n\n        if (!parentVNode.$children$) {\n          parentVNode.$children$ = [];\n        }\n\n        parentVNode.$children$[childVNode.$index$] = childVNode;\n        parentVNode = childVNode;\n\n        if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n          shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n        }\n      }\n    }\n\n    for (i2 = node.childNodes.length - 1; i2 >= 0; i2--) {\n      clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i2], hostId);\n    }\n\n    if (node.shadowRoot) {\n      for (i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--) {\n        clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i2], hostId);\n      }\n    }\n  } else if (node.nodeType === 8\n  /* CommentNode */\n  ) {\n    childIdSplt = node.nodeValue.split(\".\");\n\n    if (childIdSplt[1] === hostId || childIdSplt[1] === \"0\") {\n      childNodeType = childIdSplt[0];\n      childVNode = {\n        $flags$: 0,\n        $hostId$: childIdSplt[1],\n        $nodeId$: childIdSplt[2],\n        $depth$: childIdSplt[3],\n        $index$: childIdSplt[4],\n        $elm$: node,\n        $attrs$: null,\n        $children$: null,\n        $key$: null,\n        $name$: null,\n        $tag$: null,\n        $text$: null\n      };\n\n      if (childNodeType === TEXT_NODE_ID) {\n        childVNode.$elm$ = node.nextSibling;\n\n        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3\n        /* TextNode */\n        ) {\n          childVNode.$text$ = childVNode.$elm$.textContent;\n          childRenderNodes.push(childVNode);\n          node.remove();\n\n          if (!parentVNode.$children$) {\n            parentVNode.$children$ = [];\n          }\n\n          parentVNode.$children$[childVNode.$index$] = childVNode;\n\n          if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n          }\n        }\n      } else if (childVNode.$hostId$ === hostId) {\n        if (childNodeType === SLOT_NODE_ID) {\n          childVNode.$tag$ = \"slot\";\n\n          if (childIdSplt[5]) {\n            node[\"s-sn\"] = childVNode.$name$ = childIdSplt[5];\n          } else {\n            node[\"s-sn\"] = \"\";\n          }\n\n          node[\"s-sr\"] = true;\n\n          if (BUILD9.shadowDom && shadowRootNodes) {\n            childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n\n            if (childVNode.$name$) {\n              childVNode.$elm$.setAttribute(\"name\", childVNode.$name$);\n            }\n\n            node.parentNode.insertBefore(childVNode.$elm$, node);\n            node.remove();\n\n            if (childVNode.$depth$ === \"0\") {\n              shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n            }\n          }\n\n          slotNodes.push(childVNode);\n\n          if (!parentVNode.$children$) {\n            parentVNode.$children$ = [];\n          }\n\n          parentVNode.$children$[childVNode.$index$] = childVNode;\n        } else if (childNodeType === CONTENT_REF_ID) {\n          if (BUILD9.shadowDom && shadowRootNodes) {\n            node.remove();\n          } else if (BUILD9.slotRelocation) {\n            hostElm[\"s-cr\"] = node;\n            node[\"s-cn\"] = true;\n          }\n        }\n      }\n    }\n  } else if (parentVNode && parentVNode.$tag$ === \"style\") {\n    var vnode = newVNode(null, node.textContent);\n    vnode.$elm$ = node;\n    vnode.$index$ = \"0\";\n    parentVNode.$children$ = [vnode];\n  }\n};\n\nvar initializeDocumentHydrate = function initializeDocumentHydrate(node, orgLocNodes) {\n  if (node.nodeType === 1\n  /* ElementNode */\n  ) {\n    var i2 = 0;\n\n    for (; i2 < node.childNodes.length; i2++) {\n      initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);\n    }\n\n    if (node.shadowRoot) {\n      for (i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++) {\n        initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);\n      }\n    }\n  } else if (node.nodeType === 8\n  /* CommentNode */\n  ) {\n    var childIdSplt = node.nodeValue.split(\".\");\n\n    if (childIdSplt[0] === ORG_LOCATION_ID) {\n      orgLocNodes.set(childIdSplt[1] + \".\" + childIdSplt[2], node);\n      node.nodeValue = \"\";\n      node[\"s-en\"] = childIdSplt[3];\n    }\n  }\n}; // src/runtime/initialize-component.ts\n\n\nimport { BUILD as BUILD20 } from \"@stencil/core/internal/app-data\"; // src/runtime/mode.ts\n\nvar computeMode = function computeMode(elm) {\n  return modeResolutionChain.map(function (h2) {\n    return h2(elm);\n  }).find(function (m) {\n    return !!m;\n  });\n};\n\nvar setMode = function setMode(handler) {\n  return modeResolutionChain.push(handler);\n};\n\nvar getMode = function getMode(ref) {\n  return getHostRef(ref).$modeName$;\n}; // src/runtime/proxy-component.ts\n\n\nimport { BUILD as BUILD19 } from \"@stencil/core/internal/app-data\"; // src/runtime/set-value.ts\n\nimport { BUILD as BUILD18 } from \"@stencil/core/internal/app-data\"; // src/runtime/parse-property-value.ts\n\nimport { BUILD as BUILD10 } from \"@stencil/core/internal/app-data\";\n\nvar parsePropertyValue = function parsePropertyValue(propValue, propType) {\n  if (propValue != null && !isComplexType(propValue)) {\n    if (BUILD10.propBoolean && propType & 4\n    /* Boolean */\n    ) {\n      return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n    }\n\n    if (BUILD10.propNumber && propType & 2\n    /* Number */\n    ) {\n      return parseFloat(propValue);\n    }\n\n    if (BUILD10.propString && propType & 1\n    /* String */\n    ) {\n      return String(propValue);\n    }\n\n    return propValue;\n  }\n\n  return propValue;\n}; // src/runtime/update-component.ts\n\n\nimport { BUILD as BUILD17, NAMESPACE } from \"@stencil/core/internal/app-data\"; // src/runtime/event-emitter.ts\n\nimport { BUILD as BUILD12 } from \"@stencil/core/internal/app-data\"; // src/runtime/element.ts\n\nimport { BUILD as BUILD11 } from \"@stencil/core/internal/app-data\";\n\nvar getElement = function getElement(ref) {\n  return BUILD11.lazyLoad ? getHostRef(ref).$hostElement$ : ref;\n}; // src/runtime/event-emitter.ts\n\n\nvar createEvent = function createEvent(ref, name, flags) {\n  var elm = getElement(ref);\n  return {\n    emit: function emit(detail) {\n      if (BUILD12.isDev && !elm.isConnected) {\n        consoleDevWarn(\"The \\\"\".concat(name, \"\\\" event was emitted, but the dispatcher node is no longer connected to the dom.\"));\n      }\n\n      return emitEvent(elm, name, {\n        bubbles: !!(flags & 4\n        /* Bubbles */\n        ),\n        composed: !!(flags & 2\n        /* Composed */\n        ),\n        cancelable: !!(flags & 1\n        /* Cancellable */\n        ),\n        detail: detail\n      });\n    }\n  };\n};\n\nvar emitEvent = function emitEvent(elm, name, opts) {\n  var ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n}; // src/runtime/styles.ts\n\n\nimport { BUILD as BUILD13 } from \"@stencil/core/internal/app-data\";\nvar rootAppliedStyles = /* @__PURE__ */new WeakMap();\n\nvar registerStyle = function registerStyle(scopeId2, cssText, allowCS) {\n  var style = styles.get(scopeId2);\n\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n\n    if (typeof style === \"string\") {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n\n  styles.set(scopeId2, style);\n};\n\nvar addStyle = function addStyle(styleContainerNode, cmpMeta, mode) {\n  var _a;\n\n  var scopeId2 = getScopeId(cmpMeta, mode);\n  var style = styles.get(scopeId2);\n\n  if (!BUILD13.attachStyles) {\n    return scopeId2;\n  }\n\n  styleContainerNode = styleContainerNode.nodeType === 11\n  /* DocumentFragment */\n  ? styleContainerNode : doc;\n\n  if (style) {\n    if (typeof style === \"string\") {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      var appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      var styleElm;\n\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */new Set());\n      }\n\n      if (!appliedStyles.has(scopeId2)) {\n        if (BUILD13.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(\"[\".concat(HYDRATED_STYLE_ID, \"=\\\"\").concat(scopeId2, \"\\\"]\")))) {\n          styleElm.innerHTML = style;\n        } else {\n          styleElm = doc.createElement(\"style\");\n          styleElm.innerHTML = style;\n          var nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);\n\n          if (nonce != null) {\n            styleElm.setAttribute(\"nonce\", nonce);\n          }\n\n          if (BUILD13.hydrateServerSide || BUILD13.hotModuleReplacement) {\n            styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);\n          }\n\n          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector(\"link\"));\n        }\n\n        if (cmpMeta.$flags$ & 4\n        /* hasSlotRelocation */\n        ) {\n          styleElm.innerHTML += SLOT_FB_CSS;\n        }\n\n        if (appliedStyles) {\n          appliedStyles.add(scopeId2);\n        }\n      }\n    } else if (BUILD13.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets = [].concat(_toConsumableArray(styleContainerNode.adoptedStyleSheets), [style]);\n    }\n  }\n\n  return scopeId2;\n};\n\nvar attachStyles = function attachStyles(hostRef) {\n  var cmpMeta = hostRef.$cmpMeta$;\n  var elm = hostRef.$hostElement$;\n  var flags = cmpMeta.$flags$;\n  var endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n  var scopeId2 = addStyle(BUILD13.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);\n\n  if ((BUILD13.shadowDom || BUILD13.scoped) && BUILD13.cssAnnotations && flags & 10\n  /* needsScopedEncapsulation */\n  ) {\n    elm[\"s-sc\"] = scopeId2;\n    elm.classList.add(scopeId2 + \"-h\");\n\n    if (BUILD13.scoped && flags & 2\n    /* scopedCssEncapsulation */\n    ) {\n      elm.classList.add(scopeId2 + \"-s\");\n    }\n  }\n\n  endAttachStyles();\n};\n\nvar getScopeId = function getScopeId(cmp, mode) {\n  return \"sc-\" + (BUILD13.mode && mode && cmp.$flags$ & 32\n  /* hasMode */\n  ? cmp.$tagName$ + \"-\" + mode : cmp.$tagName$);\n};\n\nvar convertScopedToShadow = function convertScopedToShadow(css) {\n  return css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, \"$1{\");\n}; // src/runtime/vdom/vdom-render.ts\n\n\nimport { BUILD as BUILD16 } from \"@stencil/core/internal/app-data\"; // src/runtime/vdom/update-element.ts\n\nimport { BUILD as BUILD15 } from \"@stencil/core/internal/app-data\"; // src/runtime/vdom/set-accessor.ts\n\nimport { BUILD as BUILD14 } from \"@stencil/core/internal/app-data\";\n\nvar setAccessor = function setAccessor(elm, memberName, oldValue, newValue, isSvg, flags) {\n  if (oldValue !== newValue) {\n    var isProp = isMemberInElement(elm, memberName);\n    var ln = memberName.toLowerCase();\n\n    if (BUILD14.vdomClass && memberName === \"class\") {\n      var classList = elm.classList;\n      var oldClasses = parseClassList(oldValue);\n      var newClasses = parseClassList(newValue);\n      classList.remove.apply(classList, _toConsumableArray(oldClasses.filter(function (c) {\n        return c && !newClasses.includes(c);\n      })));\n      classList.add.apply(classList, _toConsumableArray(newClasses.filter(function (c) {\n        return c && !oldClasses.includes(c);\n      })));\n    } else if (BUILD14.vdomStyle && memberName === \"style\") {\n      if (BUILD14.updatable) {\n        for (var prop in oldValue) {\n          if (!newValue || newValue[prop] == null) {\n            if (!BUILD14.hydrateServerSide && prop.includes(\"-\")) {\n              elm.style.removeProperty(prop);\n            } else {\n              elm.style[prop] = \"\";\n            }\n          }\n        }\n      }\n\n      for (var _prop in newValue) {\n        if (!oldValue || newValue[_prop] !== oldValue[_prop]) {\n          if (!BUILD14.hydrateServerSide && _prop.includes(\"-\")) {\n            elm.style.setProperty(_prop, newValue[_prop]);\n          } else {\n            elm.style[_prop] = newValue[_prop];\n          }\n        }\n      }\n    } else if (BUILD14.vdomKey && memberName === \"key\") {} else if (BUILD14.vdomRef && memberName === \"ref\") {\n      if (newValue) {\n        newValue(elm);\n      }\n    } else if (BUILD14.vdomListener && (BUILD14.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === \"o\" && memberName[1] === \"n\") {\n      if (memberName[2] === \"-\") {\n        memberName = memberName.slice(3);\n      } else if (isMemberInElement(win, ln)) {\n        memberName = ln.slice(2);\n      } else {\n        memberName = ln[2] + memberName.slice(3);\n      }\n\n      if (oldValue || newValue) {\n        var capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);\n        memberName = memberName.replace(CAPTURE_EVENT_REGEX, \"\");\n\n        if (oldValue) {\n          plt.rel(elm, memberName, oldValue, capture);\n        }\n\n        if (newValue) {\n          plt.ael(elm, memberName, newValue, capture);\n        }\n      }\n    } else if (BUILD14.vdomPropOrAttr) {\n      var isComplex = isComplexType(newValue);\n\n      if ((isProp || isComplex && newValue !== null) && !isSvg) {\n        try {\n          if (!elm.tagName.includes(\"-\")) {\n            var n = newValue == null ? \"\" : newValue;\n\n            if (memberName === \"list\") {\n              isProp = false;\n            } else if (oldValue == null || elm[memberName] != n) {\n              elm[memberName] = n;\n            }\n          } else {\n            elm[memberName] = newValue;\n          }\n        } catch (e) {}\n      }\n\n      var xlink = false;\n\n      if (BUILD14.vdomXlink) {\n        if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n          memberName = ln;\n          xlink = true;\n        }\n      }\n\n      if (newValue == null || newValue === false) {\n        if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n          if (BUILD14.vdomXlink && xlink) {\n            elm.removeAttributeNS(XLINK_NS, memberName);\n          } else {\n            elm.removeAttribute(memberName);\n          }\n        }\n      } else if ((!isProp || flags & 4\n      /* isHost */\n      || isSvg) && !isComplex) {\n        newValue = newValue === true ? \"\" : newValue;\n\n        if (BUILD14.vdomXlink && xlink) {\n          elm.setAttributeNS(XLINK_NS, memberName, newValue);\n        } else {\n          elm.setAttribute(memberName, newValue);\n        }\n      }\n    }\n  }\n};\n\nvar parseClassListRegex = /\\s/;\n\nvar parseClassList = function parseClassList(value) {\n  return !value ? [] : value.split(parseClassListRegex);\n};\n\nvar CAPTURE_EVENT_SUFFIX = \"Capture\";\nvar CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + \"$\"); // src/runtime/vdom/update-element.ts\n\nvar updateElement = function updateElement(oldVnode, newVnode, isSvgMode2) {\n  var elm = newVnode.$elm$.nodeType === 11\n  /* DocumentFragment */\n  && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  var oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n  var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n\n  if (BUILD15.updatable) {\n    var _iterator = _createForOfIteratorHelper(sortedAttrNames(Object.keys(oldVnodeAttrs))),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var memberName = _step.value;\n\n        if (!(memberName in newVnodeAttrs)) {\n          setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(sortedAttrNames(Object.keys(newVnodeAttrs))),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _memberName = _step2.value;\n      setAccessor(elm, _memberName, oldVnodeAttrs[_memberName], newVnodeAttrs[_memberName], isSvgMode2, newVnode.$flags$);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n\nfunction sortedAttrNames(attrNames) {\n  return attrNames.includes(\"ref\") ? // we need to sort these to ensure that `'ref'` is the last attr\n  [].concat(_toConsumableArray(attrNames.filter(function (attr) {\n    return attr !== \"ref\";\n  })), [\"ref\"]) : // no need to sort, return the original array\n  attrNames;\n} // src/runtime/vdom/vdom-render.ts\n\n\nvar scopeId;\nvar contentRef;\nvar hostTagName;\nvar useNativeShadowDom = false;\nvar checkSlotFallbackVisibility = false;\nvar checkSlotRelocate = false;\nvar isSvgMode = false;\n\nvar createElm = function createElm(oldParentVNode, newParentVNode, childIndex, parentElm) {\n  var _a;\n\n  var newVNode2 = newParentVNode.$children$[childIndex];\n  var i2 = 0;\n  var elm;\n  var childNode;\n  var oldVNode;\n\n  if (BUILD16.slotRelocation && !useNativeShadowDom) {\n    checkSlotRelocate = true;\n\n    if (newVNode2.$tag$ === \"slot\") {\n      if (scopeId) {\n        parentElm.classList.add(scopeId + \"-s\");\n      }\n\n      newVNode2.$flags$ |= newVNode2.$children$ ? // slot element has fallback content\n      // still create an element that \"mocks\" the slot element\n      2\n      /* isSlotFallback */\n      : // slot element does not have fallback content\n      // create an html comment we'll use to always reference\n      // where actual slot content should sit next to\n      1\n      /* isSlotReference */\n      ;\n    }\n  }\n\n  if (BUILD16.isDev && newVNode2.$elm$) {\n    consoleDevError(\"The JSX \".concat(newVNode2.$text$ !== null ? \"\\\"\".concat(newVNode2.$text$, \"\\\" text\") : \"\\\"\".concat(newVNode2.$tag$, \"\\\" element\"), \" node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes\"));\n  }\n\n  if (BUILD16.vdomText && newVNode2.$text$ !== null) {\n    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);\n  } else if (BUILD16.slotRelocation && newVNode2.$flags$ & 1\n  /* isSlotReference */\n  ) {\n    elm = newVNode2.$elm$ = BUILD16.isDebug || BUILD16.hydrateServerSide ? slotReferenceDebugNode(newVNode2) : doc.createTextNode(\"\");\n  } else {\n    if (BUILD16.svg && !isSvgMode) {\n      isSvgMode = newVNode2.$tag$ === \"svg\";\n    }\n\n    elm = newVNode2.$elm$ = BUILD16.svg ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, !useNativeShadowDom && BUILD16.slotRelocation && newVNode2.$flags$ & 2\n    /* isSlotFallback */\n    ? \"slot-fb\" : newVNode2.$tag$) : doc.createElement(!useNativeShadowDom && BUILD16.slotRelocation && newVNode2.$flags$ & 2\n    /* isSlotFallback */\n    ? \"slot-fb\" : newVNode2.$tag$);\n\n    if (BUILD16.svg && isSvgMode && newVNode2.$tag$ === \"foreignObject\") {\n      isSvgMode = false;\n    }\n\n    if (BUILD16.vdomAttribute) {\n      updateElement(null, newVNode2, isSvgMode);\n    }\n\n    if ((BUILD16.shadowDom || BUILD16.scoped) && isDef(scopeId) && elm[\"s-si\"] !== scopeId) {\n      elm.classList.add(elm[\"s-si\"] = scopeId);\n    }\n\n    if (BUILD16.scoped) {\n      updateElementScopeIds(elm, parentElm);\n    }\n\n    if (newVNode2.$children$) {\n      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {\n        childNode = createElm(oldParentVNode, newVNode2, i2, elm);\n\n        if (childNode) {\n          elm.appendChild(childNode);\n        }\n      }\n    }\n\n    if (BUILD16.svg) {\n      if (newVNode2.$tag$ === \"svg\") {\n        isSvgMode = false;\n      } else if (elm.tagName === \"foreignObject\") {\n        isSvgMode = true;\n      }\n    }\n  }\n\n  elm[\"s-hn\"] = hostTagName;\n\n  if (BUILD16.slotRelocation) {\n    if (newVNode2.$flags$ & (2\n    /* isSlotFallback */\n    | 1\n    /* isSlotReference */\n    )) {\n      elm[\"s-sr\"] = true;\n      elm[\"s-cr\"] = contentRef;\n      elm[\"s-sn\"] = newVNode2.$name$ || \"\";\n      elm[\"s-rf\"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;\n      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n\n      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {\n        if (BUILD16.experimentalSlotFixes) {\n          relocateToHostRoot(oldParentVNode.$elm$);\n        } else {\n          putBackInOriginalLocation(oldParentVNode.$elm$, false);\n        }\n      }\n    }\n  }\n\n  return elm;\n};\n\nvar relocateToHostRoot = function relocateToHostRoot(parentElm) {\n  plt.$flags$ |= 1\n  /* isTmpDisconnected */\n  ;\n  var host = parentElm.closest(hostTagName.toLowerCase());\n\n  if (host != null) {\n    var contentRefNode = Array.from(host.childNodes).find(function (ref) {\n      return ref[\"s-cr\"];\n    });\n    var childNodeArray = Array.from(parentElm.childNodes);\n\n    var _iterator3 = _createForOfIteratorHelper(contentRefNode ? childNodeArray.reverse() : childNodeArray),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var childNode = _step3.value;\n\n        if (childNode[\"s-sh\"] != null) {\n          insertBefore(host, childNode, contentRefNode != null ? contentRefNode : null);\n          childNode[\"s-sh\"] = void 0;\n          checkSlotRelocate = true;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  plt.$flags$ &= ~1\n  /* isTmpDisconnected */\n  ;\n};\n\nvar putBackInOriginalLocation = function putBackInOriginalLocation(parentElm, recursive) {\n  plt.$flags$ |= 1\n  /* isTmpDisconnected */\n  ;\n  var oldSlotChildNodes = Array.from(parentElm.childNodes);\n\n  if (parentElm[\"s-sr\"] && BUILD16.experimentalSlotFixes) {\n    var node = parentElm;\n\n    while (node = node.nextSibling) {\n      if (node && node[\"s-sn\"] === parentElm[\"s-sn\"] && node[\"s-sh\"] === hostTagName) {\n        oldSlotChildNodes.push(node);\n      }\n    }\n  }\n\n  for (var i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {\n    var childNode = oldSlotChildNodes[i2];\n\n    if (childNode[\"s-hn\"] !== hostTagName && childNode[\"s-ol\"]) {\n      insertBefore(parentReferenceNode(childNode), childNode, referenceNode(childNode));\n      childNode[\"s-ol\"].remove();\n      childNode[\"s-ol\"] = void 0;\n      childNode[\"s-sh\"] = void 0;\n      checkSlotRelocate = true;\n    }\n\n    if (recursive) {\n      putBackInOriginalLocation(childNode, recursive);\n    }\n  }\n\n  plt.$flags$ &= ~1\n  /* isTmpDisconnected */\n  ;\n};\n\nvar addVnodes = function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx) {\n  var containerElm = BUILD16.slotRelocation && parentElm[\"s-cr\"] && parentElm[\"s-cr\"].parentNode || parentElm;\n  var childNode;\n\n  if (BUILD16.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx, parentElm);\n\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        insertBefore(containerElm, childNode, BUILD16.slotRelocation ? referenceNode(before) : before);\n      }\n    }\n  }\n};\n\nvar removeVnodes = function removeVnodes(vnodes, startIdx, endIdx) {\n  for (var index = startIdx; index <= endIdx; ++index) {\n    var vnode = vnodes[index];\n\n    if (vnode) {\n      var elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n\n      if (elm) {\n        if (BUILD16.slotRelocation) {\n          checkSlotFallbackVisibility = true;\n\n          if (elm[\"s-ol\"]) {\n            elm[\"s-ol\"].remove();\n          } else {\n            putBackInOriginalLocation(elm, true);\n          }\n        }\n\n        elm.remove();\n      }\n    }\n  }\n};\n\nvar updateChildren = function updateChildren(parentElm, oldCh, newVNode2, newCh) {\n  var isInitialRender = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var oldStartIdx = 0;\n  var newStartIdx = 0;\n  var idxInOld = 0;\n  var i2 = 0;\n  var oldEndIdx = oldCh.length - 1;\n  var oldStartVnode = oldCh[0];\n  var oldEndVnode = oldCh[oldEndIdx];\n  var newEndIdx = newCh.length - 1;\n  var newStartVnode = newCh[0];\n  var newEndVnode = newCh[newEndIdx];\n  var node;\n  var elmToMove;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {\n      patch(oldStartVnode, newStartVnode, isInitialRender);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {\n      patch(oldEndVnode, newEndVnode, isInitialRender);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {\n      if (BUILD16.slotRelocation && (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\")) {\n        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n      }\n\n      patch(oldStartVnode, newEndVnode, isInitialRender);\n      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {\n      if (BUILD16.slotRelocation && (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\")) {\n        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n      }\n\n      patch(oldEndVnode, newStartVnode, isInitialRender);\n      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      idxInOld = -1;\n\n      if (BUILD16.vdomKey) {\n        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {\n          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {\n            idxInOld = i2;\n            break;\n          }\n        }\n      }\n\n      if (BUILD16.vdomKey && idxInOld >= 0) {\n        elmToMove = oldCh[idxInOld];\n\n        if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);\n        } else {\n          patch(elmToMove, newStartVnode, isInitialRender);\n          oldCh[idxInOld] = void 0;\n          node = elmToMove.$elm$;\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);\n        newStartVnode = newCh[++newStartIdx];\n      }\n\n      if (node) {\n        if (BUILD16.slotRelocation) {\n          insertBefore(parentReferenceNode(oldStartVnode.$elm$), node, referenceNode(oldStartVnode.$elm$));\n        } else {\n          insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);\n  } else if (BUILD16.updatable && newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\n\nvar isSameVnode = function isSameVnode(leftVNode, rightVNode) {\n  var isInitialRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    if (BUILD16.slotRelocation && leftVNode.$tag$ === \"slot\") {\n      return leftVNode.$name$ === rightVNode.$name$;\n    }\n\n    if (BUILD16.vdomKey && !isInitialRender) {\n      return leftVNode.$key$ === rightVNode.$key$;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nvar referenceNode = function referenceNode(node) {\n  return node && node[\"s-ol\"] || node;\n};\n\nvar parentReferenceNode = function parentReferenceNode(node) {\n  return (node[\"s-ol\"] ? node[\"s-ol\"] : node).parentNode;\n};\n\nvar patch = function patch(oldVNode, newVNode2) {\n  var isInitialRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var elm = newVNode2.$elm$ = oldVNode.$elm$;\n  var oldChildren = oldVNode.$children$;\n  var newChildren = newVNode2.$children$;\n  var tag = newVNode2.$tag$;\n  var text = newVNode2.$text$;\n  var defaultHolder;\n\n  if (!BUILD16.vdomText || text === null) {\n    if (BUILD16.svg) {\n      isSvgMode = tag === \"svg\" ? true : tag === \"foreignObject\" ? false : isSvgMode;\n    }\n\n    if (BUILD16.vdomAttribute || BUILD16.reflect) {\n      if (BUILD16.slot && tag === \"slot\" && !useNativeShadowDom) {\n        if (BUILD16.experimentalSlotFixes && oldVNode.$name$ !== newVNode2.$name$) {\n          newVNode2.$elm$[\"s-sn\"] = newVNode2.$name$ || \"\";\n          relocateToHostRoot(newVNode2.$elm$.parentElement);\n        }\n      } else {\n        updateElement(oldVNode, newVNode2, isSvgMode);\n      }\n    }\n\n    if (BUILD16.updatable && oldChildren !== null && newChildren !== null) {\n      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);\n    } else if (newChildren !== null) {\n      if (BUILD16.updatable && BUILD16.vdomText && oldVNode.$text$ !== null) {\n        elm.textContent = \"\";\n      }\n\n      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);\n    } else if (BUILD16.updatable && oldChildren !== null) {\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    }\n\n    if (BUILD16.svg && isSvgMode && tag === \"svg\") {\n      isSvgMode = false;\n    }\n  } else if (BUILD16.vdomText && BUILD16.slotRelocation && (defaultHolder = elm[\"s-cr\"])) {\n    defaultHolder.parentNode.textContent = text;\n  } else if (BUILD16.vdomText && oldVNode.$text$ !== text) {\n    elm.data = text;\n  }\n};\n\nvar updateFallbackSlotVisibility = function updateFallbackSlotVisibility(elm) {\n  var childNodes = elm.childNodes;\n\n  var _iterator4 = _createForOfIteratorHelper(childNodes),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var childNode = _step4.value;\n\n      if (childNode.nodeType === 1\n      /* ElementNode */\n      ) {\n        if (childNode[\"s-sr\"]) {\n          var slotName = childNode[\"s-sn\"];\n          childNode.hidden = false;\n\n          var _iterator5 = _createForOfIteratorHelper(childNodes),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var siblingNode = _step5.value;\n\n              if (siblingNode !== childNode) {\n                if (siblingNode[\"s-hn\"] !== childNode[\"s-hn\"] || slotName !== \"\") {\n                  if (siblingNode.nodeType === 1\n                  /* ElementNode */\n                  && (slotName === siblingNode.getAttribute(\"slot\") || slotName === siblingNode[\"s-sn\"]) || siblingNode.nodeType === 3\n                  /* TextNode */\n                  && slotName === siblingNode[\"s-sn\"]) {\n                    childNode.hidden = true;\n                    break;\n                  }\n                } else {\n                  if (siblingNode.nodeType === 1\n                  /* ElementNode */\n                  || siblingNode.nodeType === 3\n                  /* TextNode */\n                  && siblingNode.textContent.trim() !== \"\") {\n                    childNode.hidden = true;\n                    break;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        updateFallbackSlotVisibility(childNode);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n};\n\nvar relocateNodes = [];\n\nvar markSlotContentForRelocation = function markSlotContentForRelocation(elm) {\n  var node;\n  var hostContentNodes;\n  var j;\n\n  var _iterator6 = _createForOfIteratorHelper(elm.childNodes),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var childNode = _step6.value;\n\n      if (childNode[\"s-sr\"] && (node = childNode[\"s-cr\"]) && node.parentNode) {\n        hostContentNodes = node.parentNode.childNodes;\n        var slotName = childNode[\"s-sn\"];\n\n        var _loop = function _loop() {\n          node = hostContentNodes[j];\n\n          if (!node[\"s-cn\"] && !node[\"s-nr\"] && node[\"s-hn\"] !== childNode[\"s-hn\"] && (!BUILD16.experimentalSlotFixes || !node[\"s-sh\"] || node[\"s-sh\"] !== childNode[\"s-hn\"])) {\n            if (isNodeLocatedInSlot(node, slotName)) {\n              var relocateNodeData = relocateNodes.find(function (r) {\n                return r.$nodeToRelocate$ === node;\n              });\n              checkSlotFallbackVisibility = true;\n              node[\"s-sn\"] = node[\"s-sn\"] || slotName;\n\n              if (relocateNodeData) {\n                relocateNodeData.$nodeToRelocate$[\"s-sh\"] = childNode[\"s-hn\"];\n                relocateNodeData.$slotRefNode$ = childNode;\n              } else {\n                node[\"s-sh\"] = childNode[\"s-hn\"];\n                relocateNodes.push({\n                  $slotRefNode$: childNode,\n                  $nodeToRelocate$: node\n                });\n              }\n\n              if (node[\"s-sr\"]) {\n                relocateNodes.map(function (relocateNode) {\n                  if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node[\"s-sn\"])) {\n                    relocateNodeData = relocateNodes.find(function (r) {\n                      return r.$nodeToRelocate$ === node;\n                    });\n\n                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                      relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                    }\n                  }\n                });\n              }\n            } else if (!relocateNodes.some(function (r) {\n              return r.$nodeToRelocate$ === node;\n            })) {\n              relocateNodes.push({\n                $nodeToRelocate$: node\n              });\n            }\n          }\n        };\n\n        for (j = hostContentNodes.length - 1; j >= 0; j--) {\n          _loop();\n        }\n      }\n\n      if (childNode.nodeType === 1\n      /* ElementNode */\n      ) {\n        markSlotContentForRelocation(childNode);\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n};\n\nvar isNodeLocatedInSlot = function isNodeLocatedInSlot(nodeToRelocate, slotName) {\n  if (nodeToRelocate.nodeType === 1\n  /* ElementNode */\n  ) {\n    if (nodeToRelocate.getAttribute(\"slot\") === null && slotName === \"\") {\n      return true;\n    }\n\n    if (nodeToRelocate.getAttribute(\"slot\") === slotName) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (nodeToRelocate[\"s-sn\"] === slotName) {\n    return true;\n  }\n\n  return slotName === \"\";\n};\n\nvar nullifyVNodeRefs = function nullifyVNodeRefs(vNode) {\n  if (BUILD16.vdomRef) {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\n\nvar insertBefore = function insertBefore(parent, newNode, reference) {\n  var inserted = parent == null ? void 0 : parent.insertBefore(newNode, reference);\n\n  if (BUILD16.scoped) {\n    updateElementScopeIds(newNode, parent);\n  }\n\n  return inserted;\n};\n\nvar findScopeIds = function findScopeIds(element) {\n  var scopeIds = [];\n\n  if (element) {\n    scopeIds.push.apply(scopeIds, _toConsumableArray(element[\"s-scs\"] || []).concat([element[\"s-si\"], element[\"s-sc\"]], _toConsumableArray(findScopeIds(element.parentElement))));\n  }\n\n  return scopeIds;\n};\n\nvar updateElementScopeIds = function updateElementScopeIds(element, parent) {\n  var iterateChildNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _a;\n\n  if (element && parent && element.nodeType === 1\n  /* ElementNode */\n  ) {\n    var scopeIds = new Set(findScopeIds(parent).filter(Boolean));\n\n    if (scopeIds.size) {\n      var _a4;\n\n      (_a = element.classList) == null ? void 0 : (_a4 = _a).add.apply(_a4, _toConsumableArray(element[\"s-scs\"] = _toConsumableArray(scopeIds)));\n\n      if (element[\"s-ol\"] || iterateChildNodes) {\n        for (var _i = 0, _Array$from = Array.from(element.childNodes); _i < _Array$from.length; _i++) {\n          var childNode = _Array$from[_i];\n          updateElementScopeIds(childNode, element, true);\n        }\n      }\n    }\n  }\n};\n\nvar renderVdom = function renderVdom(hostRef, renderFnResults) {\n  var isInitialLoad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _a, _b, _c, _d, _e;\n\n  var hostElm = hostRef.$hostElement$;\n  var cmpMeta = hostRef.$cmpMeta$;\n  var oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  var rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n\n  if (BUILD16.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n    throw new Error(\"The <Host> must be the single root component.\\nLooks like the render() function of \\\"\".concat(hostTagName.toLowerCase(), \"\\\" is returning an array that contains the <Host>.\\n\\nThe render() function should look like this instead:\\n\\nrender() {\\n  // Do not return an array\\n  return (\\n    <Host>{content}</Host>\\n  );\\n}\\n  \"));\n  }\n\n  if (BUILD16.reflect && cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          propName = _ref3[0],\n          attribute = _ref3[1];\n\n      return rootVnode.$attrs$[attribute] = hostElm[propName];\n    });\n  }\n\n  if (isInitialLoad && rootVnode.$attrs$) {\n    for (var _i2 = 0, _Object$keys = Object.keys(rootVnode.$attrs$); _i2 < _Object$keys.length; _i2++) {\n      var key = _Object$keys[_i2];\n\n      if (hostElm.hasAttribute(key) && ![\"key\", \"ref\", \"style\", \"class\"].includes(key)) {\n        rootVnode.$attrs$[key] = hostElm[key];\n      }\n    }\n  }\n\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4\n  /* isHost */\n  ;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = BUILD16.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;\n\n  if (BUILD16.scoped || BUILD16.shadowDom) {\n    scopeId = hostElm[\"s-sc\"];\n  }\n\n  useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1\n  /* shadowDomEncapsulation */\n  ) !== 0;\n\n  if (BUILD16.slotRelocation) {\n    contentRef = hostElm[\"s-cr\"];\n    checkSlotFallbackVisibility = false;\n  }\n\n  patch(oldVNode, rootVnode, isInitialLoad);\n\n  if (BUILD16.slotRelocation) {\n    plt.$flags$ |= 1\n    /* isTmpDisconnected */\n    ;\n\n    if (checkSlotRelocate) {\n      markSlotContentForRelocation(rootVnode.$elm$);\n\n      for (var _i3 = 0, _relocateNodes = relocateNodes; _i3 < _relocateNodes.length; _i3++) {\n        var relocateData = _relocateNodes[_i3];\n        var nodeToRelocate = relocateData.$nodeToRelocate$;\n\n        if (!nodeToRelocate[\"s-ol\"]) {\n          var orgLocationNode = BUILD16.isDebug || BUILD16.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode(\"\");\n          orgLocationNode[\"s-nr\"] = nodeToRelocate;\n          insertBefore(nodeToRelocate.parentNode, nodeToRelocate[\"s-ol\"] = orgLocationNode, nodeToRelocate);\n        }\n      }\n\n      for (var _i4 = 0, _relocateNodes2 = relocateNodes; _i4 < _relocateNodes2.length; _i4++) {\n        var _relocateData = _relocateNodes2[_i4];\n        var _nodeToRelocate = _relocateData.$nodeToRelocate$;\n        var slotRefNode = _relocateData.$slotRefNode$;\n\n        if (slotRefNode) {\n          var parentNodeRef = slotRefNode.parentNode;\n          var insertBeforeNode = slotRefNode.nextSibling;\n\n          if (!BUILD16.experimentalSlotFixes || insertBeforeNode && insertBeforeNode.nodeType === 1\n          /* ElementNode */\n          ) {\n            var _orgLocationNode = (_a = _nodeToRelocate[\"s-ol\"]) == null ? void 0 : _a.previousSibling;\n\n            while (_orgLocationNode) {\n              var refNode = (_b = _orgLocationNode[\"s-nr\"]) != null ? _b : null;\n\n              if (refNode && refNode[\"s-sn\"] === _nodeToRelocate[\"s-sn\"] && parentNodeRef === refNode.parentNode) {\n                refNode = refNode.nextSibling;\n\n                while (refNode === _nodeToRelocate || (refNode == null ? void 0 : refNode[\"s-sr\"])) {\n                  refNode = refNode == null ? void 0 : refNode.nextSibling;\n                }\n\n                if (!refNode || !refNode[\"s-nr\"]) {\n                  insertBeforeNode = refNode;\n                  break;\n                }\n              }\n\n              _orgLocationNode = _orgLocationNode.previousSibling;\n            }\n          }\n\n          if (!insertBeforeNode && parentNodeRef !== _nodeToRelocate.parentNode || _nodeToRelocate.nextSibling !== insertBeforeNode) {\n            if (_nodeToRelocate !== insertBeforeNode) {\n              if (!BUILD16.experimentalSlotFixes && !_nodeToRelocate[\"s-hn\"] && _nodeToRelocate[\"s-ol\"]) {\n                _nodeToRelocate[\"s-hn\"] = _nodeToRelocate[\"s-ol\"].parentNode.nodeName;\n              }\n\n              insertBefore(parentNodeRef, _nodeToRelocate, insertBeforeNode);\n\n              if (_nodeToRelocate.nodeType === 1\n              /* ElementNode */\n              ) {\n                _nodeToRelocate.hidden = (_c = _nodeToRelocate[\"s-ih\"]) != null ? _c : false;\n              }\n            }\n          }\n\n          _nodeToRelocate && typeof slotRefNode[\"s-rf\"] === \"function\" && slotRefNode[\"s-rf\"](_nodeToRelocate);\n        } else {\n          if (_nodeToRelocate.nodeType === 1\n          /* ElementNode */\n          ) {\n            if (isInitialLoad) {\n              _nodeToRelocate[\"s-ih\"] = (_d = _nodeToRelocate.hidden) != null ? _d : false;\n            }\n\n            _nodeToRelocate.hidden = true;\n          }\n        }\n      }\n    }\n\n    if (checkSlotFallbackVisibility) {\n      updateFallbackSlotVisibility(rootVnode.$elm$);\n    }\n\n    plt.$flags$ &= ~1\n    /* isTmpDisconnected */\n    ;\n    relocateNodes.length = 0;\n  }\n\n  if (BUILD16.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2\n  /* scopedCssEncapsulation */\n  ) {\n    var _iterator7 = _createForOfIteratorHelper(rootVnode.$elm$.childNodes),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var childNode = _step7.value;\n\n        if (childNode[\"s-hn\"] !== hostTagName && !childNode[\"s-sh\"]) {\n          if (isInitialLoad && childNode[\"s-ih\"] == null) {\n            childNode[\"s-ih\"] = (_e = childNode.hidden) != null ? _e : false;\n          }\n\n          childNode.hidden = true;\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  }\n\n  contentRef = void 0;\n};\n\nvar slotReferenceDebugNode = function slotReferenceDebugNode(slotVNode) {\n  return doc.createComment(\"<slot\".concat(slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : \"\", \"> (host=\").concat(hostTagName.toLowerCase(), \")\"));\n};\n\nvar originalLocationDebugNode = function originalLocationDebugNode(nodeToRelocate) {\n  return doc.createComment(\"org-location for \" + (nodeToRelocate.localName ? \"<\".concat(nodeToRelocate.localName, \"> (host=\").concat(nodeToRelocate[\"s-hn\"], \")\") : \"[\".concat(nodeToRelocate.textContent, \"]\")));\n}; // src/runtime/update-component.ts\n\n\nvar attachToAncestor = function attachToAncestor(hostRef, ancestorComponent) {\n  if (BUILD17.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n    ancestorComponent[\"s-p\"].push(new Promise(function (r) {\n      return hostRef.$onRenderResolve$ = r;\n    }));\n  }\n};\n\nvar scheduleUpdate = function scheduleUpdate(hostRef, isInitialLoad) {\n  if (BUILD17.taskQueue && BUILD17.updatable) {\n    hostRef.$flags$ |= 16\n    /* isQueuedForUpdate */\n    ;\n  }\n\n  if (BUILD17.asyncLoading && hostRef.$flags$ & 4\n  /* isWaitingForChildren */\n  ) {\n    hostRef.$flags$ |= 512\n    /* needsRerender */\n    ;\n    return;\n  }\n\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n\n  var dispatch = function dispatch() {\n    return dispatchHooks(hostRef, isInitialLoad);\n  };\n\n  return BUILD17.taskQueue ? writeTask(dispatch) : dispatch();\n};\n\nvar dispatchHooks = function dispatchHooks(hostRef, isInitialLoad) {\n  var elm = hostRef.$hostElement$;\n  var endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n  var instance = BUILD17.lazyLoad ? hostRef.$lazyInstance$ : elm;\n\n  if (!instance) {\n    throw new Error(\"Can't render component <\".concat(elm.tagName.toLowerCase(), \" /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime\"));\n  }\n\n  var maybePromise;\n\n  if (isInitialLoad) {\n    if (BUILD17.lazyLoad && BUILD17.hostListener) {\n      hostRef.$flags$ |= 256\n      /* isListenReady */\n      ;\n\n      if (hostRef.$queuedListeners$) {\n        hostRef.$queuedListeners$.map(function (_ref4) {\n          var _ref5 = _slicedToArray(_ref4, 2),\n              methodName = _ref5[0],\n              event = _ref5[1];\n\n          return safeCall(instance, methodName, event);\n        });\n        hostRef.$queuedListeners$ = void 0;\n      }\n    }\n\n    emitLifecycleEvent(elm, \"componentWillLoad\");\n\n    if (BUILD17.cmpWillLoad) {\n      maybePromise = safeCall(instance, \"componentWillLoad\");\n    }\n  } else {\n    emitLifecycleEvent(elm, \"componentWillUpdate\");\n\n    if (BUILD17.cmpWillUpdate) {\n      maybePromise = safeCall(instance, \"componentWillUpdate\");\n    }\n  }\n\n  emitLifecycleEvent(elm, \"componentWillRender\");\n\n  if (BUILD17.cmpWillRender) {\n    maybePromise = enqueue(maybePromise, function () {\n      return safeCall(instance, \"componentWillRender\");\n    });\n  }\n\n  endSchedule();\n  return enqueue(maybePromise, function () {\n    return updateComponent(hostRef, instance, isInitialLoad);\n  });\n};\n\nvar enqueue = function enqueue(maybePromise, fn) {\n  return isPromisey(maybePromise) ? maybePromise.then(fn).catch(function (err2) {\n    console.error(err2);\n    fn();\n  }) : fn();\n};\n\nvar isPromisey = function isPromisey(maybePromise) {\n  return maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === \"function\";\n};\n\nvar updateComponent = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hostRef, instance, isInitialLoad) {\n    var _a, elm, endUpdate, rc, endRender, childrenPromises, postUpdate;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          elm = hostRef.$hostElement$;\n          endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n          rc = elm[\"s-rc\"];\n\n          if (BUILD17.style && isInitialLoad) {\n            attachStyles(hostRef);\n          }\n\n          endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n\n          if (BUILD17.isDev) {\n            hostRef.$flags$ |= 1024\n            /* devOnRender */\n            ;\n          }\n\n          if (!BUILD17.hydrateServerSide) {\n            _context.next = 11;\n            break;\n          }\n\n          _context.next = 9;\n          return callRender(hostRef, instance, elm, isInitialLoad);\n\n        case 9:\n          _context.next = 12;\n          break;\n\n        case 11:\n          callRender(hostRef, instance, elm, isInitialLoad);\n\n        case 12:\n          if (BUILD17.isDev) {\n            hostRef.$renderCount$ = hostRef.$renderCount$ === void 0 ? 1 : hostRef.$renderCount$ + 1;\n            hostRef.$flags$ &= ~1024\n            /* devOnRender */\n            ;\n          }\n\n          if (BUILD17.hydrateServerSide) {\n            try {\n              serverSideConnected(elm);\n\n              if (isInitialLoad) {\n                if (hostRef.$cmpMeta$.$flags$ & 1\n                /* shadowDomEncapsulation */\n                ) {\n                  elm[\"s-en\"] = \"\";\n                } else if (hostRef.$cmpMeta$.$flags$ & 2\n                /* scopedCssEncapsulation */\n                ) {\n                  elm[\"s-en\"] = \"c\";\n                }\n              }\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          }\n\n          if (BUILD17.asyncLoading && rc) {\n            rc.map(function (cb) {\n              return cb();\n            });\n            elm[\"s-rc\"] = void 0;\n          }\n\n          endRender();\n          endUpdate();\n\n          if (BUILD17.asyncLoading) {\n            childrenPromises = (_a = elm[\"s-p\"]) != null ? _a : [];\n\n            postUpdate = function postUpdate() {\n              return postUpdateComponent(hostRef);\n            };\n\n            if (childrenPromises.length === 0) {\n              postUpdate();\n            } else {\n              Promise.all(childrenPromises).then(postUpdate);\n              hostRef.$flags$ |= 4\n              /* isWaitingForChildren */\n              ;\n              childrenPromises.length = 0;\n            }\n          } else {\n            postUpdateComponent(hostRef);\n          }\n\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function updateComponent(_x, _x2, _x3) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar renderingRef = null;\n\nvar callRender = function callRender(hostRef, instance, elm, isInitialLoad) {\n  var allRenderFn = BUILD17.allRenderFn ? true : false;\n  var lazyLoad = BUILD17.lazyLoad ? true : false;\n  var taskQueue = BUILD17.taskQueue ? true : false;\n  var updatable = BUILD17.updatable ? true : false;\n\n  try {\n    renderingRef = instance;\n    instance = allRenderFn ? instance.render() : instance.render && instance.render();\n\n    if (updatable && taskQueue) {\n      hostRef.$flags$ &= ~16\n      /* isQueuedForUpdate */\n      ;\n    }\n\n    if (updatable || lazyLoad) {\n      hostRef.$flags$ |= 2\n      /* hasRendered */\n      ;\n    }\n\n    if (BUILD17.hasRenderFn || BUILD17.reflect) {\n      if (BUILD17.vdomRender || BUILD17.reflect) {\n        if (BUILD17.hydrateServerSide) {\n          return Promise.resolve(instance).then(function (value) {\n            return renderVdom(hostRef, value, isInitialLoad);\n          });\n        } else {\n          renderVdom(hostRef, instance, isInitialLoad);\n        }\n      } else {\n        var shadowRoot = elm.shadowRoot;\n\n        if (hostRef.$cmpMeta$.$flags$ & 1\n        /* shadowDomEncapsulation */\n        ) {\n          shadowRoot.textContent = instance;\n        } else {\n          elm.textContent = instance;\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n\n  renderingRef = null;\n  return null;\n};\n\nvar getRenderingRef = function getRenderingRef() {\n  return renderingRef;\n};\n\nvar postUpdateComponent = function postUpdateComponent(hostRef) {\n  var tagName = hostRef.$cmpMeta$.$tagName$;\n  var elm = hostRef.$hostElement$;\n  var endPostUpdate = createTime(\"postUpdate\", tagName);\n  var instance = BUILD17.lazyLoad ? hostRef.$lazyInstance$ : elm;\n  var ancestorComponent = hostRef.$ancestorComponent$;\n\n  if (BUILD17.cmpDidRender) {\n    if (BUILD17.isDev) {\n      hostRef.$flags$ |= 1024\n      /* devOnRender */\n      ;\n    }\n\n    safeCall(instance, \"componentDidRender\");\n\n    if (BUILD17.isDev) {\n      hostRef.$flags$ &= ~1024\n      /* devOnRender */\n      ;\n    }\n  }\n\n  emitLifecycleEvent(elm, \"componentDidRender\");\n\n  if (!(hostRef.$flags$ & 64\n  /* hasLoadedComponent */\n  )) {\n    hostRef.$flags$ |= 64\n    /* hasLoadedComponent */\n    ;\n\n    if (BUILD17.asyncLoading && BUILD17.cssAnnotations) {\n      addHydratedFlag(elm);\n    }\n\n    if (BUILD17.cmpDidLoad) {\n      if (BUILD17.isDev) {\n        hostRef.$flags$ |= 2048\n        /* devOnDidLoad */\n        ;\n      }\n\n      safeCall(instance, \"componentDidLoad\");\n\n      if (BUILD17.isDev) {\n        hostRef.$flags$ &= ~2048\n        /* devOnDidLoad */\n        ;\n      }\n    }\n\n    emitLifecycleEvent(elm, \"componentDidLoad\");\n    endPostUpdate();\n\n    if (BUILD17.asyncLoading) {\n      hostRef.$onReadyResolve$(elm);\n\n      if (!ancestorComponent) {\n        appDidLoad(tagName);\n      }\n    }\n  } else {\n    if (BUILD17.cmpDidUpdate) {\n      if (BUILD17.isDev) {\n        hostRef.$flags$ |= 1024\n        /* devOnRender */\n        ;\n      }\n\n      safeCall(instance, \"componentDidUpdate\");\n\n      if (BUILD17.isDev) {\n        hostRef.$flags$ &= ~1024\n        /* devOnRender */\n        ;\n      }\n    }\n\n    emitLifecycleEvent(elm, \"componentDidUpdate\");\n    endPostUpdate();\n  }\n\n  if (BUILD17.method && BUILD17.lazyLoad) {\n    hostRef.$onInstanceResolve$(elm);\n  }\n\n  if (BUILD17.asyncLoading) {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = void 0;\n    }\n\n    if (hostRef.$flags$ & 512\n    /* needsRerender */\n    ) {\n      nextTick(function () {\n        return scheduleUpdate(hostRef, false);\n      });\n    }\n\n    hostRef.$flags$ &= ~(4\n    /* isWaitingForChildren */\n    | 512\n    /* needsRerender */\n    );\n  }\n};\n\nvar forceUpdate = function forceUpdate(ref) {\n  if (BUILD17.updatable && (Build.isBrowser || Build.isTesting)) {\n    var hostRef = getHostRef(ref);\n    var isConnected = hostRef.$hostElement$.isConnected;\n\n    if (isConnected && (hostRef.$flags$ & (2\n    /* hasRendered */\n    | 16\n    /* isQueuedForUpdate */\n    )) === 2\n    /* hasRendered */\n    ) {\n      scheduleUpdate(hostRef, false);\n    }\n\n    return isConnected;\n  }\n\n  return false;\n};\n\nvar appDidLoad = function appDidLoad(who) {\n  if (BUILD17.cssAnnotations) {\n    addHydratedFlag(doc.documentElement);\n  }\n\n  if (BUILD17.asyncQueue) {\n    plt.$flags$ |= 2\n    /* appLoaded */\n    ;\n  }\n\n  nextTick(function () {\n    return emitEvent(win, \"appload\", {\n      detail: {\n        namespace: NAMESPACE\n      }\n    });\n  });\n\n  if (BUILD17.profile && performance.measure) {\n    performance.measure(\"[Stencil] \".concat(NAMESPACE, \" initial load (by \").concat(who, \")\"), \"st:app:start\");\n  }\n};\n\nvar safeCall = function safeCall(instance, method, arg) {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  return void 0;\n};\n\nvar emitLifecycleEvent = function emitLifecycleEvent(elm, lifecycleName) {\n  if (BUILD17.lifecycleDOMEvents) {\n    emitEvent(elm, \"stencil_\" + lifecycleName, {\n      bubbles: true,\n      composed: true,\n      detail: {\n        namespace: NAMESPACE\n      }\n    });\n  }\n};\n\nvar addHydratedFlag = function addHydratedFlag(elm) {\n  var _a, _b;\n\n  return BUILD17.hydratedClass ? elm.classList.add((_a = BUILD17.hydratedSelectorName) != null ? _a : \"hydrated\") : BUILD17.hydratedAttribute ? elm.setAttribute((_b = BUILD17.hydratedSelectorName) != null ? _b : \"hydrated\", \"\") : void 0;\n};\n\nvar serverSideConnected = function serverSideConnected(elm) {\n  var children = elm.children;\n\n  if (children != null) {\n    for (var i2 = 0, ii = children.length; i2 < ii; i2++) {\n      var childElm = children[i2];\n\n      if (typeof childElm.connectedCallback === \"function\") {\n        childElm.connectedCallback();\n      }\n\n      serverSideConnected(childElm);\n    }\n  }\n}; // src/runtime/set-value.ts\n\n\nvar getValue = function getValue(ref, propName) {\n  return getHostRef(ref).$instanceValues$.get(propName);\n};\n\nvar setValue = function setValue(ref, propName, newVal, cmpMeta) {\n  var hostRef = getHostRef(ref);\n\n  if (BUILD18.lazyLoad && !hostRef) {\n    throw new Error(\"Couldn't find host element for \\\"\".concat(cmpMeta.$tagName$, \"\\\" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).\"));\n  }\n\n  var elm = BUILD18.lazyLoad ? hostRef.$hostElement$ : ref;\n  var oldVal = hostRef.$instanceValues$.get(propName);\n  var flags = hostRef.$flags$;\n  var instance = BUILD18.lazyLoad ? hostRef.$lazyInstance$ : elm;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n  var areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  var didValueChange = newVal !== oldVal && !areBothNaN;\n\n  if ((!BUILD18.lazyLoad || !(flags & 8\n  /* isConstructingInstance */\n  ) || oldVal === void 0) && didValueChange) {\n    hostRef.$instanceValues$.set(propName, newVal);\n\n    if (BUILD18.isDev) {\n      if (hostRef.$flags$ & 1024\n      /* devOnRender */\n      ) {\n        consoleDevWarn(\"The state/prop \\\"\".concat(propName, \"\\\" changed during rendering. This can potentially lead to infinite-loops and other bugs.\"), \"\\nElement\", elm, \"\\nNew value\", newVal, \"\\nOld value\", oldVal);\n      } else if (hostRef.$flags$ & 2048\n      /* devOnDidLoad */\n      ) {\n        consoleDevWarn(\"The state/prop \\\"\".concat(propName, \"\\\" changed during \\\"componentDidLoad()\\\", this triggers extra re-renders, try to setup on \\\"componentWillLoad()\\\"\"), \"\\nElement\", elm, \"\\nNew value\", newVal, \"\\nOld value\", oldVal);\n      }\n    }\n\n    if (!BUILD18.lazyLoad || instance) {\n      if (BUILD18.watchCallback && cmpMeta.$watchers$ && flags & 128\n      /* isWatchReady */\n      ) {\n        var watchMethods = cmpMeta.$watchers$[propName];\n\n        if (watchMethods) {\n          watchMethods.map(function (watchMethodName) {\n            try {\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n\n      if (BUILD18.updatable && (flags & (2\n      /* hasRendered */\n      | 16\n      /* isQueuedForUpdate */\n      )) === 2\n      /* hasRendered */\n      ) {\n        if (BUILD18.cmpShouldUpdate && instance.componentShouldUpdate) {\n          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n            return;\n          }\n        }\n\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n}; // src/runtime/proxy-component.ts\n\n\nvar proxyComponent = function proxyComponent(Cstr, cmpMeta, flags) {\n  var _a, _b;\n\n  var prototype = Cstr.prototype;\n\n  if (BUILD19.formAssociated && cmpMeta.$flags$ & 64\n  /* formAssociated */\n  && flags & 1\n  /* isElementConstructor */\n  ) {\n    FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS.forEach(function (cbName) {\n      return Object.defineProperty(prototype, cbName, {\n        value: function value() {\n          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            args[_key5] = arguments[_key5];\n          }\n\n          var hostRef = getHostRef(this);\n          var elm = BUILD19.lazyLoad ? hostRef.$hostElement$ : this;\n          var instance = BUILD19.lazyLoad ? hostRef.$lazyInstance$ : elm;\n\n          if (!instance) {\n            hostRef.$onReadyPromise$.then(function (instance2) {\n              var cb = instance2[cbName];\n              typeof cb === \"function\" && cb.call.apply(cb, [instance2].concat(args));\n            });\n          } else {\n            var cb = instance[cbName];\n            typeof cb === \"function\" && cb.call.apply(cb, [instance].concat(args));\n          }\n        }\n      });\n    });\n  }\n\n  if (BUILD19.member && cmpMeta.$members$ || BUILD19.watchCallback && (cmpMeta.$watchers$ || Cstr.watchers)) {\n    if (BUILD19.watchCallback && Cstr.watchers && !cmpMeta.$watchers$) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n\n    var members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});\n    members.map(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n          memberName = _ref8[0],\n          _ref8$ = _slicedToArray(_ref8[1], 1),\n          memberFlags = _ref8$[0];\n\n      if ((BUILD19.prop || BUILD19.state) && (memberFlags & 31\n      /* Prop */\n      || (!BUILD19.lazyLoad || flags & 2\n      /* proxyState */\n      ) && memberFlags & 32\n      /* State */\n      )) {\n        Object.defineProperty(prototype, memberName, {\n          get: function get() {\n            return getValue(this, memberName);\n          },\n          set: function set(newValue) {\n            if (BUILD19.isDev) {\n              var ref = getHostRef(this);\n\n              if ( // we are proxying the instance (not element)\n              (flags & 1\n              /* isElementConstructor */\n              ) === 0 && // the element is not constructing\n              (ref && ref.$flags$ & 8\n              /* isConstructingInstance */\n              ) === 0 && // the member is a prop\n              (memberFlags & 31\n              /* Prop */\n              ) !== 0 && // the member is not mutable\n              (memberFlags & 1024\n              /* Mutable */\n              ) === 0) {\n                consoleDevWarn(\"@Prop() \\\"\".concat(memberName, \"\\\" on <\").concat(cmpMeta.$tagName$, \"> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability\"));\n              }\n            }\n\n            setValue(this, memberName, newValue, cmpMeta);\n          },\n          configurable: true,\n          enumerable: true\n        });\n      } else if (BUILD19.lazyLoad && BUILD19.method && flags & 1\n      /* isElementConstructor */\n      && memberFlags & 64\n      /* Method */\n      ) {\n        Object.defineProperty(prototype, memberName, {\n          value: function value() {\n            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n              args[_key6] = arguments[_key6];\n            }\n\n            var _a2;\n\n            var ref = getHostRef(this);\n            return (_a2 = ref == null ? void 0 : ref.$onInstancePromise$) == null ? void 0 : _a2.then(function () {\n              var _a5;\n\n              var _a3;\n\n              return (_a3 = ref.$lazyInstance$) == null ? void 0 : (_a5 = _a3)[memberName].apply(_a5, args);\n            });\n          }\n        });\n      }\n    });\n\n    if (BUILD19.observeAttribute && (!BUILD19.lazyLoad || flags & 1\n    /* isElementConstructor */\n    )) {\n      var attrNameToPropName = /* @__PURE__ */new Map();\n\n      prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {\n        var _this = this;\n\n        plt.jmp(function () {\n          var _a2;\n\n          var propName = attrNameToPropName.get(attrName);\n\n          if (_this.hasOwnProperty(propName)) {\n            newValue = _this[propName];\n            delete _this[propName];\n          } else if (prototype.hasOwnProperty(propName) && typeof _this[propName] === \"number\" && _this[propName] == newValue) {\n            return;\n          } else if (propName == null) {\n            var hostRef = getHostRef(_this);\n            var flags2 = hostRef == null ? void 0 : hostRef.$flags$;\n\n            if (flags2 && !(flags2 & 8\n            /* isConstructingInstance */\n            ) && flags2 & 128\n            /* isWatchReady */\n            && newValue !== oldValue) {\n              var elm = BUILD19.lazyLoad ? hostRef.$hostElement$ : _this;\n              var instance = BUILD19.lazyLoad ? hostRef.$lazyInstance$ : elm;\n              var entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];\n              entry == null ? void 0 : entry.forEach(function (callbackName) {\n                if (instance[callbackName] != null) {\n                  instance[callbackName].call(instance, newValue, oldValue, attrName);\n                }\n              });\n            }\n\n            return;\n          }\n\n          _this[propName] = newValue === null && typeof _this[propName] === \"boolean\" ? false : newValue;\n        });\n      };\n\n      Cstr.observedAttributes = Array.from( /* @__PURE__ */new Set([].concat(_toConsumableArray(Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {})), _toConsumableArray(members.filter(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            _ = _ref10[0],\n            m = _ref10[1];\n\n        return m[0] & 15;\n      }\n      /* HasAttribute */\n      ).map(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n            propName = _ref12[0],\n            m = _ref12[1];\n\n        var _a2;\n\n        var attrName = m[1] || propName;\n        attrNameToPropName.set(attrName, propName);\n\n        if (BUILD19.reflect && m[0] & 512\n        /* ReflectAttr */\n        ) {\n          (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);\n        }\n\n        return attrName;\n      })))));\n    }\n  }\n\n  return Cstr;\n}; // src/runtime/initialize-component.ts\n\n\nvar initializeComponent = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(elm, hostRef, cmpMeta, hmrVersionId) {\n    var Cstr, bundleId, CstrImport, endLoad, endNewInstance, cmpTag, style, scopeId2, endRegisterStyles, ancestorComponent, schedule;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!((hostRef.$flags$ & 32\n          /* hasInitializedComponent */\n          ) === 0)) {\n            _context2.next = 40;\n            break;\n          }\n\n          hostRef.$flags$ |= 32\n          /* hasInitializedComponent */\n          ;\n          bundleId = cmpMeta.$lazyBundleId$;\n\n          if (!((BUILD20.lazyLoad || BUILD20.hydrateClientSide) && bundleId)) {\n            _context2.next = 26;\n            break;\n          }\n\n          CstrImport = loadModule(cmpMeta, hostRef, hmrVersionId);\n\n          if (!(CstrImport && \"then\" in CstrImport)) {\n            _context2.next = 13;\n            break;\n          }\n\n          endLoad = uniqueTime(\"st:load:\".concat(cmpMeta.$tagName$, \":\").concat(hostRef.$modeName$), \"[Stencil] Load module for <\".concat(cmpMeta.$tagName$, \">\"));\n          _context2.next = 9;\n          return CstrImport;\n\n        case 9:\n          Cstr = _context2.sent;\n          endLoad();\n          _context2.next = 14;\n          break;\n\n        case 13:\n          Cstr = CstrImport;\n\n        case 14:\n          if (Cstr) {\n            _context2.next = 16;\n            break;\n          }\n\n          throw new Error(\"Constructor for \\\"\".concat(cmpMeta.$tagName$, \"#\").concat(hostRef.$modeName$, \"\\\" was not found\"));\n\n        case 16:\n          if (BUILD20.member && !Cstr.isProxied) {\n            if (BUILD20.watchCallback) {\n              cmpMeta.$watchers$ = Cstr.watchers;\n            }\n\n            proxyComponent(Cstr, cmpMeta, 2\n            /* proxyState */\n            );\n            Cstr.isProxied = true;\n          }\n\n          endNewInstance = createTime(\"createInstance\", cmpMeta.$tagName$);\n\n          if (BUILD20.member) {\n            hostRef.$flags$ |= 8\n            /* isConstructingInstance */\n            ;\n          }\n\n          try {\n            new Cstr(hostRef);\n          } catch (e) {\n            consoleError(e);\n          }\n\n          if (BUILD20.member) {\n            hostRef.$flags$ &= ~8\n            /* isConstructingInstance */\n            ;\n          }\n\n          if (BUILD20.watchCallback) {\n            hostRef.$flags$ |= 128\n            /* isWatchReady */\n            ;\n          }\n\n          endNewInstance();\n          fireConnectedCallback(hostRef.$lazyInstance$);\n          _context2.next = 29;\n          break;\n\n        case 26:\n          Cstr = elm.constructor;\n          cmpTag = elm.localName;\n          customElements.whenDefined(cmpTag).then(function () {\n            return hostRef.$flags$ |= 128;\n          }\n          /* isWatchReady */\n          );\n\n        case 29:\n          if (!(BUILD20.style && Cstr && Cstr.style)) {\n            _context2.next = 40;\n            break;\n          }\n\n          if (typeof Cstr.style === \"string\") {\n            style = Cstr.style;\n          } else if (BUILD20.mode && typeof Cstr.style !== \"string\") {\n            hostRef.$modeName$ = computeMode(elm);\n\n            if (hostRef.$modeName$) {\n              style = Cstr.style[hostRef.$modeName$];\n            }\n\n            if (BUILD20.hydrateServerSide && hostRef.$modeName$) {\n              elm.setAttribute(\"s-mode\", hostRef.$modeName$);\n            }\n          }\n\n          scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);\n\n          if (styles.has(scopeId2)) {\n            _context2.next = 40;\n            break;\n          }\n\n          endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n\n          if (!(!BUILD20.hydrateServerSide && BUILD20.shadowDom && // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field\n          BUILD20.shadowDomShim && cmpMeta.$flags$ & 8\n          /* needsShadowDomShim */\n          )) {\n            _context2.next = 38;\n            break;\n          }\n\n          _context2.next = 37;\n          return import(\"./shadow-css.js\").then(function (m) {\n            return m.scopeCss(style, scopeId2, false);\n          });\n\n        case 37:\n          style = _context2.sent;\n\n        case 38:\n          registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1\n          /* shadowDomEncapsulation */\n          ));\n          endRegisterStyles();\n\n        case 40:\n          ancestorComponent = hostRef.$ancestorComponent$;\n\n          schedule = function schedule() {\n            return scheduleUpdate(hostRef, true);\n          };\n\n          if (BUILD20.asyncLoading && ancestorComponent && ancestorComponent[\"s-rc\"]) {\n            ancestorComponent[\"s-rc\"].push(schedule);\n          } else {\n            schedule();\n          }\n\n        case 43:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n\n  return function initializeComponent(_x4, _x5, _x6, _x7) {\n    return _ref13.apply(this, arguments);\n  };\n}();\n\nvar fireConnectedCallback = function fireConnectedCallback(instance) {\n  if (BUILD20.lazyLoad && BUILD20.connectedCallback) {\n    safeCall(instance, \"connectedCallback\");\n  }\n}; // src/runtime/connected-callback.ts\n\n\nvar _connectedCallback = function connectedCallback(elm) {\n  if ((plt.$flags$ & 1\n  /* isTmpDisconnected */\n  ) === 0) {\n    var hostRef = getHostRef(elm);\n    var cmpMeta = hostRef.$cmpMeta$;\n    var endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n\n    if (BUILD21.hostListenerTargetParent) {\n      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n    }\n\n    if (!(hostRef.$flags$ & 1\n    /* hasConnected */\n    )) {\n      hostRef.$flags$ |= 1\n      /* hasConnected */\n      ;\n      var hostId;\n\n      if (BUILD21.hydrateClientSide) {\n        hostId = elm.getAttribute(HYDRATE_ID);\n\n        if (hostId) {\n          if (BUILD21.shadowDom && supportsShadow && cmpMeta.$flags$ & 1\n          /* shadowDomEncapsulation */\n          ) {\n            var scopeId2 = BUILD21.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute(\"s-mode\")) : addStyle(elm.shadowRoot, cmpMeta);\n            elm.classList.remove(scopeId2 + \"-h\", scopeId2 + \"-s\");\n          }\n\n          initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n        }\n      }\n\n      if (BUILD21.slotRelocation && !hostId) {\n        if (BUILD21.hydrateServerSide || (BUILD21.slot || BUILD21.shadowDom) && // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field\n        cmpMeta.$flags$ & (4\n        /* hasSlotRelocation */\n        | 8\n        /* needsShadowDomShim */\n        )) {\n          setContentReference(elm);\n        }\n      }\n\n      if (BUILD21.asyncLoading) {\n        var ancestorComponent = elm;\n\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          if (BUILD21.hydrateClientSide && ancestorComponent.nodeType === 1\n          /* ElementNode */\n          && ancestorComponent.hasAttribute(\"s-id\") && ancestorComponent[\"s-p\"] || ancestorComponent[\"s-p\"]) {\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n\n      if (BUILD21.prop && !BUILD21.hydrateServerSide && cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(function (_ref14) {\n          var _ref15 = _slicedToArray(_ref14, 2),\n              memberName = _ref15[0],\n              _ref15$ = _slicedToArray(_ref15[1], 1),\n              memberFlags = _ref15$[0];\n\n          if (memberFlags & 31\n          /* Prop */\n          && elm.hasOwnProperty(memberName)) {\n            var value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n\n      if (BUILD21.initializeNextTick) {\n        nextTick(function () {\n          return initializeComponent(elm, hostRef, cmpMeta);\n        });\n      } else {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n\n      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {\n        fireConnectedCallback(hostRef.$lazyInstance$);\n      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n        hostRef.$onReadyPromise$.then(function () {\n          return fireConnectedCallback(hostRef.$lazyInstance$);\n        });\n      }\n    }\n\n    endConnected();\n  }\n};\n\nvar setContentReference = function setContentReference(elm) {\n  var contentRefElm = elm[\"s-cr\"] = doc.createComment(BUILD21.isDebug ? \"content-ref (host=\".concat(elm.localName, \")\") : \"\");\n  contentRefElm[\"s-cn\"] = true;\n  insertBefore(elm, contentRefElm, elm.firstChild);\n}; // src/runtime/disconnected-callback.ts\n\n\nimport { BUILD as BUILD22 } from \"@stencil/core/internal/app-data\";\n\nvar disconnectInstance = function disconnectInstance(instance) {\n  if (BUILD22.lazyLoad && BUILD22.disconnectedCallback) {\n    safeCall(instance, \"disconnectedCallback\");\n  }\n\n  if (BUILD22.cmpDidUnload) {\n    safeCall(instance, \"componentDidUnload\");\n  }\n};\n\nvar _disconnectedCallback = /*#__PURE__*/function () {\n  var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(elm) {\n    var hostRef;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          if ((plt.$flags$ & 1\n          /* isTmpDisconnected */\n          ) === 0) {\n            hostRef = getHostRef(elm);\n\n            if (BUILD22.hostListener) {\n              if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map(function (rmListener) {\n                  return rmListener();\n                });\n                hostRef.$rmListeners$ = void 0;\n              }\n            }\n\n            if (!BUILD22.lazyLoad) {\n              disconnectInstance(elm);\n            } else if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {\n              disconnectInstance(hostRef.$lazyInstance$);\n            } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n              hostRef.$onReadyPromise$.then(function () {\n                return disconnectInstance(hostRef.$lazyInstance$);\n              });\n            }\n          }\n\n        case 1:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n\n  return function disconnectedCallback(_x8) {\n    return _ref16.apply(this, arguments);\n  };\n}(); // src/runtime/dom-extras.ts\n\n\nimport { BUILD as BUILD23 } from \"@stencil/core/internal/app-data\";\n\nvar patchPseudoShadowDom = function patchPseudoShadowDom(hostElementPrototype, descriptorPrototype) {\n  patchCloneNode(hostElementPrototype);\n  patchSlotAppendChild(hostElementPrototype);\n  patchSlotAppend(hostElementPrototype);\n  patchSlotPrepend(hostElementPrototype);\n  patchSlotInsertAdjacentElement(hostElementPrototype);\n  patchSlotInsertAdjacentHTML(hostElementPrototype);\n  patchSlotInsertAdjacentText(hostElementPrototype);\n  patchTextContent(hostElementPrototype);\n  patchChildSlotNodes(hostElementPrototype, descriptorPrototype);\n  patchSlotRemoveChild(hostElementPrototype);\n};\n\nvar patchCloneNode = function patchCloneNode(HostElementPrototype) {\n  var orgCloneNode = HostElementPrototype.cloneNode;\n\n  HostElementPrototype.cloneNode = function (deep) {\n    var srcNode = this;\n    var isShadowDom = BUILD23.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n    var clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n\n    if (BUILD23.slot && !isShadowDom && deep) {\n      var i2 = 0;\n      var slotted, nonStencilNode;\n      var stencilPrivates = [\"s-id\", \"s-cr\", \"s-lr\", \"s-rc\", \"s-sc\", \"s-p\", \"s-cn\", \"s-sr\", \"s-sn\", \"s-hn\", \"s-ol\", \"s-nr\", \"s-si\", \"s-rf\", \"s-scs\"];\n\n      for (; i2 < srcNode.childNodes.length; i2++) {\n        slotted = srcNode.childNodes[i2][\"s-nr\"];\n        nonStencilNode = stencilPrivates.every(function (privateField) {\n          return !srcNode.childNodes[i2][privateField];\n        });\n\n        if (slotted) {\n          if (BUILD23.appendChildSlotFix && clonedNode.__appendChild) {\n            clonedNode.__appendChild(slotted.cloneNode(true));\n          } else {\n            clonedNode.appendChild(slotted.cloneNode(true));\n          }\n        }\n\n        if (nonStencilNode) {\n          clonedNode.appendChild(srcNode.childNodes[i2].cloneNode(true));\n        }\n      }\n    }\n\n    return clonedNode;\n  };\n};\n\nvar patchSlotAppendChild = function patchSlotAppendChild(HostElementPrototype) {\n  HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n\n  HostElementPrototype.appendChild = function (newChild) {\n    var slotName = newChild[\"s-sn\"] = getSlotName(newChild);\n    var slotNode = getHostSlotNode(this.childNodes, slotName, this.tagName);\n\n    if (slotNode) {\n      var slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n      var appendAfter = slotChildNodes[slotChildNodes.length - 1];\n      var insertedNode = insertBefore(appendAfter.parentNode, newChild, appendAfter.nextSibling);\n      updateFallbackSlotVisibility(this);\n      return insertedNode;\n    }\n\n    return this.__appendChild(newChild);\n  };\n};\n\nvar patchSlotRemoveChild = function patchSlotRemoveChild(ElementPrototype) {\n  ElementPrototype.__removeChild = ElementPrototype.removeChild;\n\n  ElementPrototype.removeChild = function (toRemove) {\n    if (toRemove && typeof toRemove[\"s-sn\"] !== \"undefined\") {\n      var slotNode = getHostSlotNode(this.childNodes, toRemove[\"s-sn\"], this.tagName);\n\n      if (slotNode) {\n        var slotChildNodes = getHostSlotChildNodes(slotNode, toRemove[\"s-sn\"]);\n        var existingNode = slotChildNodes.find(function (n) {\n          return n === toRemove;\n        });\n\n        if (existingNode) {\n          existingNode.remove();\n          updateFallbackSlotVisibility(this);\n          return;\n        }\n      }\n    }\n\n    return this.__removeChild(toRemove);\n  };\n};\n\nvar patchSlotPrepend = function patchSlotPrepend(HostElementPrototype) {\n  var originalPrepend = HostElementPrototype.prepend;\n\n  HostElementPrototype.prepend = function () {\n    var _this2 = this;\n\n    for (var _len7 = arguments.length, newChildren = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      newChildren[_key7] = arguments[_key7];\n    }\n\n    newChildren.forEach(function (newChild) {\n      if (typeof newChild === \"string\") {\n        newChild = _this2.ownerDocument.createTextNode(newChild);\n      }\n\n      var slotName = newChild[\"s-sn\"] = getSlotName(newChild);\n      var slotNode = getHostSlotNode(_this2.childNodes, slotName, _this2.tagName);\n\n      if (slotNode) {\n        var slotPlaceholder = document.createTextNode(\"\");\n        slotPlaceholder[\"s-nr\"] = newChild;\n\n        slotNode[\"s-cr\"].parentNode.__appendChild(slotPlaceholder);\n\n        newChild[\"s-ol\"] = slotPlaceholder;\n        var slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n        var appendAfter = slotChildNodes[0];\n        return insertBefore(appendAfter.parentNode, newChild, appendAfter.nextSibling);\n      }\n\n      if (newChild.nodeType === 1 && !!newChild.getAttribute(\"slot\")) {\n        newChild.hidden = true;\n      }\n\n      return originalPrepend.call(_this2, newChild);\n    });\n  };\n};\n\nvar patchSlotAppend = function patchSlotAppend(HostElementPrototype) {\n  HostElementPrototype.append = function () {\n    var _this3 = this;\n\n    for (var _len8 = arguments.length, newChildren = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      newChildren[_key8] = arguments[_key8];\n    }\n\n    newChildren.forEach(function (newChild) {\n      if (typeof newChild === \"string\") {\n        newChild = _this3.ownerDocument.createTextNode(newChild);\n      }\n\n      _this3.appendChild(newChild);\n    });\n  };\n};\n\nvar patchSlotInsertAdjacentHTML = function patchSlotInsertAdjacentHTML(HostElementPrototype) {\n  var originalInsertAdjacentHtml = HostElementPrototype.insertAdjacentHTML;\n\n  HostElementPrototype.insertAdjacentHTML = function (position, text) {\n    if (position !== \"afterbegin\" && position !== \"beforeend\") {\n      return originalInsertAdjacentHtml.call(this, position, text);\n    }\n\n    var container = this.ownerDocument.createElement(\"_\");\n    var node;\n    container.innerHTML = text;\n\n    if (position === \"afterbegin\") {\n      while (node = container.firstChild) {\n        this.prepend(node);\n      }\n    } else if (position === \"beforeend\") {\n      while (node = container.firstChild) {\n        this.append(node);\n      }\n    }\n  };\n};\n\nvar patchSlotInsertAdjacentText = function patchSlotInsertAdjacentText(HostElementPrototype) {\n  HostElementPrototype.insertAdjacentText = function (position, text) {\n    this.insertAdjacentHTML(position, text);\n  };\n};\n\nvar patchSlotInsertAdjacentElement = function patchSlotInsertAdjacentElement(HostElementPrototype) {\n  var originalInsertAdjacentElement = HostElementPrototype.insertAdjacentElement;\n\n  HostElementPrototype.insertAdjacentElement = function (position, element) {\n    if (position !== \"afterbegin\" && position !== \"beforeend\") {\n      return originalInsertAdjacentElement.call(this, position, element);\n    }\n\n    if (position === \"afterbegin\") {\n      this.prepend(element);\n      return element;\n    } else if (position === \"beforeend\") {\n      this.append(element);\n      return element;\n    }\n\n    return element;\n  };\n};\n\nvar patchTextContent = function patchTextContent(hostElementPrototype) {\n  var descriptor = Object.getOwnPropertyDescriptor(Node.prototype, \"textContent\");\n  Object.defineProperty(hostElementPrototype, \"__textContent\", descriptor);\n\n  if (BUILD23.experimentalScopedSlotChanges) {\n    Object.defineProperty(hostElementPrototype, \"textContent\", {\n      // To mimic shadow root behavior, we need to return the text content of all\n      // nodes in a slot reference node\n      get: function get() {\n        var slotRefNodes = getAllChildSlotNodes(this.childNodes);\n        var textContent = slotRefNodes.map(function (node) {\n          var _a, _b;\n\n          var text = [];\n          var slotContent = node.nextSibling;\n\n          while (slotContent && slotContent[\"s-sn\"] === node[\"s-sn\"]) {\n            if (slotContent.nodeType === 3\n            /* TEXT_NODE */\n            || slotContent.nodeType === 1\n            /* ELEMENT_NODE */\n            ) {\n              text.push((_b = (_a = slotContent.textContent) == null ? void 0 : _a.trim()) != null ? _b : \"\");\n            }\n\n            slotContent = slotContent.nextSibling;\n          }\n\n          return text.filter(function (ref) {\n            return ref !== \"\";\n          }).join(\" \");\n        }).filter(function (text) {\n          return text !== \"\";\n        }).join(\" \");\n        return \" \" + textContent + \" \";\n      },\n      // To mimic shadow root behavior, we need to overwrite all nodes in a slot\n      // reference node. If a default slot reference node exists, the text content will be\n      // placed there. Otherwise, the new text node will be hidden\n      set: function set(value) {\n        var _this4 = this;\n\n        var slotRefNodes = getAllChildSlotNodes(this.childNodes);\n        slotRefNodes.forEach(function (node) {\n          var slotContent = node.nextSibling;\n\n          while (slotContent && slotContent[\"s-sn\"] === node[\"s-sn\"]) {\n            var tmp = slotContent;\n            slotContent = slotContent.nextSibling;\n            tmp.remove();\n          }\n\n          if (node[\"s-sn\"] === \"\") {\n            var textNode = _this4.ownerDocument.createTextNode(value);\n\n            textNode[\"s-sn\"] = \"\";\n            insertBefore(node.parentElement, textNode, node.nextSibling);\n          } else {\n            node.remove();\n          }\n        });\n      }\n    });\n  } else {\n    Object.defineProperty(hostElementPrototype, \"textContent\", {\n      get: function get() {\n        var _a;\n\n        var slotNode = getHostSlotNode(this.childNodes, \"\", this.tagName);\n\n        if (((_a = slotNode == null ? void 0 : slotNode.nextSibling) == null ? void 0 : _a.nodeType) === 3\n        /* TEXT_NODE */\n        ) {\n          return slotNode.nextSibling.textContent;\n        } else if (slotNode) {\n          return slotNode.textContent;\n        } else {\n          return this.__textContent;\n        }\n      },\n      set: function set(value) {\n        var _a;\n\n        var slotNode = getHostSlotNode(this.childNodes, \"\", this.tagName);\n\n        if (((_a = slotNode == null ? void 0 : slotNode.nextSibling) == null ? void 0 : _a.nodeType) === 3\n        /* TEXT_NODE */\n        ) {\n          slotNode.nextSibling.textContent = value;\n        } else if (slotNode) {\n          slotNode.textContent = value;\n        } else {\n          this.__textContent = value;\n          var contentRefElm = this[\"s-cr\"];\n\n          if (contentRefElm) {\n            insertBefore(this, contentRefElm, this.firstChild);\n          }\n        }\n      }\n    });\n  }\n};\n\nvar patchChildSlotNodes = function patchChildSlotNodes(elm, cmpMeta) {\n  var FakeNodeList = /*#__PURE__*/function (_Array) {\n    function FakeNodeList() {\n      _classCallCheck(this, FakeNodeList);\n\n      return _callSuper(this, FakeNodeList, arguments);\n    }\n\n    _inherits(FakeNodeList, _Array);\n\n    return _createClass(FakeNodeList, [{\n      key: \"item\",\n      value: function item(n) {\n        return this[n];\n      }\n    }]);\n  }( /*#__PURE__*/_wrapNativeSuper(Array));\n\n  if (cmpMeta.$flags$ & 8\n  /* needsShadowDomShim */\n  ) {\n    var childNodesFn = elm.__lookupGetter__(\"childNodes\");\n\n    Object.defineProperty(elm, \"children\", {\n      get: function get() {\n        return this.childNodes.map(function (n) {\n          return n.nodeType === 1;\n        });\n      }\n    });\n    Object.defineProperty(elm, \"childElementCount\", {\n      get: function get() {\n        return elm.children.length;\n      }\n    });\n    Object.defineProperty(elm, \"childNodes\", {\n      get: function get() {\n        var childNodes = childNodesFn.call(this);\n\n        if ((plt.$flags$ & 1\n        /* isTmpDisconnected */\n        ) === 0 && getHostRef(this).$flags$ & 2\n        /* hasRendered */\n        ) {\n          var result = new FakeNodeList();\n\n          for (var i2 = 0; i2 < childNodes.length; i2++) {\n            var slot = childNodes[i2][\"s-nr\"];\n\n            if (slot) {\n              result.push(slot);\n            }\n          }\n\n          return result;\n        }\n\n        return FakeNodeList.from(childNodes);\n      }\n    });\n  }\n};\n\nvar getAllChildSlotNodes = function getAllChildSlotNodes(childNodes) {\n  var slotRefNodes = [];\n\n  for (var _i5 = 0, _Array$from2 = Array.from(childNodes); _i5 < _Array$from2.length; _i5++) {\n    var childNode = _Array$from2[_i5];\n\n    if (childNode[\"s-sr\"]) {\n      slotRefNodes.push(childNode);\n    }\n\n    slotRefNodes.push.apply(slotRefNodes, _toConsumableArray(getAllChildSlotNodes(childNode.childNodes)));\n  }\n\n  return slotRefNodes;\n};\n\nvar getSlotName = function getSlotName(node) {\n  return node[\"s-sn\"] || node.nodeType === 1 && node.getAttribute(\"slot\") || \"\";\n};\n\nvar getHostSlotNode = function getHostSlotNode(childNodes, slotName, hostName) {\n  var i2 = 0;\n  var childNode;\n\n  for (; i2 < childNodes.length; i2++) {\n    childNode = childNodes[i2];\n\n    if (childNode[\"s-sr\"] && childNode[\"s-sn\"] === slotName && childNode[\"s-hn\"] === hostName) {\n      return childNode;\n    }\n\n    childNode = getHostSlotNode(childNode.childNodes, slotName, hostName);\n\n    if (childNode) {\n      return childNode;\n    }\n  }\n\n  return null;\n};\n\nvar getHostSlotChildNodes = function getHostSlotChildNodes(n, slotName) {\n  var childNodes = [n];\n\n  while ((n = n.nextSibling) && n[\"s-sn\"] === slotName) {\n    childNodes.push(n);\n  }\n\n  return childNodes;\n}; // src/runtime/bootstrap-custom-element.ts\n\n\nvar defineCustomElement = function defineCustomElement(Cstr, compactMeta) {\n  customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\n\nvar proxyCustomElement = function proxyCustomElement(Cstr, compactMeta) {\n  var cmpMeta = {\n    $flags$: compactMeta[0],\n    $tagName$: compactMeta[1]\n  };\n\n  if (BUILD24.member) {\n    cmpMeta.$members$ = compactMeta[2];\n  }\n\n  if (BUILD24.hostListener) {\n    cmpMeta.$listeners$ = compactMeta[3];\n  }\n\n  if (BUILD24.watchCallback) {\n    cmpMeta.$watchers$ = Cstr.$watchers$;\n  }\n\n  if (BUILD24.reflect) {\n    cmpMeta.$attrsToReflect$ = [];\n  }\n\n  if (BUILD24.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1\n  /* shadowDomEncapsulation */\n  ) {\n    cmpMeta.$flags$ |= 8\n    /* needsShadowDomShim */\n    ;\n  }\n\n  if (BUILD24.experimentalSlotFixes) {\n    if (BUILD24.scoped && cmpMeta.$flags$ & 2\n    /* scopedCssEncapsulation */\n    ) {\n      patchPseudoShadowDom(Cstr.prototype, cmpMeta);\n    }\n  } else {\n    if (BUILD24.slotChildNodesFix) {\n      patchChildSlotNodes(Cstr.prototype, cmpMeta);\n    }\n\n    if (BUILD24.cloneNodeFix) {\n      patchCloneNode(Cstr.prototype);\n    }\n\n    if (BUILD24.appendChildSlotFix) {\n      patchSlotAppendChild(Cstr.prototype);\n    }\n\n    if (BUILD24.scopedSlotTextContentFix && cmpMeta.$flags$ & 2\n    /* scopedCssEncapsulation */\n    ) {\n      patchTextContent(Cstr.prototype);\n    }\n  }\n\n  var originalConnectedCallback = Cstr.prototype.connectedCallback;\n  var originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n  Object.assign(Cstr.prototype, {\n    __registerHost: function __registerHost() {\n      registerHost(this, cmpMeta);\n    },\n    connectedCallback: function connectedCallback() {\n      var hostRef = getHostRef(this);\n      addHostEventListeners(this, hostRef, cmpMeta.$listeners$, false);\n\n      _connectedCallback(this);\n\n      if (BUILD24.connectedCallback && originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    },\n    disconnectedCallback: function disconnectedCallback() {\n      _disconnectedCallback(this);\n\n      if (BUILD24.disconnectedCallback && originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    },\n    __attachShadow: function __attachShadow() {\n      if (supportsShadow) {\n        if (!this.shadowRoot) {\n          if (BUILD24.shadowDelegatesFocus) {\n            this.attachShadow({\n              mode: \"open\",\n              delegatesFocus: !!(cmpMeta.$flags$ & 16\n              /* shadowDelegatesFocus */\n              )\n            });\n          } else {\n            this.attachShadow({\n              mode: \"open\"\n            });\n          }\n        } else {\n          if (this.shadowRoot.mode !== \"open\") {\n            throw new Error(\"Unable to re-use existing shadow root for \".concat(cmpMeta.$tagName$, \"! Mode is set to \").concat(this.shadowRoot.mode, \" but Stencil only supports open shadow roots.\"));\n          }\n        }\n      } else {\n        this.shadowRoot = this;\n      }\n    }\n  });\n  Cstr.is = cmpMeta.$tagName$;\n  return proxyComponent(Cstr, cmpMeta, 1\n  /* isElementConstructor */\n  | 2\n  /* proxyState */\n  );\n};\n\nvar forceModeUpdate = function forceModeUpdate(elm) {\n  if (BUILD24.style && BUILD24.mode && !BUILD24.lazyLoad) {\n    var mode = computeMode(elm);\n    var hostRef = getHostRef(elm);\n\n    if (hostRef.$modeName$ !== mode) {\n      var cmpMeta = hostRef.$cmpMeta$;\n      var oldScopeId = elm[\"s-sc\"];\n      var scopeId2 = getScopeId(cmpMeta, mode);\n      var style = elm.constructor.style[mode];\n      var flags = cmpMeta.$flags$;\n\n      if (style) {\n        if (!styles.has(scopeId2)) {\n          registerStyle(scopeId2, style, !!(flags & 1\n          /* shadowDomEncapsulation */\n          ));\n        }\n\n        hostRef.$modeName$ = mode;\n        elm.classList.remove(oldScopeId + \"-h\", oldScopeId + \"-s\");\n        attachStyles(hostRef);\n        forceUpdate(elm);\n      }\n    }\n  }\n}; // src/runtime/bootstrap-lazy.ts\n\n\nimport { BUILD as BUILD25 } from \"@stencil/core/internal/app-data\"; // src/runtime/hmr-component.ts\n\nvar hmrStart = function hmrStart(hostElement, cmpMeta, hmrVersionId) {\n  var hostRef = getHostRef(hostElement);\n  hostRef.$flags$ = 1\n  /* hasConnected */\n  ;\n  initializeComponent(hostElement, hostRef, cmpMeta, hmrVersionId);\n}; // src/runtime/bootstrap-lazy.ts\n\n\nvar bootstrapLazy = function bootstrapLazy(lazyBundles) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  if (BUILD25.profile && performance.mark) {\n    performance.mark(\"st:app:start\");\n  }\n\n  installDevTools();\n  var endBootstrap = createTime(\"bootstrapLazy\");\n  var cmpTags = [];\n  var exclude = options.exclude || [];\n  var customElements2 = win.customElements;\n  var head = doc.head;\n  var metaCharset = /* @__PURE__ */head.querySelector(\"meta[charset]\");\n  var dataStyles = /* @__PURE__ */doc.createElement(\"style\");\n  var deferredConnectedCallbacks = [];\n  var styles2 = /* @__PURE__ */doc.querySelectorAll(\"[\".concat(HYDRATED_STYLE_ID, \"]\"));\n  var appLoadFallback;\n  var isBootstrapping = true;\n  var i2 = 0;\n  Object.assign(plt, options);\n  plt.$resourcesUrl$ = new URL(options.resourcesUrl || \"./\", doc.baseURI).href;\n\n  if (BUILD25.asyncQueue) {\n    if (options.syncQueue) {\n      plt.$flags$ |= 4\n      /* queueSync */\n      ;\n    }\n  }\n\n  if (BUILD25.hydrateClientSide) {\n    plt.$flags$ |= 2\n    /* appLoaded */\n    ;\n  }\n\n  if (BUILD25.hydrateClientSide && BUILD25.shadowDom) {\n    for (; i2 < styles2.length; i2++) {\n      registerStyle(styles2[i2].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles2[i2].innerHTML), true);\n    }\n  }\n\n  var hasSlotRelocation = false;\n  lazyBundles.map(function (lazyBundle) {\n    lazyBundle[1].map(function (compactMeta) {\n      var _a2;\n\n      var cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n        $members$: compactMeta[2],\n        $listeners$: compactMeta[3]\n      };\n\n      if (cmpMeta.$flags$ & 4\n      /* hasSlotRelocation */\n      ) {\n        hasSlotRelocation = true;\n      }\n\n      if (BUILD25.member) {\n        cmpMeta.$members$ = compactMeta[2];\n      }\n\n      if (BUILD25.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n      }\n\n      if (BUILD25.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n      }\n\n      if (BUILD25.watchCallback) {\n        cmpMeta.$watchers$ = (_a2 = compactMeta[4]) != null ? _a2 : {};\n      }\n\n      if (BUILD25.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1\n      /* shadowDomEncapsulation */\n      ) {\n        cmpMeta.$flags$ |= 8\n        /* needsShadowDomShim */\n        ;\n      }\n\n      var tagName = BUILD25.transformTagName && options.transformTagName ? options.transformTagName(cmpMeta.$tagName$) : cmpMeta.$tagName$;\n\n      var HostElement = /*#__PURE__*/function (_HTMLElement) {\n        // StencilLazyHost\n        function HostElement(self) {\n          var _this5;\n\n          _classCallCheck(this, HostElement);\n\n          _this5 = _callSuper(this, HostElement, [self]);\n          _this5.hasRegisteredEventListeners = false;\n          self = _this5;\n          registerHost(self, cmpMeta);\n\n          if (BUILD25.shadowDom && cmpMeta.$flags$ & 1\n          /* shadowDomEncapsulation */\n          ) {\n            if (supportsShadow) {\n              if (!self.shadowRoot) {\n                if (BUILD25.shadowDelegatesFocus) {\n                  self.attachShadow({\n                    mode: \"open\",\n                    delegatesFocus: !!(cmpMeta.$flags$ & 16\n                    /* shadowDelegatesFocus */\n                    )\n                  });\n                } else {\n                  self.attachShadow({\n                    mode: \"open\"\n                  });\n                }\n              } else {\n                if (self.shadowRoot.mode !== \"open\") {\n                  throw new Error(\"Unable to re-use existing shadow root for \".concat(cmpMeta.$tagName$, \"! Mode is set to \").concat(self.shadowRoot.mode, \" but Stencil only supports open shadow roots.\"));\n                }\n              }\n            } else if (!BUILD25.hydrateServerSide && !(\"shadowRoot\" in self)) {\n              self.shadowRoot = self;\n            }\n          }\n\n          return _this5;\n        }\n\n        _inherits(HostElement, _HTMLElement);\n\n        return _createClass(HostElement, [{\n          key: \"connectedCallback\",\n          value: function connectedCallback() {\n            var _this6 = this;\n\n            var hostRef = getHostRef(this);\n\n            if (!this.hasRegisteredEventListeners) {\n              this.hasRegisteredEventListeners = true;\n              addHostEventListeners(this, hostRef, cmpMeta.$listeners$, false);\n            }\n\n            if (appLoadFallback) {\n              clearTimeout(appLoadFallback);\n              appLoadFallback = null;\n            }\n\n            if (isBootstrapping) {\n              deferredConnectedCallbacks.push(this);\n            } else {\n              plt.jmp(function () {\n                return _connectedCallback(_this6);\n              });\n            }\n          }\n        }, {\n          key: \"disconnectedCallback\",\n          value: function disconnectedCallback() {\n            var _this7 = this;\n\n            plt.jmp(function () {\n              return _disconnectedCallback(_this7);\n            });\n          }\n        }, {\n          key: \"componentOnReady\",\n          value: function componentOnReady() {\n            return getHostRef(this).$onReadyPromise$;\n          }\n        }]);\n      }( /*#__PURE__*/_wrapNativeSuper(HTMLElement));\n\n      if (BUILD25.experimentalSlotFixes) {\n        if (BUILD25.scoped && cmpMeta.$flags$ & 2\n        /* scopedCssEncapsulation */\n        ) {\n          patchPseudoShadowDom(HostElement.prototype, cmpMeta);\n        }\n      } else {\n        if (BUILD25.slotChildNodesFix) {\n          patchChildSlotNodes(HostElement.prototype, cmpMeta);\n        }\n\n        if (BUILD25.cloneNodeFix) {\n          patchCloneNode(HostElement.prototype);\n        }\n\n        if (BUILD25.appendChildSlotFix) {\n          patchSlotAppendChild(HostElement.prototype);\n        }\n\n        if (BUILD25.scopedSlotTextContentFix && cmpMeta.$flags$ & 2\n        /* scopedCssEncapsulation */\n        ) {\n          patchTextContent(HostElement.prototype);\n        }\n      }\n\n      if (BUILD25.formAssociated && cmpMeta.$flags$ & 64\n      /* formAssociated */\n      ) {\n        HostElement.formAssociated = true;\n      }\n\n      if (BUILD25.hotModuleReplacement) {\n        HostElement.prototype[\"s-hmr\"] = function (hmrVersionId) {\n          hmrStart(this, cmpMeta, hmrVersionId);\n        };\n      }\n\n      cmpMeta.$lazyBundleId$ = lazyBundle[0];\n\n      if (!exclude.includes(tagName) && !customElements2.get(tagName)) {\n        cmpTags.push(tagName);\n        customElements2.define(tagName, proxyComponent(HostElement, cmpMeta, 1\n        /* isElementConstructor */\n        ));\n      }\n    });\n  });\n\n  if (cmpTags.length > 0) {\n    if (hasSlotRelocation) {\n      dataStyles.textContent += SLOT_FB_CSS;\n    }\n\n    if (BUILD25.invisiblePrehydration && (BUILD25.hydratedClass || BUILD25.hydratedAttribute)) {\n      dataStyles.textContent += cmpTags.sort() + HYDRATED_CSS;\n    }\n\n    if (dataStyles.innerHTML.length) {\n      dataStyles.setAttribute(\"data-styles\", \"\");\n      var nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);\n\n      if (nonce != null) {\n        dataStyles.setAttribute(\"nonce\", nonce);\n      }\n\n      head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n  }\n\n  isBootstrapping = false;\n\n  if (deferredConnectedCallbacks.length) {\n    deferredConnectedCallbacks.map(function (host) {\n      return host.connectedCallback();\n    });\n  } else {\n    if (BUILD25.profile) {\n      plt.jmp(function () {\n        return appLoadFallback = setTimeout(appDidLoad, 30, \"timeout\");\n      });\n    } else {\n      plt.jmp(function () {\n        return appLoadFallback = setTimeout(appDidLoad, 30);\n      });\n    }\n  }\n\n  endBootstrap();\n}; // src/runtime/fragment.ts\n\n\nvar Fragment = function Fragment(_, children) {\n  return children;\n}; // src/runtime/host-listener.ts\n\n\nimport { BUILD as BUILD26 } from \"@stencil/core/internal/app-data\";\n\nvar addHostEventListeners = function addHostEventListeners(elm, hostRef, listeners, attachParentListeners) {\n  if (BUILD26.hostListener && listeners) {\n    if (BUILD26.hostListenerTargetParent) {\n      if (attachParentListeners) {\n        listeners = listeners.filter(function (_ref17) {\n          var _ref18 = _slicedToArray(_ref17, 1),\n              flags = _ref18[0];\n\n          return flags & 32;\n        }\n        /* TargetParent */\n        );\n      } else {\n        listeners = listeners.filter(function (_ref19) {\n          var _ref20 = _slicedToArray(_ref19, 1),\n              flags = _ref20[0];\n\n          return !(flags & 32\n          /* TargetParent */\n          );\n        });\n      }\n    }\n\n    listeners.map(function (_ref21) {\n      var _ref22 = _slicedToArray(_ref21, 3),\n          flags = _ref22[0],\n          name = _ref22[1],\n          method = _ref22[2];\n\n      var target = BUILD26.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n      var handler = hostListenerProxy(hostRef, method);\n      var opts = hostListenerOpts(flags);\n      plt.ael(target, name, handler, opts);\n      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(function () {\n        return plt.rel(target, name, handler, opts);\n      });\n    });\n  }\n};\n\nvar hostListenerProxy = function hostListenerProxy(hostRef, methodName) {\n  return function (ev) {\n    var _a;\n\n    try {\n      if (BUILD26.lazyLoad) {\n        if (hostRef.$flags$ & 256\n        /* isListenReady */\n        ) {\n          (_a = hostRef.$lazyInstance$) == null ? void 0 : _a[methodName](ev);\n        } else {\n          (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n        }\n      } else {\n        hostRef.$hostElement$[methodName](ev);\n      }\n    } catch (e) {\n      consoleError(e);\n    }\n  };\n};\n\nvar getHostListenerTarget = function getHostListenerTarget(elm, flags) {\n  if (BUILD26.hostListenerTargetDocument && flags & 4\n  /* TargetDocument */\n  ) return doc;\n  if (BUILD26.hostListenerTargetWindow && flags & 8\n  /* TargetWindow */\n  ) return win;\n  if (BUILD26.hostListenerTargetBody && flags & 16\n  /* TargetBody */\n  ) return doc.body;\n  if (BUILD26.hostListenerTargetParent && flags & 32\n  /* TargetParent */\n  && elm.parentElement) return elm.parentElement;\n  return elm;\n};\n\nvar hostListenerOpts = function hostListenerOpts(flags) {\n  return supportsListenerOptions ? {\n    passive: (flags & 1\n    /* Passive */\n    ) !== 0,\n    capture: (flags & 2\n    /* Capture */\n    ) !== 0\n  } : (flags & 2\n  /* Capture */\n  ) !== 0;\n}; // src/runtime/nonce.ts\n\n\nvar setNonce = function setNonce(nonce) {\n  return plt.$nonce$ = nonce;\n}; // src/runtime/platform-options.ts\n\n\nvar setPlatformOptions = function setPlatformOptions(opts) {\n  return Object.assign(plt, opts);\n}; // src/runtime/vdom/vdom-annotations.ts\n\n\nvar insertVdomAnnotations = function insertVdomAnnotations(doc2, staticComponents) {\n  if (doc2 != null) {\n    var docData = {\n      hostIds: 0,\n      rootLevelIds: 0,\n      staticComponents: new Set(staticComponents)\n    };\n    var orgLocationNodes = [];\n    parseVNodeAnnotations(doc2, doc2.body, docData, orgLocationNodes);\n    orgLocationNodes.forEach(function (orgLocationNode) {\n      var _a;\n\n      if (orgLocationNode != null && orgLocationNode[\"s-nr\"]) {\n        var nodeRef = orgLocationNode[\"s-nr\"];\n        var hostId = nodeRef[\"s-host-id\"];\n        var nodeId = nodeRef[\"s-node-id\"];\n        var childId = \"\".concat(hostId, \".\").concat(nodeId);\n\n        if (hostId == null) {\n          hostId = 0;\n          docData.rootLevelIds++;\n          nodeId = docData.rootLevelIds;\n          childId = \"\".concat(hostId, \".\").concat(nodeId);\n\n          if (nodeRef.nodeType === 1\n          /* ElementNode */\n          ) {\n            nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n          } else if (nodeRef.nodeType === 3\n          /* TextNode */\n          ) {\n            if (hostId === 0) {\n              var textContent = (_a = nodeRef.nodeValue) == null ? void 0 : _a.trim();\n\n              if (textContent === \"\") {\n                orgLocationNode.remove();\n                return;\n              }\n            }\n\n            var commentBeforeTextNode = doc2.createComment(childId);\n            commentBeforeTextNode.nodeValue = \"\".concat(TEXT_NODE_ID, \".\").concat(childId);\n            insertBefore(nodeRef.parentNode, commentBeforeTextNode, nodeRef);\n          }\n        }\n\n        var orgLocationNodeId = \"\".concat(ORG_LOCATION_ID, \".\").concat(childId);\n        var orgLocationParentNode = orgLocationNode.parentElement;\n\n        if (orgLocationParentNode) {\n          if (orgLocationParentNode[\"s-en\"] === \"\") {\n            orgLocationNodeId += \".\";\n          } else if (orgLocationParentNode[\"s-en\"] === \"c\") {\n            orgLocationNodeId += \".c\";\n          }\n        }\n\n        orgLocationNode.nodeValue = orgLocationNodeId;\n      }\n    });\n  }\n};\n\nvar parseVNodeAnnotations = function parseVNodeAnnotations(doc2, node, docData, orgLocationNodes) {\n  var _a;\n\n  if (node == null) {\n    return;\n  }\n\n  if (node[\"s-nr\"] != null) {\n    orgLocationNodes.push(node);\n  }\n\n  if (node.nodeType === 1\n  /* ElementNode */\n  ) {\n    var childNodes = [].concat(_toConsumableArray(Array.from(node.childNodes)), _toConsumableArray(Array.from(((_a = node.shadowRoot) == null ? void 0 : _a.childNodes) || [])));\n    childNodes.forEach(function (childNode) {\n      var hostRef = getHostRef(childNode);\n\n      if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n        var cmpData = {\n          nodeIds: 0\n        };\n        insertVNodeAnnotations(doc2, childNode, hostRef.$vnode$, docData, cmpData);\n      }\n\n      parseVNodeAnnotations(doc2, childNode, docData, orgLocationNodes);\n    });\n  }\n};\n\nvar insertVNodeAnnotations = function insertVNodeAnnotations(doc2, hostElm, vnode, docData, cmpData) {\n  if (vnode != null) {\n    var hostId = ++docData.hostIds;\n    hostElm.setAttribute(HYDRATE_ID, hostId);\n\n    if (hostElm[\"s-cr\"] != null) {\n      hostElm[\"s-cr\"].nodeValue = \"\".concat(CONTENT_REF_ID, \".\").concat(hostId);\n    }\n\n    if (vnode.$children$ != null) {\n      var depth = 0;\n      vnode.$children$.forEach(function (vnodeChild, index) {\n        insertChildVNodeAnnotations(doc2, vnodeChild, cmpData, hostId, depth, index);\n      });\n    }\n\n    if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute(HYDRATE_CHILD_ID)) {\n      var parent = hostElm.parentElement;\n\n      if (parent && parent.childNodes) {\n        var parentChildNodes = Array.from(parent.childNodes);\n        var comment = parentChildNodes.find(function (node) {\n          return node.nodeType === 8\n          /* CommentNode */\n          && node[\"s-sr\"];\n        });\n\n        if (comment) {\n          var index = parentChildNodes.indexOf(hostElm) - 1;\n          vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, \"\".concat(comment[\"s-host-id\"], \".\").concat(comment[\"s-node-id\"], \".0.\").concat(index));\n        }\n      }\n    }\n  }\n};\n\nvar insertChildVNodeAnnotations = function insertChildVNodeAnnotations(doc2, vnodeChild, cmpData, hostId, depth, index) {\n  var childElm = vnodeChild.$elm$;\n\n  if (childElm == null) {\n    return;\n  }\n\n  var nodeId = cmpData.nodeIds++;\n  var childId = \"\".concat(hostId, \".\").concat(nodeId, \".\").concat(depth, \".\").concat(index);\n  childElm[\"s-host-id\"] = hostId;\n  childElm[\"s-node-id\"] = nodeId;\n\n  if (childElm.nodeType === 1\n  /* ElementNode */\n  ) {\n    childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n  } else if (childElm.nodeType === 3\n  /* TextNode */\n  ) {\n    var parentNode = childElm.parentNode;\n    var nodeName = parentNode == null ? void 0 : parentNode.nodeName;\n\n    if (nodeName !== \"STYLE\" && nodeName !== \"SCRIPT\") {\n      var textNodeId = \"\".concat(TEXT_NODE_ID, \".\").concat(childId);\n      var commentBeforeTextNode = doc2.createComment(textNodeId);\n      insertBefore(parentNode, commentBeforeTextNode, childElm);\n    }\n  } else if (childElm.nodeType === 8\n  /* CommentNode */\n  ) {\n    if (childElm[\"s-sr\"]) {\n      var slotName = childElm[\"s-sn\"] || \"\";\n      var slotNodeId = \"\".concat(SLOT_NODE_ID, \".\").concat(childId, \".\").concat(slotName);\n      childElm.nodeValue = slotNodeId;\n    }\n  }\n\n  if (vnodeChild.$children$ != null) {\n    var childDepth = depth + 1;\n    vnodeChild.$children$.forEach(function (vnode, index2) {\n      insertChildVNodeAnnotations(doc2, vnode, cmpData, hostId, childDepth, index2);\n    });\n  }\n};\n\nexport { BUILD27 as BUILD, Build, Env, Fragment, H, H as HTMLElement, Host, NAMESPACE2 as NAMESPACE, STENCIL_DEV_MODE, addHostEventListeners, bootstrapLazy, cmpModules, _connectedCallback as connectedCallback, consoleDevError, consoleDevInfo, consoleDevWarn, consoleError, createEvent, defineCustomElement, _disconnectedCallback as disconnectedCallback, doc, forceModeUpdate, forceUpdate, getAssetPath, getElement, getHostRef, getMode, getRenderingRef, getValue, h, insertVdomAnnotations, isMemberInElement, loadModule, modeResolutionChain, nextTick, parsePropertyValue, plt, postUpdateComponent, promiseResolve, proxyComponent, proxyCustomElement, readTask, registerHost, registerInstance, renderVdom, setAssetPath, setErrorHandler, setMode, setNonce, setPlatformHelpers, setPlatformOptions, setValue, styles, supportsConstructableStylesheets, supportsListenerOptions, supportsShadow, win, writeTask };","map":null,"metadata":{},"sourceType":"module"}