{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-a5d50daf.js';\nimport { r as raf } from './helpers-da915de8.js';\nimport { a as printIonError } from './index-9b0d46f4.js';\n/**\n * Used to update a scoped component that uses emulated slots. This fires when\n * content is passed into the slot or when the content inside of a slot changes.\n * This is not needed for components using native slots in the Shadow DOM.\n * @internal\n * @param el The host element to observe\n * @param slotName mutationCallback will fire when nodes on these slot(s) change\n * @param mutationCallback The callback to fire whenever the slotted content changes\n */\n\nvar createSlotMutationController = function createSlotMutationController(el, slotName, mutationCallback) {\n  var hostMutationObserver;\n  var slottedContentMutationObserver;\n\n  if (win !== undefined && 'MutationObserver' in win) {\n    var slots = Array.isArray(slotName) ? slotName : [slotName];\n    hostMutationObserver = new MutationObserver(function (entries) {\n      var _iterator = _createForOfIteratorHelper(entries),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n\n          var _iterator2 = _createForOfIteratorHelper(entry.addedNodes),\n              _step2;\n\n          try {\n            var _loop = function _loop() {\n              var node = _step2.value;\n\n              /**\n               * Check to see if the added node\n               *  is our slotted content.\n               */\n              if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {\n                /**\n                 * If so, we want to watch the slotted\n                 * content itself for changes. This lets us\n                 * detect when content inside of the slot changes.\n                 */\n                mutationCallback();\n                /**\n                 * Adding the listener in an raf\n                 * waits until Stencil moves the slotted element\n                 * into the correct place in the event that\n                 * slotted content is being added.\n                 */\n\n                raf(function () {\n                  return watchForSlotChange(node);\n                });\n                return {\n                  v: void 0\n                };\n              }\n            },\n                _ret;\n\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _ret = _loop();\n              if (_ret) return _ret.v;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n    hostMutationObserver.observe(el, {\n      childList: true,\n\n      /**\n       * This fixes an issue with the `ion-input` and\n       * `ion-textarea` not re-rendering in some cases\n       * when using the label slot functionality.\n       *\n       * HTML element patches in Stencil that are enabled\n       * by the `experimentalSlotFixes` flag in Stencil v4\n       * result in DOM manipulations that won't trigger\n       * the current mutation observer configuration and\n       * callback.\n       */\n      subtree: true\n    });\n  }\n  /**\n   * Listen for changes inside of the slotted content.\n   * We can listen for subtree changes here to be\n   * informed of text within the slotted content\n   * changing. Doing this on the host is possible\n   * but it is much more expensive to do because\n   * it also listens for changes to the internals\n   * of the component.\n   */\n\n\n  var watchForSlotChange = function watchForSlotChange(slottedEl) {\n    var _a;\n\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n\n    slottedContentMutationObserver = new MutationObserver(function (entries) {\n      mutationCallback();\n\n      var _iterator3 = _createForOfIteratorHelper(entries),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var entry = _step3.value;\n\n          var _iterator4 = _createForOfIteratorHelper(entry.removedNodes),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var node = _step4.value;\n\n              /**\n               * If the element was removed then we\n               * need to destroy the MutationObserver\n               * so the element can be garbage collected.\n               */\n              if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n                destroySlottedContentObserver();\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    });\n    /**\n     * Listen for changes inside of the element\n     * as well as anything deep in the tree.\n     * We listen on the parentElement so that we can\n     * detect when slotted element itself is removed.\n     */\n\n    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, {\n      subtree: true,\n      childList: true\n    });\n  };\n\n  var destroy = function destroy() {\n    if (hostMutationObserver) {\n      hostMutationObserver.disconnect();\n      hostMutationObserver = undefined;\n    }\n\n    destroySlottedContentObserver();\n  };\n\n  var destroySlottedContentObserver = function destroySlottedContentObserver() {\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n  };\n\n  return {\n    destroy: destroy\n  };\n};\n\nvar getCounterText = function getCounterText(value, maxLength, counterFormatter) {\n  var valueLength = value == null ? 0 : value.toString().length;\n  var defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\n  /**\n   * If developers did not pass a custom formatter,\n   * use the default one.\n   */\n\n  if (counterFormatter === undefined) {\n    return defaultCounterText;\n  }\n  /**\n   * Otherwise, try to use the custom formatter\n   * and fallback to the default formatter if\n   * there was an error.\n   */\n\n\n  try {\n    return counterFormatter(valueLength, maxLength);\n  } catch (e) {\n    printIonError('Exception in provided `counterFormatter`.', e);\n    return defaultCounterText;\n  }\n};\n\nvar defaultCounterFormatter = function defaultCounterFormatter(length, maxlength) {\n  return \"\".concat(length, \" / \").concat(maxlength);\n};\n\nexport { createSlotMutationController as c, getCounterText as g };","map":null,"metadata":{},"sourceType":"module"}