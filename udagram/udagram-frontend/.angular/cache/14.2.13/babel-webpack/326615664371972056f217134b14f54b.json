{"ast":null,"code":"import _regeneratorRuntime from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win, d as doc } from './index-a5d50daf.js';\nimport { g as getScrollElement, c as scrollByPoint, f as findClosestIonContent } from './index-5cc724f3.js';\nimport { a as addEventListener, b as removeEventListener, r as raf, c as componentOnReady } from './helpers-da915de8.js';\nimport { a as KeyboardResize, K as Keyboard } from './keyboard-73175e24.js';\nimport './index-9b0d46f4.js';\nimport './capacitor-59395cbd.js';\nvar cloneMap = new WeakMap();\n\nvar relocateInput = function relocateInput(componentEl, inputEl, shouldRelocate) {\n  var inputRelativeY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var disabledClonedInput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY, disabledClonedInput);\n  } else {\n    removeClone(componentEl, inputEl);\n  }\n};\n\nvar isFocused = function isFocused(input) {\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode\n   * Calling getRootNode on an element in standard web page will return HTMLDocument.\n   * Calling getRootNode on an element inside of the Shadow DOM will return the associated ShadowRoot.\n   * Calling getRootNode on an element that is not attached to a document/shadow tree will return\n   * the root of the DOM tree it belongs to.\n   * isFocused is used for the hide-caret utility which only considers input/textarea elements\n   * that are present in the DOM, so we don't set types for that final case since it does not apply.\n   */\n  return input === input.getRootNode().activeElement;\n};\n\nvar addClone = function addClone(componentEl, inputEl, inputRelativeY) {\n  var disabledClonedInput = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  var parentEl = inputEl.parentNode; // DOM WRITES\n\n  var clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  /**\n   * Making the cloned input disabled prevents\n   * Chrome for Android from still scrolling\n   * the entire page since this cloned input\n   * will briefly be hidden by the keyboard\n   * even though it is not focused.\n   *\n   * This is not needed on iOS. While this\n   * does not cause functional issues on iOS,\n   * the input still appears slightly dimmed even\n   * if we set opacity: 1.\n   */\n\n  if (disabledClonedInput) {\n    clonedEl.disabled = true;\n  }\n\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  var doc = componentEl.ownerDocument;\n  var tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = \"translate3d(\".concat(tx, \"px,\").concat(inputRelativeY, \"px,0) scale(0)\");\n};\n\nvar removeClone = function removeClone(componentEl, inputEl) {\n  var clone = cloneMap.get(componentEl);\n\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n};\n/**\n * Factoring in 50px gives us some room\n * in case the keyboard shows password/autofill bars\n * asynchronously.\n */\n\n\nvar SCROLL_AMOUNT_PADDING = 50;\n\nvar enableHideCaretOnScroll = function enableHideCaretOnScroll(componentEl, inputEl, scrollEl) {\n  if (!scrollEl || !inputEl) {\n    return function () {\n      return;\n    };\n  }\n\n  var scrollHideCaret = function scrollHideCaret(shouldHideCaret) {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n\n  var onBlur = function onBlur() {\n    return relocateInput(componentEl, inputEl, false);\n  };\n\n  var hideCaret = function hideCaret() {\n    return scrollHideCaret(true);\n  };\n\n  var showCaret = function showCaret() {\n    return scrollHideCaret(false);\n  };\n\n  addEventListener(scrollEl, 'ionScrollStart', hideCaret);\n  addEventListener(scrollEl, 'ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return function () {\n    removeEventListener(scrollEl, 'ionScrollStart', hideCaret);\n    removeEventListener(scrollEl, 'ionScrollEnd', showCaret);\n    inputEl.removeEventListener('blur', onBlur);\n  };\n};\n\nvar SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';\n\nvar enableInputBlurring = function enableInputBlurring() {\n  var focused = true;\n  var didScroll = false;\n  var doc = document;\n\n  var onScroll = function onScroll() {\n    didScroll = true;\n  };\n\n  var onFocusin = function onFocusin() {\n    focused = true;\n  };\n\n  var onTouchend = function onTouchend(ev) {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n\n    var active = doc.activeElement;\n\n    if (!active) {\n      return;\n    } // only blur if the active element is a text-input or a textarea\n\n\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    } // if the selected target is the active element, do not blur\n\n\n    var tapped = ev.target;\n\n    if (tapped === active) {\n      return;\n    }\n\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n\n    focused = false; // TODO FW-2796: find a better way, why 50ms?\n\n    setTimeout(function () {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  };\n\n  addEventListener(doc, 'ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return function () {\n    removeEventListener(doc, 'ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n};\n\nvar SCROLL_ASSIST_SPEED = 0.3;\n\nvar getScrollData = function getScrollData(componentEl, contentEl, keyboardHeight, platformHeight) {\n  var _a;\n\n  var itemEl = (_a = componentEl.closest('ion-item,[ion-item]')) !== null && _a !== void 0 ? _a : componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, platformHeight);\n};\n\nvar calcScrollData = function calcScrollData(inputRect, contentRect, keyboardHeight, platformHeight) {\n  // compute input's Y values relative to the body\n  var inputTop = inputRect.top;\n  var inputBottom = inputRect.bottom; // compute visible area\n\n  var visibleAreaTop = contentRect.top;\n  var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight); // compute safe area\n\n  var safeAreaTop = visibleAreaTop + 15;\n  var safeAreaBottom = visibleAreaBottom - SCROLL_AMOUNT_PADDING; // figure out if each edge of the input is within the safe area\n\n  var distanceToBottom = safeAreaBottom - inputBottom;\n  var distanceToTop = safeAreaTop - inputTop; // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n\n  var desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0); // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n\n  var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  var distance = Math.abs(scrollAmount);\n  var duration = distance / SCROLL_ASSIST_SPEED;\n  var scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount: scrollAmount,\n    scrollDuration: scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4\n  };\n};\n\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\n/**\n * Scroll padding adds additional padding to the bottom\n * of ion-content so that there is enough scroll space\n * for an input to be scrolled above the keyboard. This\n * is needed in environments where the webview does not\n * resize when the keyboard opens.\n *\n * Example: If an input at the bottom of ion-content is\n * focused, there is no additional scrolling space below\n * it, so the input cannot be scrolled above the keyboard.\n * Scroll padding fixes this by adding padding equal to the\n * height of the keyboard to the bottom of the content.\n *\n * Common environments where this is needed:\n * - Mobile Safari: The keyboard overlays the content\n * - Capacitor/Cordova on iOS: The keyboard overlays the content\n * when the KeyboardResize mode is set to 'none'.\n */\n\nvar setScrollPadding = function setScrollPadding(contentEl, paddingAmount, clearCallback) {\n  var timer = contentEl[PADDING_TIMER_KEY];\n\n  if (timer) {\n    clearTimeout(timer);\n  }\n\n  if (paddingAmount > 0) {\n    contentEl.style.setProperty('--keyboard-offset', \"\".concat(paddingAmount, \"px\"));\n  } else {\n    contentEl[PADDING_TIMER_KEY] = setTimeout(function () {\n      contentEl.style.setProperty('--keyboard-offset', '0px');\n\n      if (clearCallback) {\n        clearCallback();\n      }\n    }, 120);\n  }\n};\n/**\n * When an input is about to be focused,\n * set a timeout to clear any scroll padding\n * on the content. Note: The clearing\n * is done on a timeout so that if users\n * are moving focus from one input to the next\n * then re-adding scroll padding to the new\n * input with cancel the timeout to clear the\n * scroll padding.\n */\n\n\nvar setClearScrollPaddingListener = function setClearScrollPaddingListener(inputEl, contentEl, doneCallback) {\n  var clearScrollPadding = function clearScrollPadding() {\n    if (contentEl) {\n      setScrollPadding(contentEl, 0, doneCallback);\n    }\n  };\n\n  inputEl.addEventListener('focusout', clearScrollPadding, {\n    once: true\n  });\n};\n\nvar currentPadding = 0;\nvar SKIP_SCROLL_ASSIST = 'data-ionic-skip-scroll-assist';\n\nvar enableScrollAssist = function enableScrollAssist(componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, keyboardResize) {\n  var disableClonedInput = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n\n  /**\n   * Scroll padding should only be added if:\n   * 1. The global scrollPadding config option\n   * is set to true.\n   * 2. The native keyboard resize mode is either \"none\"\n   * (keyboard overlays webview) or undefined (resize\n   * information unavailable)\n   * Resize info is available on Capacitor 4+\n   */\n  var addScrollPadding = enableScrollPadding && (keyboardResize === undefined || keyboardResize.mode === KeyboardResize.None);\n  /**\n   * This tracks whether or not the keyboard has been\n   * presented for a single focused text field. Note\n   * that it does not track if the keyboard is open\n   * in general such as if the keyboard is open for\n   * a different focused text field.\n   */\n\n  var hasKeyboardBeenPresentedForTextField = false;\n  /**\n   * When adding scroll padding we need to know\n   * how much of the viewport the keyboard obscures.\n   * We do this by subtracting the keyboard height\n   * from the platform height.\n   *\n   * If we compute this value when switching between\n   * inputs then the webview may already be resized.\n   * At this point, `win.innerHeight` has already accounted\n   * for the keyboard meaning we would then subtract\n   * the keyboard height again. This will result in the input\n   * being scrolled more than it needs to.\n   */\n\n  var platformHeight = win !== undefined ? win.innerHeight : 0;\n  /**\n   * Scroll assist is run when a text field\n   * is focused. However, it may need to\n   * re-run when the keyboard size changes\n   * such that the text field is now hidden\n   * underneath the keyboard.\n   * This function re-runs scroll assist\n   * when that happens.\n   *\n   * One limitation of this is on a web browser\n   * where native keyboard APIs do not have cross-browser\n   * support. `ionKeyboardDidShow` relies on the Visual Viewport API.\n   * This means that if the keyboard changes but does not change\n   * geometry, then scroll assist will not re-run even if\n   * the user has scrolled the text field under the keyboard.\n   * This is not a problem when running in Cordova/Capacitor\n   * because `ionKeyboardDidShow` uses the native events\n   * which fire every time the keyboard changes.\n   */\n\n  var keyboardShow = function keyboardShow(ev) {\n    /**\n     * If the keyboard has not yet been presented\n     * for this text field then the text field has just\n     * received focus. In that case, the focusin listener\n     * will run scroll assist.\n     */\n    if (hasKeyboardBeenPresentedForTextField === false) {\n      hasKeyboardBeenPresentedForTextField = true;\n      return;\n    }\n    /**\n     * Otherwise, the keyboard has already been presented\n     * for the focused text field.\n     * This means that the keyboard likely changed\n     * geometry, and we need to re-run scroll assist.\n     * This can happen when the user rotates their device\n     * or when they switch keyboards.\n     *\n     * Make sure we pass in the computed keyboard height\n     * rather than the estimated keyboard height.\n     *\n     * Since the keyboard is already open then we do not\n     * need to wait for the webview to resize, so we pass\n     * \"waitForResize: false\".\n     */\n\n\n    jsSetFocus(componentEl, inputEl, contentEl, footerEl, ev.detail.keyboardHeight, addScrollPadding, disableClonedInput, platformHeight, false);\n  };\n  /**\n   * Reset the internal state when the text field loses focus.\n   */\n\n\n  var focusOut = function focusOut() {\n    hasKeyboardBeenPresentedForTextField = false;\n    win === null || win === void 0 ? void 0 : win.removeEventListener('ionKeyboardDidShow', keyboardShow);\n    componentEl.removeEventListener('focusout', focusOut);\n  };\n  /**\n   * When the input is about to receive\n   * focus, we need to move it to prevent\n   * mobile Safari from adjusting the viewport.\n   */\n\n\n  var focusIn = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!inputEl.hasAttribute(SKIP_SCROLL_ASSIST)) {\n              _context.next = 3;\n              break;\n            }\n\n            inputEl.removeAttribute(SKIP_SCROLL_ASSIST);\n            return _context.abrupt(\"return\");\n\n          case 3:\n            jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight, addScrollPadding, disableClonedInput, platformHeight);\n            win === null || win === void 0 ? void 0 : win.addEventListener('ionKeyboardDidShow', keyboardShow);\n            componentEl.addEventListener('focusout', focusOut);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n\n    return function focusIn() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  componentEl.addEventListener('focusin', focusIn);\n  return function () {\n    componentEl.removeEventListener('focusin', focusIn);\n    win === null || win === void 0 ? void 0 : win.removeEventListener('ionKeyboardDidShow', keyboardShow);\n    componentEl.removeEventListener('focusout', focusOut);\n  };\n};\n/**\n * Use this function when you want to manually\n * focus an input but not have scroll assist run again.\n */\n\n\nvar setManualFocus = function setManualFocus(el) {\n  /**\n   * If element is already focused then\n   * a new focusin event will not be dispatched\n   * to remove the SKIL_SCROLL_ASSIST attribute.\n   */\n  if (document.activeElement === el) {\n    return;\n  }\n\n  el.setAttribute(SKIP_SCROLL_ASSIST, 'true');\n  el.focus();\n};\n\nvar jsSetFocus = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding) {\n    var disableClonedInput = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    var platformHeight = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    var waitForResize = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n    return /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var scrollData, scrollContentTimeout, scrollContent, doubleKeyboardEventListener, scrollEl, totalScrollAmount;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(!contentEl && !footerEl)) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 2:\n            scrollData = getScrollData(componentEl, contentEl || footerEl, keyboardHeight, platformHeight);\n\n            if (!(contentEl && Math.abs(scrollData.scrollAmount) < 4)) {\n              _context3.next = 7;\n              break;\n            }\n\n            // the text input is in a safe position that doesn't\n            // require it to be scrolled into view, just set focus now\n            setManualFocus(inputEl);\n            /**\n             * Even though the input does not need\n             * scroll assist, we should preserve the\n             * the scroll padding as users could be moving\n             * focus from an input that needs scroll padding\n             * to an input that does not need scroll padding.\n             * If we remove the scroll padding now, users will\n             * see the page jump.\n             */\n\n            if (enableScrollPadding && contentEl !== null) {\n              setScrollPadding(contentEl, currentPadding);\n              setClearScrollPaddingListener(inputEl, contentEl, function () {\n                return currentPadding = 0;\n              });\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 7:\n            // temporarily move the focus to the focus holder so the browser\n            // doesn't freak out while it's trying to get the input in place\n            // at this point the native text input still does not have focus\n            relocateInput(componentEl, inputEl, true, scrollData.inputSafeY, disableClonedInput);\n            setManualFocus(inputEl);\n            /**\n             * Relocating/Focusing input causes the\n             * click event to be cancelled, so\n             * manually fire one here.\n             */\n\n            raf(function () {\n              return componentEl.click();\n            });\n            /**\n             * If enabled, we can add scroll padding to\n             * the bottom of the content so that scroll assist\n             * has enough room to scroll the input above\n             * the keyboard.\n             */\n\n            if (enableScrollPadding && contentEl) {\n              currentPadding = scrollData.scrollPadding;\n              setScrollPadding(contentEl, currentPadding);\n            }\n\n            if (!(typeof window !== 'undefined')) {\n              _context3.next = 24;\n              break;\n            }\n\n            scrollContent = /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) switch (_context2.prev = _context2.next) {\n                    case 0:\n                      // clean up listeners and timeouts\n                      if (scrollContentTimeout !== undefined) {\n                        clearTimeout(scrollContentTimeout);\n                      }\n\n                      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n                      window.removeEventListener('ionKeyboardDidShow', scrollContent); // scroll the input into place\n\n                      if (!contentEl) {\n                        _context2.next = 6;\n                        break;\n                      }\n\n                      _context2.next = 6;\n                      return scrollByPoint(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);\n\n                    case 6:\n                      // the scroll view is in the correct position now\n                      // give the native text input focus\n                      relocateInput(componentEl, inputEl, false, scrollData.inputSafeY); // ensure this is the focused input\n\n                      setManualFocus(inputEl);\n                      /**\n                       * When the input is about to be blurred\n                       * we should set a timeout to remove\n                       * any scroll padding.\n                       */\n\n                      if (enableScrollPadding) {\n                        setClearScrollPaddingListener(inputEl, contentEl, function () {\n                          return currentPadding = 0;\n                        });\n                      }\n\n                    case 9:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }, _callee2);\n              }));\n\n              return function scrollContent() {\n                return _ref3.apply(this, arguments);\n              };\n            }();\n\n            doubleKeyboardEventListener = function doubleKeyboardEventListener() {\n              window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n              window.addEventListener('ionKeyboardDidShow', scrollContent);\n            };\n\n            if (!contentEl) {\n              _context3.next = 23;\n              break;\n            }\n\n            _context3.next = 17;\n            return getScrollElement(contentEl);\n\n          case 17:\n            scrollEl = _context3.sent;\n\n            /**\n             * scrollData will only consider the amount we need\n             * to scroll in order to properly bring the input\n             * into view. It will not consider the amount\n             * we can scroll in the content element.\n             * As a result, scrollData may request a greater\n             * scroll position than is currently available\n             * in the DOM. If this is the case, we need to\n             * wait for the webview to resize/the keyboard\n             * to show in order for additional scroll\n             * bandwidth to become available.\n             */\n            totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n\n            if (!(waitForResize && scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop)) {\n              _context3.next = 23;\n              break;\n            }\n\n            /**\n             * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n             * after the initial keyboard is shown. This prevents the webview from resizing\n             * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n             */\n            if (inputEl.type === 'password') {\n              // Add 50px to account for the \"Passwords\" bar\n              scrollData.scrollAmount += SCROLL_AMOUNT_PADDING;\n              window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n            } else {\n              window.addEventListener('ionKeyboardDidShow', scrollContent);\n            }\n            /**\n             * This should only fire in 2 instances:\n             * 1. The app is very slow.\n             * 2. The app is running in a browser on an old OS\n             * that does not support Ionic Keyboard Events\n             */\n\n\n            scrollContentTimeout = setTimeout(scrollContent, 1000);\n            return _context3.abrupt(\"return\");\n\n          case 23:\n            scrollContent();\n\n          case 24:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    })();\n  });\n\n  return function jsSetFocus(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar INPUT_BLURRING = true;\n\nvar startInputShims = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(config, platform) {\n    var isIOS, isAndroid, keyboardHeight, scrollAssist, hideCaret, inputBlurring, scrollPadding, inputs, hideCaretMap, scrollAssistMap, keyboardResizeMode, registerInput, unregisterInput, _i, _inputs, input;\n\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          if (!(doc === undefined)) {\n            _context5.next = 2;\n            break;\n          }\n\n          return _context5.abrupt(\"return\");\n\n        case 2:\n          isIOS = platform === 'ios';\n          isAndroid = platform === 'android';\n          /**\n           * Hide Caret and Input Blurring are needed on iOS.\n           * Scroll Assist and Scroll Padding are needed on iOS and Android\n           * with Chrome web browser (not Chrome webview).\n           */\n\n          keyboardHeight = config.getNumber('keyboardHeight', 290);\n          scrollAssist = config.getBoolean('scrollAssist', true);\n          hideCaret = config.getBoolean('hideCaretOnScroll', isIOS);\n          /**\n           * The team is evaluating if inputBlurring is still needed. As a result\n           * this feature is disabled by default as of Ionic 8.0. Developers are\n           * able to re-enable it temporarily. The team may remove this utility\n           * if it is determined that doing so would not bring any adverse side effects.\n           * TODO FW-6014 remove input blurring utility (including implementation)\n           */\n\n          inputBlurring = config.getBoolean('inputBlurring', false);\n          scrollPadding = config.getBoolean('scrollPadding', true);\n          inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n          hideCaretMap = new WeakMap();\n          scrollAssistMap = new WeakMap();\n          /**\n           * Grab the native keyboard resize configuration\n           * and pass it to scroll assist. Scroll assist requires\n           * that we adjust the input right before the input\n           * is about to be focused. If we called `Keyboard.getResizeMode`\n           * on focusin in scroll assist, we could potentially adjust the\n           * input too late since this call is async.\n           */\n\n          _context5.next = 14;\n          return Keyboard.getResizeMode();\n\n        case 14:\n          keyboardResizeMode = _context5.sent;\n\n          registerInput = /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(componentEl) {\n              var inputRoot, inputEl, scrollEl, footerEl, rmFn, isDateInput, _rmFn;\n\n              return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                while (1) switch (_context4.prev = _context4.next) {\n                  case 0:\n                    _context4.next = 2;\n                    return new Promise(function (resolve) {\n                      return componentOnReady(componentEl, resolve);\n                    });\n\n                  case 2:\n                    inputRoot = componentEl.shadowRoot || componentEl;\n                    inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n                    scrollEl = findClosestIonContent(componentEl);\n                    footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;\n\n                    if (inputEl) {\n                      _context4.next = 8;\n                      break;\n                    }\n\n                    return _context4.abrupt(\"return\");\n\n                  case 8:\n                    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n                      rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n                      hideCaretMap.set(componentEl, rmFn);\n                    }\n                    /**\n                     * date/datetime-locale inputs on mobile devices show date picker\n                     * overlays instead of keyboards. As a result, scroll assist is\n                     * not needed. This also works around a bug in iOS <16 where\n                     * scroll assist causes the browser to lock up. See FW-1997.\n                     */\n\n\n                    isDateInput = inputEl.type === 'date' || inputEl.type === 'datetime-local';\n\n                    if (!isDateInput && (!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {\n                      _rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight, scrollPadding, keyboardResizeMode, isAndroid);\n                      scrollAssistMap.set(componentEl, _rmFn);\n                    }\n\n                  case 11:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }, _callee4);\n            }));\n\n            return function registerInput(_x9) {\n              return _ref5.apply(this, arguments);\n            };\n          }();\n\n          unregisterInput = function unregisterInput(componentEl) {\n            if (hideCaret) {\n              var fn = hideCaretMap.get(componentEl);\n\n              if (fn) {\n                fn();\n              }\n\n              hideCaretMap.delete(componentEl);\n            }\n\n            if (scrollAssist) {\n              var _fn = scrollAssistMap.get(componentEl);\n\n              if (_fn) {\n                _fn();\n              }\n\n              scrollAssistMap.delete(componentEl);\n            }\n          };\n\n          if (inputBlurring && INPUT_BLURRING) {\n            enableInputBlurring();\n          } // Input might be already loaded in the DOM before ion-device-hacks did.\n          // At this point we need to look for all of the inputs not registered yet\n          // and register them.\n\n\n          for (_i = 0, _inputs = inputs; _i < _inputs.length; _i++) {\n            input = _inputs[_i];\n            registerInput(input);\n          }\n\n          doc.addEventListener('ionInputDidLoad', function (ev) {\n            registerInput(ev.detail);\n          });\n          doc.addEventListener('ionInputDidUnload', function (ev) {\n            unregisterInput(ev.detail);\n          });\n\n        case 21:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n\n  return function startInputShims(_x7, _x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexport { startInputShims };","map":null,"metadata":{},"sourceType":"module"}