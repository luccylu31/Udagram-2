{"ast":null,"code":"import _possibleConstructorReturn from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _isNativeReflectConstruct from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\";\nimport _getPrototypeOf from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _wrapNativeSuper from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _regeneratorRuntime from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createClass from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Udemy/Hosting AWS/Udagram/nd0067-c4-deployment-process-project-starter-online/udagram/udagram-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar NAMESPACE = 'ionic';\nvar BUILD =\n/* ionic */\n{\n  allRenderFn: false,\n  appendChildSlotFix: true,\n  asyncLoading: true,\n  asyncQueue: false,\n  attachStyles: true,\n  cloneNodeFix: true,\n  cmpDidLoad: true,\n  cmpDidRender: true,\n  cmpDidUnload: false,\n  cmpDidUpdate: true,\n  cmpShouldUpdate: false,\n  cmpWillLoad: true,\n  cmpWillRender: true,\n  cmpWillUpdate: false,\n  connectedCallback: true,\n  constructableCSS: true,\n  cssAnnotations: true,\n  devTools: false,\n  disconnectedCallback: true,\n  element: false,\n  event: true,\n  experimentalScopedSlotChanges: true,\n  experimentalSlotFixes: true,\n  formAssociated: false,\n  hasRenderFn: true,\n  hostListener: true,\n  hostListenerTarget: true,\n  hostListenerTargetBody: true,\n  hostListenerTargetDocument: true,\n  hostListenerTargetParent: false,\n  hostListenerTargetWindow: true,\n  hotModuleReplacement: false,\n  hydrateClientSide: true,\n  hydrateServerSide: false,\n  hydratedAttribute: false,\n  hydratedClass: true,\n  hydratedSelectorName: \"hydrated\",\n  initializeNextTick: false,\n  invisiblePrehydration: true,\n  isDebug: false,\n  isDev: false,\n  isTesting: false,\n  lazyLoad: true,\n  lifecycle: true,\n  lifecycleDOMEvents: false,\n  member: true,\n  method: true,\n  mode: true,\n  observeAttribute: true,\n  profile: false,\n  prop: true,\n  propBoolean: true,\n  propMutable: true,\n  propNumber: true,\n  propString: true,\n  reflect: true,\n  scoped: true,\n  scopedSlotTextContentFix: true,\n  scriptDataOpts: false,\n  shadowDelegatesFocus: true,\n  shadowDom: true,\n  slot: true,\n  slotChildNodesFix: true,\n  slotRelocation: true,\n  state: true,\n  style: true,\n  svg: true,\n  taskQueue: true,\n  transformTagName: false,\n  updatable: true,\n  vdomAttribute: true,\n  vdomClass: true,\n  vdomFunctional: true,\n  vdomKey: true,\n  vdomListener: true,\n  vdomPropOrAttr: true,\n  vdomRef: true,\n  vdomRender: true,\n  vdomStyle: true,\n  vdomText: true,\n  vdomXlink: true,\n  watchCallback: true\n};\n/*\n Stencil Client Platform v4.19.2 | MIT Licensed | https://stenciljs.com\n */\n\nvar __defProp = Object.defineProperty;\n\nvar __export = function __export(target, all) {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\nvar Build = {\n  isDev: false,\n  isBrowser: true,\n  isServer: false,\n  isTesting: false\n};\nvar hostRefs = /* @__PURE__ */new WeakMap();\n\nvar getHostRef = function getHostRef(ref) {\n  return hostRefs.get(ref);\n};\n\nvar registerInstance = function registerInstance(lazyInstance, hostRef) {\n  return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\n};\n\nvar registerHost = function registerHost(hostElement, cmpMeta) {\n  var hostRef = {\n    $flags$: 0,\n    $hostElement$: hostElement,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: /* @__PURE__ */new Map()\n  };\n  {\n    hostRef.$onInstancePromise$ = new Promise(function (r) {\n      return hostRef.$onInstanceResolve$ = r;\n    });\n  }\n  {\n    hostRef.$onReadyPromise$ = new Promise(function (r) {\n      return hostRef.$onReadyResolve$ = r;\n    });\n    hostElement[\"s-p\"] = [];\n    hostElement[\"s-rc\"] = [];\n  }\n  return hostRefs.set(hostElement, hostRef);\n};\n\nvar isMemberInElement = function isMemberInElement(elm, memberName) {\n  return memberName in elm;\n};\n\nvar consoleError = function consoleError(e, el) {\n  return (0, console.error)(e, el);\n}; // src/client/client-load-module.ts\n\n\nvar cmpModules = /* @__PURE__ */new Map();\n\nvar loadModule = function loadModule(cmpMeta, hostRef, hmrVersionId) {\n  var exportName = cmpMeta.$tagName$.replace(/-/g, \"_\");\n  var bundleId = cmpMeta.$lazyBundleId$;\n\n  if (!bundleId) {\n    return void 0;\n  }\n\n  var module = cmpModules.get(bundleId);\n\n  if (module) {\n    return module[exportName];\n  }\n  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/\n\n\n  return import(\n  /* @vite-ignore */\n\n  /* webpackInclude: /\\.entry\\.js$/ */\n\n  /* webpackExclude: /\\.system\\.entry\\.js$/ */\n\n  /* webpackMode: \"lazy\" */\n  \"./\".concat(bundleId, \".entry.js\")).then(function (importedModule) {\n    {\n      cmpModules.set(bundleId, importedModule);\n    }\n    return importedModule[exportName];\n  }, consoleError);\n}; // src/client/client-style.ts\n\n\nvar styles = /* @__PURE__ */new Map();\nvar modeResolutionChain = []; // src/runtime/runtime-constants.ts\n\nvar CONTENT_REF_ID = \"r\";\nvar ORG_LOCATION_ID = \"o\";\nvar SLOT_NODE_ID = \"s\";\nvar TEXT_NODE_ID = \"t\";\nvar HYDRATE_ID = \"s-id\";\nvar HYDRATED_STYLE_ID = \"sty-id\";\nvar HYDRATE_CHILD_ID = \"c-id\";\nvar HYDRATED_CSS = \"{visibility:hidden}.hydrated{visibility:inherit}\";\nvar SLOT_FB_CSS = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\";\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\";\nvar win = typeof window !== \"undefined\" ? window : {};\nvar doc = win.document || {\n  head: {}\n};\n\nvar H = win.HTMLElement || /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n  }\n\n  return _createClass(_class);\n}();\n\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: \"\",\n  jmp: function jmp(h2) {\n    return h2();\n  },\n  raf: function raf(h2) {\n    return requestAnimationFrame(h2);\n  },\n  ael: function ael(el, eventName, listener, opts) {\n    return el.addEventListener(eventName, listener, opts);\n  },\n  rel: function rel(el, eventName, listener, opts) {\n    return el.removeEventListener(eventName, listener, opts);\n  },\n  ce: function ce(eventName, opts) {\n    return new CustomEvent(eventName, opts);\n  }\n};\n\nvar setPlatformHelpers = function setPlatformHelpers(helpers) {\n  Object.assign(plt, helpers);\n};\n\nvar supportsShadow = BUILD.shadowDom;\n\nvar supportsListenerOptions = /* @__PURE__ */function () {\n  var supportsListenerOptions2 = false;\n\n  try {\n    doc.addEventListener(\"e\", null, Object.defineProperty({}, \"passive\", {\n      get: function get() {\n        supportsListenerOptions2 = true;\n      }\n    }));\n  } catch (e) {}\n\n  return supportsListenerOptions2;\n}();\n\nvar promiseResolve = function promiseResolve(v) {\n  return Promise.resolve(v);\n};\n\nvar supportsConstructableStylesheets = /* @__PURE__ */function () {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === \"function\";\n  } catch (e) {}\n\n  return false;\n}();\n\nvar queuePending = false;\nvar queueDomReads = [];\nvar queueDomWrites = [];\n\nvar queueTask = function queueTask(queue, write) {\n  return function (cb) {\n    queue.push(cb);\n\n    if (!queuePending) {\n      queuePending = true;\n\n      if (write && plt.$flags$ & 4\n      /* queueSync */\n      ) {\n        nextTick(flush);\n      } else {\n        plt.raf(flush);\n      }\n    }\n  };\n};\n\nvar consume = function consume(queue) {\n  for (var i2 = 0; i2 < queue.length; i2++) {\n    try {\n      queue[i2](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  queue.length = 0;\n};\n\nvar flush = function flush() {\n  consume(queueDomReads);\n  {\n    consume(queueDomWrites);\n\n    if (queuePending = queueDomReads.length > 0) {\n      plt.raf(flush);\n    }\n  }\n};\n\nvar nextTick = function nextTick(cb) {\n  return promiseResolve().then(cb);\n};\n\nvar readTask = /* @__PURE__ */queueTask(queueDomReads, false);\nvar writeTask = /* @__PURE__ */queueTask(queueDomWrites, true); // src/runtime/asset-path.ts\n\nvar getAssetPath = function getAssetPath(path) {\n  var assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n}; // src/utils/constants.ts\n\n\nvar EMPTY_OBJ = {};\nvar SVG_NS = \"http://www.w3.org/2000/svg\";\nvar HTML_NS = \"http://www.w3.org/1999/xhtml\"; // src/utils/helpers.ts\n\nvar isDef = function isDef(v) {\n  return v != null;\n};\n\nvar isComplexType = function isComplexType(o) {\n  o = typeof o;\n  return o === \"object\" || o === \"function\";\n}; // src/utils/query-nonce-meta-tag-content.ts\n\n\nfunction queryNonceMetaTagContent(doc2) {\n  var _a, _b, _c;\n\n  return (_c = (_b = (_a = doc2.head) == null ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) == null ? void 0 : _b.getAttribute(\"content\")) != null ? _c : void 0;\n} // src/utils/result.ts\n\n\nvar result_exports = {};\n\n__export(result_exports, {\n  err: function err() {\n    return _err;\n  },\n  map: function map() {\n    return _map;\n  },\n  ok: function ok() {\n    return _ok;\n  },\n  unwrap: function unwrap() {\n    return _unwrap;\n  },\n  unwrapErr: function unwrapErr() {\n    return _unwrapErr;\n  }\n});\n\nvar _ok = function _ok(value) {\n  return {\n    isOk: true,\n    isErr: false,\n    value: value\n  };\n};\n\nvar _err = function _err(value) {\n  return {\n    isOk: false,\n    isErr: true,\n    value: value\n  };\n};\n\nfunction _map(result, fn) {\n  if (result.isOk) {\n    var val = fn(result.value);\n\n    if (val instanceof Promise) {\n      return val.then(function (newVal) {\n        return _ok(newVal);\n      });\n    } else {\n      return _ok(val);\n    }\n  }\n\n  if (result.isErr) {\n    var value = result.value;\n    return _err(value);\n  }\n\n  throw \"should never get here\";\n}\n\nvar _unwrap = function _unwrap(result) {\n  if (result.isOk) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\nvar _unwrapErr = function _unwrapErr(result) {\n  if (result.isErr) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\nvar createTime = function createTime(fnName) {\n  var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  {\n    return function () {\n      return;\n    };\n  }\n};\n\nvar uniqueTime = function uniqueTime(key, measureText) {\n  {\n    return function () {\n      return;\n    };\n  }\n};\n\nvar h = function h(nodeName, vnodeData) {\n  var child = null;\n  var key = null;\n  var slotName = null;\n  var simple = false;\n  var lastSimple = false;\n  var vNodeChildren = [];\n\n  var walk = function walk(c) {\n    for (var i2 = 0; i2 < c.length; i2++) {\n      child = c[i2];\n\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== \"boolean\") {\n        if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n          child = String(child);\n        }\n\n        if (simple && lastSimple) {\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n\n        lastSimple = simple;\n      }\n    }\n  };\n\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n\n  walk(children);\n\n  if (vnodeData) {\n    if (vnodeData.key) {\n      key = vnodeData.key;\n    }\n\n    if (vnodeData.name) {\n      slotName = vnodeData.name;\n    }\n\n    {\n      var classData = vnodeData.className || vnodeData.class;\n\n      if (classData) {\n        vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter(function (k) {\n          return classData[k];\n        }).join(\" \");\n      }\n    }\n  }\n\n  if (typeof nodeName === \"function\") {\n    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n  }\n\n  var vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n\n  {\n    vnode.$key$ = key;\n  }\n  {\n    vnode.$name$ = slotName;\n  }\n  return vnode;\n};\n\nvar newVNode = function newVNode(tag, text) {\n  var vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  {\n    vnode.$key$ = null;\n  }\n  {\n    vnode.$name$ = null;\n  }\n  return vnode;\n};\n\nvar Host = {};\n\nvar isHost = function isHost(node) {\n  return node && node.$tag$ === Host;\n};\n\nvar vdomFnUtils = {\n  forEach: function forEach(children, cb) {\n    return children.map(convertToPublic).forEach(cb);\n  },\n  map: function map(children, cb) {\n    return children.map(convertToPublic).map(cb).map(convertToPrivate);\n  }\n};\n\nvar convertToPublic = function convertToPublic(node) {\n  return {\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$\n  };\n};\n\nvar convertToPrivate = function convertToPrivate(node) {\n  if (typeof node.vtag === \"function\") {\n    var vnodeData = _objectSpread({}, node.vattrs);\n\n    if (node.vkey) {\n      vnodeData.key = node.vkey;\n    }\n\n    if (node.vname) {\n      vnodeData.name = node.vname;\n    }\n\n    return h.apply(void 0, [node.vtag, vnodeData].concat(_toConsumableArray(node.vchildren || [])));\n  }\n\n  var vnode = newVNode(node.vtag, node.vtext);\n  vnode.$attrs$ = node.vattrs;\n  vnode.$children$ = node.vchildren;\n  vnode.$key$ = node.vkey;\n  vnode.$name$ = node.vname;\n  return vnode;\n}; // src/runtime/client-hydrate.ts\n\n\nvar initializeClientHydrate = function initializeClientHydrate(hostElm, tagName, hostId, hostRef) {\n  var endHydrate = createTime(\"hydrateClient\", tagName);\n  var shadowRoot = hostElm.shadowRoot;\n  var childRenderNodes = [];\n  var slotNodes = [];\n  var shadowRootNodes = shadowRoot ? [] : null;\n  var vnode = hostRef.$vnode$ = newVNode(tagName, null);\n\n  if (!plt.$orgLocNodes$) {\n    initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */new Map());\n  }\n\n  hostElm[HYDRATE_ID] = hostId;\n  hostElm.removeAttribute(HYDRATE_ID);\n  clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n  childRenderNodes.map(function (c) {\n    var orgLocationId = c.$hostId$ + \".\" + c.$nodeId$;\n    var orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n    var node = c.$elm$;\n\n    if (orgLocationNode && supportsShadow && orgLocationNode[\"s-en\"] === \"\") {\n      orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n    }\n\n    if (!shadowRoot) {\n      node[\"s-hn\"] = tagName;\n\n      if (orgLocationNode) {\n        node[\"s-ol\"] = orgLocationNode;\n        node[\"s-ol\"][\"s-nr\"] = node;\n      }\n    }\n\n    plt.$orgLocNodes$.delete(orgLocationId);\n  });\n\n  if (shadowRoot) {\n    shadowRootNodes.map(function (shadowRootNode) {\n      if (shadowRootNode) {\n        shadowRoot.appendChild(shadowRootNode);\n      }\n    });\n  }\n\n  endHydrate();\n};\n\nvar clientHydrate = function clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) {\n  var childNodeType;\n  var childIdSplt;\n  var childVNode;\n  var i2;\n\n  if (node.nodeType === 1\n  /* ElementNode */\n  ) {\n    childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n\n    if (childNodeType) {\n      childIdSplt = childNodeType.split(\".\");\n\n      if (childIdSplt[0] === hostId || childIdSplt[0] === \"0\") {\n        childVNode = {\n          $flags$: 0,\n          $hostId$: childIdSplt[0],\n          $nodeId$: childIdSplt[1],\n          $depth$: childIdSplt[2],\n          $index$: childIdSplt[3],\n          $tag$: node.tagName.toLowerCase(),\n          $elm$: node,\n          $attrs$: null,\n          $children$: null,\n          $key$: null,\n          $name$: null,\n          $text$: null\n        };\n        childRenderNodes.push(childVNode);\n        node.removeAttribute(HYDRATE_CHILD_ID);\n\n        if (!parentVNode.$children$) {\n          parentVNode.$children$ = [];\n        }\n\n        parentVNode.$children$[childVNode.$index$] = childVNode;\n        parentVNode = childVNode;\n\n        if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n          shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n        }\n      }\n    }\n\n    for (i2 = node.childNodes.length - 1; i2 >= 0; i2--) {\n      clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i2], hostId);\n    }\n\n    if (node.shadowRoot) {\n      for (i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--) {\n        clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i2], hostId);\n      }\n    }\n  } else if (node.nodeType === 8\n  /* CommentNode */\n  ) {\n    childIdSplt = node.nodeValue.split(\".\");\n\n    if (childIdSplt[1] === hostId || childIdSplt[1] === \"0\") {\n      childNodeType = childIdSplt[0];\n      childVNode = {\n        $flags$: 0,\n        $hostId$: childIdSplt[1],\n        $nodeId$: childIdSplt[2],\n        $depth$: childIdSplt[3],\n        $index$: childIdSplt[4],\n        $elm$: node,\n        $attrs$: null,\n        $children$: null,\n        $key$: null,\n        $name$: null,\n        $tag$: null,\n        $text$: null\n      };\n\n      if (childNodeType === TEXT_NODE_ID) {\n        childVNode.$elm$ = node.nextSibling;\n\n        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3\n        /* TextNode */\n        ) {\n          childVNode.$text$ = childVNode.$elm$.textContent;\n          childRenderNodes.push(childVNode);\n          node.remove();\n\n          if (!parentVNode.$children$) {\n            parentVNode.$children$ = [];\n          }\n\n          parentVNode.$children$[childVNode.$index$] = childVNode;\n\n          if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n          }\n        }\n      } else if (childVNode.$hostId$ === hostId) {\n        if (childNodeType === SLOT_NODE_ID) {\n          childVNode.$tag$ = \"slot\";\n\n          if (childIdSplt[5]) {\n            node[\"s-sn\"] = childVNode.$name$ = childIdSplt[5];\n          } else {\n            node[\"s-sn\"] = \"\";\n          }\n\n          node[\"s-sr\"] = true;\n\n          if (shadowRootNodes) {\n            childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n\n            if (childVNode.$name$) {\n              childVNode.$elm$.setAttribute(\"name\", childVNode.$name$);\n            }\n\n            node.parentNode.insertBefore(childVNode.$elm$, node);\n            node.remove();\n\n            if (childVNode.$depth$ === \"0\") {\n              shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n            }\n          }\n\n          slotNodes.push(childVNode);\n\n          if (!parentVNode.$children$) {\n            parentVNode.$children$ = [];\n          }\n\n          parentVNode.$children$[childVNode.$index$] = childVNode;\n        } else if (childNodeType === CONTENT_REF_ID) {\n          if (shadowRootNodes) {\n            node.remove();\n          } else {\n            hostElm[\"s-cr\"] = node;\n            node[\"s-cn\"] = true;\n          }\n        }\n      }\n    }\n  } else if (parentVNode && parentVNode.$tag$ === \"style\") {\n    var vnode = newVNode(null, node.textContent);\n    vnode.$elm$ = node;\n    vnode.$index$ = \"0\";\n    parentVNode.$children$ = [vnode];\n  }\n};\n\nvar initializeDocumentHydrate = function initializeDocumentHydrate(node, orgLocNodes) {\n  if (node.nodeType === 1\n  /* ElementNode */\n  ) {\n    var i2 = 0;\n\n    for (; i2 < node.childNodes.length; i2++) {\n      initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);\n    }\n\n    if (node.shadowRoot) {\n      for (i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++) {\n        initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);\n      }\n    }\n  } else if (node.nodeType === 8\n  /* CommentNode */\n  ) {\n    var childIdSplt = node.nodeValue.split(\".\");\n\n    if (childIdSplt[0] === ORG_LOCATION_ID) {\n      orgLocNodes.set(childIdSplt[1] + \".\" + childIdSplt[2], node);\n      node.nodeValue = \"\";\n      node[\"s-en\"] = childIdSplt[3];\n    }\n  }\n}; // src/runtime/mode.ts\n\n\nvar computeMode = function computeMode(elm) {\n  return modeResolutionChain.map(function (h2) {\n    return h2(elm);\n  }).find(function (m) {\n    return !!m;\n  });\n};\n\nvar setMode = function setMode(handler) {\n  return modeResolutionChain.push(handler);\n};\n\nvar getMode = function getMode(ref) {\n  return getHostRef(ref).$modeName$;\n};\n\nvar parsePropertyValue = function parsePropertyValue(propValue, propType) {\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4\n    /* Boolean */\n    ) {\n      return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n    }\n\n    if (propType & 2\n    /* Number */\n    ) {\n      return parseFloat(propValue);\n    }\n\n    if (propType & 1\n    /* String */\n    ) {\n      return String(propValue);\n    }\n\n    return propValue;\n  }\n\n  return propValue;\n};\n\nvar getElement = function getElement(ref) {\n  return getHostRef(ref).$hostElement$;\n}; // src/runtime/event-emitter.ts\n\n\nvar createEvent = function createEvent(ref, name, flags) {\n  var elm = getElement(ref);\n  return {\n    emit: function emit(detail) {\n      return emitEvent(elm, name, {\n        bubbles: !!(flags & 4\n        /* Bubbles */\n        ),\n        composed: !!(flags & 2\n        /* Composed */\n        ),\n        cancelable: !!(flags & 1\n        /* Cancellable */\n        ),\n        detail: detail\n      });\n    }\n  };\n};\n\nvar emitEvent = function emitEvent(elm, name, opts) {\n  var ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\n\nvar rootAppliedStyles = /* @__PURE__ */new WeakMap();\n\nvar registerStyle = function registerStyle(scopeId2, cssText, allowCS) {\n  var style = styles.get(scopeId2);\n\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n\n    if (typeof style === \"string\") {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n\n  styles.set(scopeId2, style);\n};\n\nvar addStyle = function addStyle(styleContainerNode, cmpMeta, mode) {\n  var _a;\n\n  var scopeId2 = getScopeId(cmpMeta, mode);\n  var style = styles.get(scopeId2);\n  styleContainerNode = styleContainerNode.nodeType === 11\n  /* DocumentFragment */\n  ? styleContainerNode : doc;\n\n  if (style) {\n    if (typeof style === \"string\") {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      var appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      var styleElm;\n\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */new Set());\n      }\n\n      if (!appliedStyles.has(scopeId2)) {\n        if (styleContainerNode.host && (styleElm = styleContainerNode.querySelector(\"[\".concat(HYDRATED_STYLE_ID, \"=\\\"\").concat(scopeId2, \"\\\"]\")))) {\n          styleElm.innerHTML = style;\n        } else {\n          styleElm = doc.createElement(\"style\");\n          styleElm.innerHTML = style;\n          var nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);\n\n          if (nonce != null) {\n            styleElm.setAttribute(\"nonce\", nonce);\n          }\n\n          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector(\"link\"));\n        }\n\n        if (cmpMeta.$flags$ & 4\n        /* hasSlotRelocation */\n        ) {\n          styleElm.innerHTML += SLOT_FB_CSS;\n        }\n\n        if (appliedStyles) {\n          appliedStyles.add(scopeId2);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets = [].concat(_toConsumableArray(styleContainerNode.adoptedStyleSheets), [style]);\n    }\n  }\n\n  return scopeId2;\n};\n\nvar attachStyles = function attachStyles(hostRef) {\n  var cmpMeta = hostRef.$cmpMeta$;\n  var elm = hostRef.$hostElement$;\n  var flags = cmpMeta.$flags$;\n  var endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n  var scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);\n\n  if (flags & 10\n  /* needsScopedEncapsulation */\n  ) {\n    elm[\"s-sc\"] = scopeId2;\n    elm.classList.add(scopeId2 + \"-h\");\n\n    if (flags & 2\n    /* scopedCssEncapsulation */\n    ) {\n      elm.classList.add(scopeId2 + \"-s\");\n    }\n  }\n\n  endAttachStyles();\n};\n\nvar getScopeId = function getScopeId(cmp, mode) {\n  return \"sc-\" + (mode && cmp.$flags$ & 32\n  /* hasMode */\n  ? cmp.$tagName$ + \"-\" + mode : cmp.$tagName$);\n};\n\nvar convertScopedToShadow = function convertScopedToShadow(css) {\n  return css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, \"$1{\");\n};\n\nvar setAccessor = function setAccessor(elm, memberName, oldValue, newValue, isSvg, flags) {\n  if (oldValue !== newValue) {\n    var isProp = isMemberInElement(elm, memberName);\n    var ln = memberName.toLowerCase();\n\n    if (memberName === \"class\") {\n      var classList = elm.classList;\n      var oldClasses = parseClassList(oldValue);\n      var newClasses = parseClassList(newValue);\n      classList.remove.apply(classList, _toConsumableArray(oldClasses.filter(function (c) {\n        return c && !newClasses.includes(c);\n      })));\n      classList.add.apply(classList, _toConsumableArray(newClasses.filter(function (c) {\n        return c && !oldClasses.includes(c);\n      })));\n    } else if (memberName === \"style\") {\n      {\n        for (var prop in oldValue) {\n          if (!newValue || newValue[prop] == null) {\n            if (prop.includes(\"-\")) {\n              elm.style.removeProperty(prop);\n            } else {\n              elm.style[prop] = \"\";\n            }\n          }\n        }\n      }\n\n      for (var _prop in newValue) {\n        if (!oldValue || newValue[_prop] !== oldValue[_prop]) {\n          if (_prop.includes(\"-\")) {\n            elm.style.setProperty(_prop, newValue[_prop]);\n          } else {\n            elm.style[_prop] = newValue[_prop];\n          }\n        }\n      }\n    } else if (memberName === \"key\") ;else if (memberName === \"ref\") {\n      if (newValue) {\n        newValue(elm);\n      }\n    } else if (!isProp && memberName[0] === \"o\" && memberName[1] === \"n\") {\n      if (memberName[2] === \"-\") {\n        memberName = memberName.slice(3);\n      } else if (isMemberInElement(win, ln)) {\n        memberName = ln.slice(2);\n      } else {\n        memberName = ln[2] + memberName.slice(3);\n      }\n\n      if (oldValue || newValue) {\n        var capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);\n        memberName = memberName.replace(CAPTURE_EVENT_REGEX, \"\");\n\n        if (oldValue) {\n          plt.rel(elm, memberName, oldValue, capture);\n        }\n\n        if (newValue) {\n          plt.ael(elm, memberName, newValue, capture);\n        }\n      }\n    } else {\n      var isComplex = isComplexType(newValue);\n\n      if ((isProp || isComplex && newValue !== null) && !isSvg) {\n        try {\n          if (!elm.tagName.includes(\"-\")) {\n            var n = newValue == null ? \"\" : newValue;\n\n            if (memberName === \"list\") {\n              isProp = false;\n            } else if (oldValue == null || elm[memberName] != n) {\n              elm[memberName] = n;\n            }\n          } else {\n            elm[memberName] = newValue;\n          }\n        } catch (e) {}\n      }\n\n      var xlink = false;\n      {\n        if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n          memberName = ln;\n          xlink = true;\n        }\n      }\n\n      if (newValue == null || newValue === false) {\n        if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n          if (xlink) {\n            elm.removeAttributeNS(XLINK_NS, memberName);\n          } else {\n            elm.removeAttribute(memberName);\n          }\n        }\n      } else if ((!isProp || flags & 4\n      /* isHost */\n      || isSvg) && !isComplex) {\n        newValue = newValue === true ? \"\" : newValue;\n\n        if (xlink) {\n          elm.setAttributeNS(XLINK_NS, memberName, newValue);\n        } else {\n          elm.setAttribute(memberName, newValue);\n        }\n      }\n    }\n  }\n};\n\nvar parseClassListRegex = /\\s/;\n\nvar parseClassList = function parseClassList(value) {\n  return !value ? [] : value.split(parseClassListRegex);\n};\n\nvar CAPTURE_EVENT_SUFFIX = \"Capture\";\nvar CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + \"$\"); // src/runtime/vdom/update-element.ts\n\nvar updateElement = function updateElement(oldVnode, newVnode, isSvgMode2) {\n  var elm = newVnode.$elm$.nodeType === 11\n  /* DocumentFragment */\n  && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  var oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n  var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n  {\n    var _iterator = _createForOfIteratorHelper(sortedAttrNames(Object.keys(oldVnodeAttrs))),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var memberName = _step.value;\n\n        if (!(memberName in newVnodeAttrs)) {\n          setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(sortedAttrNames(Object.keys(newVnodeAttrs))),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _memberName = _step2.value;\n      setAccessor(elm, _memberName, oldVnodeAttrs[_memberName], newVnodeAttrs[_memberName], isSvgMode2, newVnode.$flags$);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n\nfunction sortedAttrNames(attrNames) {\n  return attrNames.includes(\"ref\") ? // we need to sort these to ensure that `'ref'` is the last attr\n  [].concat(_toConsumableArray(attrNames.filter(function (attr) {\n    return attr !== \"ref\";\n  })), [\"ref\"]) : // no need to sort, return the original array\n  attrNames;\n} // src/runtime/vdom/vdom-render.ts\n\n\nvar scopeId;\nvar contentRef;\nvar hostTagName;\nvar useNativeShadowDom = false;\nvar checkSlotFallbackVisibility = false;\nvar checkSlotRelocate = false;\nvar isSvgMode = false;\n\nvar createElm = function createElm(oldParentVNode, newParentVNode, childIndex, parentElm) {\n  var _a;\n\n  var newVNode2 = newParentVNode.$children$[childIndex];\n  var i2 = 0;\n  var elm;\n  var childNode;\n  var oldVNode;\n\n  if (!useNativeShadowDom) {\n    checkSlotRelocate = true;\n\n    if (newVNode2.$tag$ === \"slot\") {\n      if (scopeId) {\n        parentElm.classList.add(scopeId + \"-s\");\n      }\n\n      newVNode2.$flags$ |= newVNode2.$children$ ? // slot element has fallback content\n      // still create an element that \"mocks\" the slot element\n      2\n      /* isSlotFallback */\n      : // slot element does not have fallback content\n      // create an html comment we'll use to always reference\n      // where actual slot content should sit next to\n      1\n      /* isSlotReference */\n      ;\n    }\n  }\n\n  if (newVNode2.$text$ !== null) {\n    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);\n  } else if (newVNode2.$flags$ & 1\n  /* isSlotReference */\n  ) {\n    elm = newVNode2.$elm$ = doc.createTextNode(\"\");\n  } else {\n    if (!isSvgMode) {\n      isSvgMode = newVNode2.$tag$ === \"svg\";\n    }\n\n    elm = newVNode2.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, !useNativeShadowDom && BUILD.slotRelocation && newVNode2.$flags$ & 2\n    /* isSlotFallback */\n    ? \"slot-fb\" : newVNode2.$tag$);\n\n    if (isSvgMode && newVNode2.$tag$ === \"foreignObject\") {\n      isSvgMode = false;\n    }\n\n    {\n      updateElement(null, newVNode2, isSvgMode);\n    }\n\n    if (isDef(scopeId) && elm[\"s-si\"] !== scopeId) {\n      elm.classList.add(elm[\"s-si\"] = scopeId);\n    }\n\n    {\n      updateElementScopeIds(elm, parentElm);\n    }\n\n    if (newVNode2.$children$) {\n      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {\n        childNode = createElm(oldParentVNode, newVNode2, i2, elm);\n\n        if (childNode) {\n          elm.appendChild(childNode);\n        }\n      }\n    }\n\n    {\n      if (newVNode2.$tag$ === \"svg\") {\n        isSvgMode = false;\n      } else if (elm.tagName === \"foreignObject\") {\n        isSvgMode = true;\n      }\n    }\n  }\n\n  elm[\"s-hn\"] = hostTagName;\n  {\n    if (newVNode2.$flags$ & (2\n    /* isSlotFallback */\n    | 1\n    /* isSlotReference */\n    )) {\n      elm[\"s-sr\"] = true;\n      elm[\"s-cr\"] = contentRef;\n      elm[\"s-sn\"] = newVNode2.$name$ || \"\";\n      elm[\"s-rf\"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;\n      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n\n      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {\n        {\n          relocateToHostRoot(oldParentVNode.$elm$);\n        }\n      }\n    }\n  }\n  return elm;\n};\n\nvar relocateToHostRoot = function relocateToHostRoot(parentElm) {\n  plt.$flags$ |= 1\n  /* isTmpDisconnected */\n  ;\n  var host = parentElm.closest(hostTagName.toLowerCase());\n\n  if (host != null) {\n    var contentRefNode = Array.from(host.childNodes).find(function (ref) {\n      return ref[\"s-cr\"];\n    });\n    var childNodeArray = Array.from(parentElm.childNodes);\n\n    var _iterator3 = _createForOfIteratorHelper(contentRefNode ? childNodeArray.reverse() : childNodeArray),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var childNode = _step3.value;\n\n        if (childNode[\"s-sh\"] != null) {\n          insertBefore(host, childNode, contentRefNode != null ? contentRefNode : null);\n          childNode[\"s-sh\"] = void 0;\n          checkSlotRelocate = true;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  plt.$flags$ &= ~1\n  /* isTmpDisconnected */\n  ;\n};\n\nvar putBackInOriginalLocation = function putBackInOriginalLocation(parentElm, recursive) {\n  plt.$flags$ |= 1\n  /* isTmpDisconnected */\n  ;\n  var oldSlotChildNodes = Array.from(parentElm.childNodes);\n\n  if (parentElm[\"s-sr\"] && BUILD.experimentalSlotFixes) {\n    var node = parentElm;\n\n    while (node = node.nextSibling) {\n      if (node && node[\"s-sn\"] === parentElm[\"s-sn\"] && node[\"s-sh\"] === hostTagName) {\n        oldSlotChildNodes.push(node);\n      }\n    }\n  }\n\n  for (var i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {\n    var childNode = oldSlotChildNodes[i2];\n\n    if (childNode[\"s-hn\"] !== hostTagName && childNode[\"s-ol\"]) {\n      insertBefore(parentReferenceNode(childNode), childNode, referenceNode(childNode));\n      childNode[\"s-ol\"].remove();\n      childNode[\"s-ol\"] = void 0;\n      childNode[\"s-sh\"] = void 0;\n      checkSlotRelocate = true;\n    }\n\n    if (recursive) {\n      putBackInOriginalLocation(childNode, recursive);\n    }\n  }\n\n  plt.$flags$ &= ~1\n  /* isTmpDisconnected */\n  ;\n};\n\nvar addVnodes = function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx) {\n  var containerElm = parentElm[\"s-cr\"] && parentElm[\"s-cr\"].parentNode || parentElm;\n  var childNode;\n\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx, parentElm);\n\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        insertBefore(containerElm, childNode, referenceNode(before));\n      }\n    }\n  }\n};\n\nvar removeVnodes = function removeVnodes(vnodes, startIdx, endIdx) {\n  for (var index = startIdx; index <= endIdx; ++index) {\n    var vnode = vnodes[index];\n\n    if (vnode) {\n      var elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n\n      if (elm) {\n        {\n          checkSlotFallbackVisibility = true;\n\n          if (elm[\"s-ol\"]) {\n            elm[\"s-ol\"].remove();\n          } else {\n            putBackInOriginalLocation(elm, true);\n          }\n        }\n        elm.remove();\n      }\n    }\n  }\n};\n\nvar updateChildren = function updateChildren(parentElm, oldCh, newVNode2, newCh) {\n  var isInitialRender = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var oldStartIdx = 0;\n  var newStartIdx = 0;\n  var idxInOld = 0;\n  var i2 = 0;\n  var oldEndIdx = oldCh.length - 1;\n  var oldStartVnode = oldCh[0];\n  var oldEndVnode = oldCh[oldEndIdx];\n  var newEndIdx = newCh.length - 1;\n  var newStartVnode = newCh[0];\n  var newEndVnode = newCh[newEndIdx];\n  var node;\n  var elmToMove;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {\n      patch(oldStartVnode, newStartVnode, isInitialRender);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {\n      patch(oldEndVnode, newEndVnode, isInitialRender);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {\n      if (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\") {\n        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n      }\n\n      patch(oldStartVnode, newEndVnode, isInitialRender);\n      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {\n      if (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\") {\n        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n      }\n\n      patch(oldEndVnode, newStartVnode, isInitialRender);\n      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      idxInOld = -1;\n      {\n        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {\n          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {\n            idxInOld = i2;\n            break;\n          }\n        }\n      }\n\n      if (idxInOld >= 0) {\n        elmToMove = oldCh[idxInOld];\n\n        if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);\n        } else {\n          patch(elmToMove, newStartVnode, isInitialRender);\n          oldCh[idxInOld] = void 0;\n          node = elmToMove.$elm$;\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);\n        newStartVnode = newCh[++newStartIdx];\n      }\n\n      if (node) {\n        {\n          insertBefore(parentReferenceNode(oldStartVnode.$elm$), node, referenceNode(oldStartVnode.$elm$));\n        }\n      }\n    }\n  }\n\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\n\nvar isSameVnode = function isSameVnode(leftVNode, rightVNode) {\n  var isInitialRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    if (leftVNode.$tag$ === \"slot\") {\n      return leftVNode.$name$ === rightVNode.$name$;\n    }\n\n    if (!isInitialRender) {\n      return leftVNode.$key$ === rightVNode.$key$;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nvar referenceNode = function referenceNode(node) {\n  return node && node[\"s-ol\"] || node;\n};\n\nvar parentReferenceNode = function parentReferenceNode(node) {\n  return (node[\"s-ol\"] ? node[\"s-ol\"] : node).parentNode;\n};\n\nvar patch = function patch(oldVNode, newVNode2) {\n  var isInitialRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var elm = newVNode2.$elm$ = oldVNode.$elm$;\n  var oldChildren = oldVNode.$children$;\n  var newChildren = newVNode2.$children$;\n  var tag = newVNode2.$tag$;\n  var text = newVNode2.$text$;\n  var defaultHolder;\n\n  if (text === null) {\n    {\n      isSvgMode = tag === \"svg\" ? true : tag === \"foreignObject\" ? false : isSvgMode;\n    }\n    {\n      if (tag === \"slot\" && !useNativeShadowDom) {\n        if (oldVNode.$name$ !== newVNode2.$name$) {\n          newVNode2.$elm$[\"s-sn\"] = newVNode2.$name$ || \"\";\n          relocateToHostRoot(newVNode2.$elm$.parentElement);\n        }\n      } else {\n        updateElement(oldVNode, newVNode2, isSvgMode);\n      }\n    }\n\n    if (oldChildren !== null && newChildren !== null) {\n      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);\n    } else if (newChildren !== null) {\n      if (oldVNode.$text$ !== null) {\n        elm.textContent = \"\";\n      }\n\n      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);\n    } else if (oldChildren !== null) {\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    }\n\n    if (isSvgMode && tag === \"svg\") {\n      isSvgMode = false;\n    }\n  } else if (defaultHolder = elm[\"s-cr\"]) {\n    defaultHolder.parentNode.textContent = text;\n  } else if (oldVNode.$text$ !== text) {\n    elm.data = text;\n  }\n};\n\nvar updateFallbackSlotVisibility = function updateFallbackSlotVisibility(elm) {\n  var childNodes = elm.childNodes;\n\n  var _iterator4 = _createForOfIteratorHelper(childNodes),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var childNode = _step4.value;\n\n      if (childNode.nodeType === 1\n      /* ElementNode */\n      ) {\n        if (childNode[\"s-sr\"]) {\n          var slotName = childNode[\"s-sn\"];\n          childNode.hidden = false;\n\n          var _iterator5 = _createForOfIteratorHelper(childNodes),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var siblingNode = _step5.value;\n\n              if (siblingNode !== childNode) {\n                if (siblingNode[\"s-hn\"] !== childNode[\"s-hn\"] || slotName !== \"\") {\n                  if (siblingNode.nodeType === 1\n                  /* ElementNode */\n                  && (slotName === siblingNode.getAttribute(\"slot\") || slotName === siblingNode[\"s-sn\"]) || siblingNode.nodeType === 3\n                  /* TextNode */\n                  && slotName === siblingNode[\"s-sn\"]) {\n                    childNode.hidden = true;\n                    break;\n                  }\n                } else {\n                  if (siblingNode.nodeType === 1\n                  /* ElementNode */\n                  || siblingNode.nodeType === 3\n                  /* TextNode */\n                  && siblingNode.textContent.trim() !== \"\") {\n                    childNode.hidden = true;\n                    break;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        updateFallbackSlotVisibility(childNode);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n};\n\nvar relocateNodes = [];\n\nvar markSlotContentForRelocation = function markSlotContentForRelocation(elm) {\n  var node;\n  var hostContentNodes;\n  var j;\n\n  var _iterator6 = _createForOfIteratorHelper(elm.childNodes),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var childNode = _step6.value;\n\n      if (childNode[\"s-sr\"] && (node = childNode[\"s-cr\"]) && node.parentNode) {\n        hostContentNodes = node.parentNode.childNodes;\n        var slotName = childNode[\"s-sn\"];\n\n        var _loop = function _loop() {\n          node = hostContentNodes[j];\n\n          if (!node[\"s-cn\"] && !node[\"s-nr\"] && node[\"s-hn\"] !== childNode[\"s-hn\"] && (!node[\"s-sh\"] || node[\"s-sh\"] !== childNode[\"s-hn\"])) {\n            if (isNodeLocatedInSlot(node, slotName)) {\n              var relocateNodeData = relocateNodes.find(function (r) {\n                return r.$nodeToRelocate$ === node;\n              });\n              checkSlotFallbackVisibility = true;\n              node[\"s-sn\"] = node[\"s-sn\"] || slotName;\n\n              if (relocateNodeData) {\n                relocateNodeData.$nodeToRelocate$[\"s-sh\"] = childNode[\"s-hn\"];\n                relocateNodeData.$slotRefNode$ = childNode;\n              } else {\n                node[\"s-sh\"] = childNode[\"s-hn\"];\n                relocateNodes.push({\n                  $slotRefNode$: childNode,\n                  $nodeToRelocate$: node\n                });\n              }\n\n              if (node[\"s-sr\"]) {\n                relocateNodes.map(function (relocateNode) {\n                  if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node[\"s-sn\"])) {\n                    relocateNodeData = relocateNodes.find(function (r) {\n                      return r.$nodeToRelocate$ === node;\n                    });\n\n                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                      relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                    }\n                  }\n                });\n              }\n            } else if (!relocateNodes.some(function (r) {\n              return r.$nodeToRelocate$ === node;\n            })) {\n              relocateNodes.push({\n                $nodeToRelocate$: node\n              });\n            }\n          }\n        };\n\n        for (j = hostContentNodes.length - 1; j >= 0; j--) {\n          _loop();\n        }\n      }\n\n      if (childNode.nodeType === 1\n      /* ElementNode */\n      ) {\n        markSlotContentForRelocation(childNode);\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n};\n\nvar isNodeLocatedInSlot = function isNodeLocatedInSlot(nodeToRelocate, slotName) {\n  if (nodeToRelocate.nodeType === 1\n  /* ElementNode */\n  ) {\n    if (nodeToRelocate.getAttribute(\"slot\") === null && slotName === \"\") {\n      return true;\n    }\n\n    if (nodeToRelocate.getAttribute(\"slot\") === slotName) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (nodeToRelocate[\"s-sn\"] === slotName) {\n    return true;\n  }\n\n  return slotName === \"\";\n};\n\nvar nullifyVNodeRefs = function nullifyVNodeRefs(vNode) {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\n\nvar insertBefore = function insertBefore(parent, newNode, reference) {\n  var inserted = parent == null ? void 0 : parent.insertBefore(newNode, reference);\n  {\n    updateElementScopeIds(newNode, parent);\n  }\n  return inserted;\n};\n\nvar findScopeIds = function findScopeIds(element) {\n  var scopeIds = [];\n\n  if (element) {\n    scopeIds.push.apply(scopeIds, _toConsumableArray(element[\"s-scs\"] || []).concat([element[\"s-si\"], element[\"s-sc\"]], _toConsumableArray(findScopeIds(element.parentElement))));\n  }\n\n  return scopeIds;\n};\n\nvar updateElementScopeIds = function updateElementScopeIds(element, parent) {\n  var iterateChildNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _a;\n\n  if (element && parent && element.nodeType === 1\n  /* ElementNode */\n  ) {\n    var scopeIds = new Set(findScopeIds(parent).filter(Boolean));\n\n    if (scopeIds.size) {\n      var _a4;\n\n      (_a = element.classList) == null ? void 0 : (_a4 = _a).add.apply(_a4, _toConsumableArray(element[\"s-scs\"] = _toConsumableArray(scopeIds)));\n\n      if (element[\"s-ol\"] || iterateChildNodes) {\n        for (var _i = 0, _Array$from = Array.from(element.childNodes); _i < _Array$from.length; _i++) {\n          var childNode = _Array$from[_i];\n          updateElementScopeIds(childNode, element, true);\n        }\n      }\n    }\n  }\n};\n\nvar renderVdom = function renderVdom(hostRef, renderFnResults) {\n  var isInitialLoad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _a, _b, _c, _d, _e;\n\n  var hostElm = hostRef.$hostElement$;\n  var cmpMeta = hostRef.$cmpMeta$;\n  var oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  var rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n\n  if (cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          propName = _ref2[0],\n          attribute = _ref2[1];\n\n      return rootVnode.$attrs$[attribute] = hostElm[propName];\n    });\n  }\n\n  if (isInitialLoad && rootVnode.$attrs$) {\n    for (var _i2 = 0, _Object$keys = Object.keys(rootVnode.$attrs$); _i2 < _Object$keys.length; _i2++) {\n      var key = _Object$keys[_i2];\n\n      if (hostElm.hasAttribute(key) && ![\"key\", \"ref\", \"style\", \"class\"].includes(key)) {\n        rootVnode.$attrs$[key] = hostElm[key];\n      }\n    }\n  }\n\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4\n  /* isHost */\n  ;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;\n  {\n    scopeId = hostElm[\"s-sc\"];\n  }\n  useNativeShadowDom = (cmpMeta.$flags$ & 1\n  /* shadowDomEncapsulation */\n  ) !== 0;\n  {\n    contentRef = hostElm[\"s-cr\"];\n    checkSlotFallbackVisibility = false;\n  }\n  patch(oldVNode, rootVnode, isInitialLoad);\n  {\n    plt.$flags$ |= 1\n    /* isTmpDisconnected */\n    ;\n\n    if (checkSlotRelocate) {\n      markSlotContentForRelocation(rootVnode.$elm$);\n\n      for (var _i3 = 0, _relocateNodes = relocateNodes; _i3 < _relocateNodes.length; _i3++) {\n        var relocateData = _relocateNodes[_i3];\n        var nodeToRelocate = relocateData.$nodeToRelocate$;\n\n        if (!nodeToRelocate[\"s-ol\"]) {\n          var orgLocationNode = doc.createTextNode(\"\");\n          orgLocationNode[\"s-nr\"] = nodeToRelocate;\n          insertBefore(nodeToRelocate.parentNode, nodeToRelocate[\"s-ol\"] = orgLocationNode, nodeToRelocate);\n        }\n      }\n\n      for (var _i4 = 0, _relocateNodes2 = relocateNodes; _i4 < _relocateNodes2.length; _i4++) {\n        var _relocateData = _relocateNodes2[_i4];\n        var _nodeToRelocate = _relocateData.$nodeToRelocate$;\n        var slotRefNode = _relocateData.$slotRefNode$;\n\n        if (slotRefNode) {\n          var parentNodeRef = slotRefNode.parentNode;\n          var insertBeforeNode = slotRefNode.nextSibling;\n\n          if (insertBeforeNode && insertBeforeNode.nodeType === 1\n          /* ElementNode */\n          ) {\n            var _orgLocationNode = (_a = _nodeToRelocate[\"s-ol\"]) == null ? void 0 : _a.previousSibling;\n\n            while (_orgLocationNode) {\n              var refNode = (_b = _orgLocationNode[\"s-nr\"]) != null ? _b : null;\n\n              if (refNode && refNode[\"s-sn\"] === _nodeToRelocate[\"s-sn\"] && parentNodeRef === refNode.parentNode) {\n                refNode = refNode.nextSibling;\n\n                while (refNode === _nodeToRelocate || (refNode == null ? void 0 : refNode[\"s-sr\"])) {\n                  refNode = refNode == null ? void 0 : refNode.nextSibling;\n                }\n\n                if (!refNode || !refNode[\"s-nr\"]) {\n                  insertBeforeNode = refNode;\n                  break;\n                }\n              }\n\n              _orgLocationNode = _orgLocationNode.previousSibling;\n            }\n          }\n\n          if (!insertBeforeNode && parentNodeRef !== _nodeToRelocate.parentNode || _nodeToRelocate.nextSibling !== insertBeforeNode) {\n            if (_nodeToRelocate !== insertBeforeNode) {\n              insertBefore(parentNodeRef, _nodeToRelocate, insertBeforeNode);\n\n              if (_nodeToRelocate.nodeType === 1\n              /* ElementNode */\n              ) {\n                _nodeToRelocate.hidden = (_c = _nodeToRelocate[\"s-ih\"]) != null ? _c : false;\n              }\n            }\n          }\n\n          _nodeToRelocate && typeof slotRefNode[\"s-rf\"] === \"function\" && slotRefNode[\"s-rf\"](_nodeToRelocate);\n        } else {\n          if (_nodeToRelocate.nodeType === 1\n          /* ElementNode */\n          ) {\n            if (isInitialLoad) {\n              _nodeToRelocate[\"s-ih\"] = (_d = _nodeToRelocate.hidden) != null ? _d : false;\n            }\n\n            _nodeToRelocate.hidden = true;\n          }\n        }\n      }\n    }\n\n    if (checkSlotFallbackVisibility) {\n      updateFallbackSlotVisibility(rootVnode.$elm$);\n    }\n\n    plt.$flags$ &= ~1\n    /* isTmpDisconnected */\n    ;\n    relocateNodes.length = 0;\n  }\n\n  if (cmpMeta.$flags$ & 2\n  /* scopedCssEncapsulation */\n  ) {\n    var _iterator7 = _createForOfIteratorHelper(rootVnode.$elm$.childNodes),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var childNode = _step7.value;\n\n        if (childNode[\"s-hn\"] !== hostTagName && !childNode[\"s-sh\"]) {\n          if (isInitialLoad && childNode[\"s-ih\"] == null) {\n            childNode[\"s-ih\"] = (_e = childNode.hidden) != null ? _e : false;\n          }\n\n          childNode.hidden = true;\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  }\n\n  contentRef = void 0;\n}; // src/runtime/update-component.ts\n\n\nvar attachToAncestor = function attachToAncestor(hostRef, ancestorComponent) {\n  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n    ancestorComponent[\"s-p\"].push(new Promise(function (r) {\n      return hostRef.$onRenderResolve$ = r;\n    }));\n  }\n};\n\nvar scheduleUpdate = function scheduleUpdate(hostRef, isInitialLoad) {\n  {\n    hostRef.$flags$ |= 16\n    /* isQueuedForUpdate */\n    ;\n  }\n\n  if (hostRef.$flags$ & 4\n  /* isWaitingForChildren */\n  ) {\n    hostRef.$flags$ |= 512\n    /* needsRerender */\n    ;\n    return;\n  }\n\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n\n  var dispatch = function dispatch() {\n    return dispatchHooks(hostRef, isInitialLoad);\n  };\n\n  return writeTask(dispatch);\n};\n\nvar dispatchHooks = function dispatchHooks(hostRef, isInitialLoad) {\n  var elm = hostRef.$hostElement$;\n  var endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n  var instance = hostRef.$lazyInstance$;\n\n  if (!instance) {\n    throw new Error(\"Can't render component <\".concat(elm.tagName.toLowerCase(), \" /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime\"));\n  }\n\n  var maybePromise;\n\n  if (isInitialLoad) {\n    {\n      hostRef.$flags$ |= 256\n      /* isListenReady */\n      ;\n\n      if (hostRef.$queuedListeners$) {\n        hostRef.$queuedListeners$.map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              methodName = _ref4[0],\n              event = _ref4[1];\n\n          return safeCall(instance, methodName, event);\n        });\n        hostRef.$queuedListeners$ = void 0;\n      }\n    }\n    {\n      maybePromise = safeCall(instance, \"componentWillLoad\");\n    }\n  }\n\n  {\n    maybePromise = enqueue(maybePromise, function () {\n      return safeCall(instance, \"componentWillRender\");\n    });\n  }\n  endSchedule();\n  return enqueue(maybePromise, function () {\n    return updateComponent(hostRef, instance, isInitialLoad);\n  });\n};\n\nvar enqueue = function enqueue(maybePromise, fn) {\n  return isPromisey(maybePromise) ? maybePromise.then(fn).catch(function (err2) {\n    console.error(err2);\n    fn();\n  }) : fn();\n};\n\nvar isPromisey = function isPromisey(maybePromise) {\n  return maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === \"function\";\n};\n\nvar updateComponent = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hostRef, instance, isInitialLoad) {\n    var _a, elm, endUpdate, rc, endRender, childrenPromises, postUpdate;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          elm = hostRef.$hostElement$;\n          endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n          rc = elm[\"s-rc\"];\n\n          if (isInitialLoad) {\n            attachStyles(hostRef);\n          }\n\n          endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n          callRender(hostRef, instance, elm, isInitialLoad);\n\n          if (rc) {\n            rc.map(function (cb) {\n              return cb();\n            });\n            elm[\"s-rc\"] = void 0;\n          }\n\n          endRender();\n          endUpdate();\n          childrenPromises = (_a = elm[\"s-p\"]) != null ? _a : [];\n\n          postUpdate = function postUpdate() {\n            return postUpdateComponent(hostRef);\n          };\n\n          if (childrenPromises.length === 0) {\n            postUpdate();\n          } else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4\n            /* isWaitingForChildren */\n            ;\n            childrenPromises.length = 0;\n          }\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function updateComponent(_x, _x2, _x3) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar callRender = function callRender(hostRef, instance, elm, isInitialLoad) {\n  try {\n    instance = instance.render && instance.render();\n    {\n      hostRef.$flags$ &= ~16\n      /* isQueuedForUpdate */\n      ;\n    }\n    {\n      hostRef.$flags$ |= 2\n      /* hasRendered */\n      ;\n    }\n    {\n      {\n        {\n          renderVdom(hostRef, instance, isInitialLoad);\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n\n  return null;\n};\n\nvar postUpdateComponent = function postUpdateComponent(hostRef) {\n  var tagName = hostRef.$cmpMeta$.$tagName$;\n  var elm = hostRef.$hostElement$;\n  var endPostUpdate = createTime(\"postUpdate\", tagName);\n  var instance = hostRef.$lazyInstance$;\n  var ancestorComponent = hostRef.$ancestorComponent$;\n  {\n    safeCall(instance, \"componentDidRender\");\n  }\n\n  if (!(hostRef.$flags$ & 64\n  /* hasLoadedComponent */\n  )) {\n    hostRef.$flags$ |= 64\n    /* hasLoadedComponent */\n    ;\n    {\n      addHydratedFlag(elm);\n    }\n    {\n      safeCall(instance, \"componentDidLoad\");\n    }\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    {\n      safeCall(instance, \"componentDidUpdate\");\n    }\n    endPostUpdate();\n  }\n\n  {\n    hostRef.$onInstanceResolve$(elm);\n  }\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = void 0;\n    }\n\n    if (hostRef.$flags$ & 512\n    /* needsRerender */\n    ) {\n      nextTick(function () {\n        return scheduleUpdate(hostRef, false);\n      });\n    }\n\n    hostRef.$flags$ &= ~(4\n    /* isWaitingForChildren */\n    | 512\n    /* needsRerender */\n    );\n  }\n};\n\nvar forceUpdate = function forceUpdate(ref) {\n  {\n    var hostRef = getHostRef(ref);\n    var isConnected = hostRef.$hostElement$.isConnected;\n\n    if (isConnected && (hostRef.$flags$ & (2\n    /* hasRendered */\n    | 16\n    /* isQueuedForUpdate */\n    )) === 2\n    /* hasRendered */\n    ) {\n      scheduleUpdate(hostRef, false);\n    }\n\n    return isConnected;\n  }\n};\n\nvar appDidLoad = function appDidLoad(who) {\n  {\n    addHydratedFlag(doc.documentElement);\n  }\n  nextTick(function () {\n    return emitEvent(win, \"appload\", {\n      detail: {\n        namespace: NAMESPACE\n      }\n    });\n  });\n};\n\nvar safeCall = function safeCall(instance, method, arg) {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  return void 0;\n};\n\nvar addHydratedFlag = function addHydratedFlag(elm) {\n  var _a;\n\n  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : \"hydrated\");\n}; // src/runtime/set-value.ts\n\n\nvar getValue = function getValue(ref, propName) {\n  return getHostRef(ref).$instanceValues$.get(propName);\n};\n\nvar setValue = function setValue(ref, propName, newVal, cmpMeta) {\n  var hostRef = getHostRef(ref);\n\n  if (!hostRef) {\n    throw new Error(\"Couldn't find host element for \\\"\".concat(cmpMeta.$tagName$, \"\\\" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).\"));\n  }\n\n  var elm = hostRef.$hostElement$;\n  var oldVal = hostRef.$instanceValues$.get(propName);\n  var flags = hostRef.$flags$;\n  var instance = hostRef.$lazyInstance$;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n  var areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  var didValueChange = newVal !== oldVal && !areBothNaN;\n\n  if ((!(flags & 8\n  /* isConstructingInstance */\n  ) || oldVal === void 0) && didValueChange) {\n    hostRef.$instanceValues$.set(propName, newVal);\n\n    if (instance) {\n      if (cmpMeta.$watchers$ && flags & 128\n      /* isWatchReady */\n      ) {\n        var watchMethods = cmpMeta.$watchers$[propName];\n\n        if (watchMethods) {\n          watchMethods.map(function (watchMethodName) {\n            try {\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n\n      if ((flags & (2\n      /* hasRendered */\n      | 16\n      /* isQueuedForUpdate */\n      )) === 2\n      /* hasRendered */\n      ) {\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n}; // src/runtime/proxy-component.ts\n\n\nvar proxyComponent = function proxyComponent(Cstr, cmpMeta, flags) {\n  var _a, _b;\n\n  var prototype = Cstr.prototype;\n\n  if (cmpMeta.$members$ || cmpMeta.$watchers$ || Cstr.watchers) {\n    if (Cstr.watchers && !cmpMeta.$watchers$) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n\n    var members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});\n    members.map(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n          memberName = _ref7[0],\n          _ref7$ = _slicedToArray(_ref7[1], 1),\n          memberFlags = _ref7$[0];\n\n      if (memberFlags & 31\n      /* Prop */\n      || flags & 2\n      /* proxyState */\n      && memberFlags & 32\n      /* State */\n      ) {\n        Object.defineProperty(prototype, memberName, {\n          get: function get() {\n            return getValue(this, memberName);\n          },\n          set: function set(newValue) {\n            setValue(this, memberName, newValue, cmpMeta);\n          },\n          configurable: true,\n          enumerable: true\n        });\n      } else if (flags & 1\n      /* isElementConstructor */\n      && memberFlags & 64\n      /* Method */\n      ) {\n        Object.defineProperty(prototype, memberName, {\n          value: function value() {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            var _a2;\n\n            var ref = getHostRef(this);\n            return (_a2 = ref == null ? void 0 : ref.$onInstancePromise$) == null ? void 0 : _a2.then(function () {\n              var _a5;\n\n              var _a3;\n\n              return (_a3 = ref.$lazyInstance$) == null ? void 0 : (_a5 = _a3)[memberName].apply(_a5, args);\n            });\n          }\n        });\n      }\n    });\n\n    if (flags & 1\n    /* isElementConstructor */\n    ) {\n      var attrNameToPropName = /* @__PURE__ */new Map();\n\n      prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {\n        var _this = this;\n\n        plt.jmp(function () {\n          var _a2;\n\n          var propName = attrNameToPropName.get(attrName);\n\n          if (_this.hasOwnProperty(propName)) {\n            newValue = _this[propName];\n            delete _this[propName];\n          } else if (prototype.hasOwnProperty(propName) && typeof _this[propName] === \"number\" && _this[propName] == newValue) {\n            return;\n          } else if (propName == null) {\n            var hostRef = getHostRef(_this);\n            var flags2 = hostRef == null ? void 0 : hostRef.$flags$;\n\n            if (flags2 && !(flags2 & 8\n            /* isConstructingInstance */\n            ) && flags2 & 128\n            /* isWatchReady */\n            && newValue !== oldValue) {\n              var instance = hostRef.$lazyInstance$;\n              var entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];\n              entry == null ? void 0 : entry.forEach(function (callbackName) {\n                if (instance[callbackName] != null) {\n                  instance[callbackName].call(instance, newValue, oldValue, attrName);\n                }\n              });\n            }\n\n            return;\n          }\n\n          _this[propName] = newValue === null && typeof _this[propName] === \"boolean\" ? false : newValue;\n        });\n      };\n\n      Cstr.observedAttributes = Array.from( /* @__PURE__ */new Set([].concat(_toConsumableArray(Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {})), _toConsumableArray(members.filter(function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            _ = _ref9[0],\n            m = _ref9[1];\n\n        return m[0] & 15;\n      }\n      /* HasAttribute */\n      ).map(function (_ref10) {\n        var _ref11 = _slicedToArray(_ref10, 2),\n            propName = _ref11[0],\n            m = _ref11[1];\n\n        var _a2;\n\n        var attrName = m[1] || propName;\n        attrNameToPropName.set(attrName, propName);\n\n        if (m[0] & 512\n        /* ReflectAttr */\n        ) {\n          (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);\n        }\n\n        return attrName;\n      })))));\n    }\n  }\n\n  return Cstr;\n}; // src/runtime/initialize-component.ts\n\n\nvar initializeComponent = /*#__PURE__*/function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(elm, hostRef, cmpMeta, hmrVersionId) {\n    var Cstr, bundleId, CstrImport, endLoad, endNewInstance, cmpTag, style, scopeId2, endRegisterStyles, ancestorComponent, schedule;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!((hostRef.$flags$ & 32\n          /* hasInitializedComponent */\n          ) === 0)) {\n            _context2.next = 30;\n            break;\n          }\n\n          hostRef.$flags$ |= 32\n          /* hasInitializedComponent */\n          ;\n          bundleId = cmpMeta.$lazyBundleId$;\n\n          if (!bundleId) {\n            _context2.next = 26;\n            break;\n          }\n\n          CstrImport = loadModule(cmpMeta);\n\n          if (!(CstrImport && \"then\" in CstrImport)) {\n            _context2.next = 13;\n            break;\n          }\n\n          endLoad = uniqueTime();\n          _context2.next = 9;\n          return CstrImport;\n\n        case 9:\n          Cstr = _context2.sent;\n          endLoad();\n          _context2.next = 14;\n          break;\n\n        case 13:\n          Cstr = CstrImport;\n\n        case 14:\n          if (Cstr) {\n            _context2.next = 16;\n            break;\n          }\n\n          throw new Error(\"Constructor for \\\"\".concat(cmpMeta.$tagName$, \"#\").concat(hostRef.$modeName$, \"\\\" was not found\"));\n\n        case 16:\n          if (!Cstr.isProxied) {\n            {\n              cmpMeta.$watchers$ = Cstr.watchers;\n            }\n            proxyComponent(Cstr, cmpMeta, 2\n            /* proxyState */\n            );\n            Cstr.isProxied = true;\n          }\n\n          endNewInstance = createTime(\"createInstance\", cmpMeta.$tagName$);\n          hostRef.$flags$ |= 8\n          /* isConstructingInstance */\n          ;\n\n          try {\n            new Cstr(hostRef);\n          } catch (e) {\n            consoleError(e);\n          }\n\n          hostRef.$flags$ &= ~8\n          /* isConstructingInstance */\n          ;\n          hostRef.$flags$ |= 128\n          /* isWatchReady */\n          ;\n          endNewInstance();\n          fireConnectedCallback(hostRef.$lazyInstance$);\n          _context2.next = 29;\n          break;\n\n        case 26:\n          Cstr = elm.constructor;\n          cmpTag = elm.localName;\n          customElements.whenDefined(cmpTag).then(function () {\n            return hostRef.$flags$ |= 128;\n          }\n          /* isWatchReady */\n          );\n\n        case 29:\n          if (Cstr && Cstr.style) {\n            if (typeof Cstr.style === \"string\") {\n              style = Cstr.style;\n            } else if (typeof Cstr.style !== \"string\") {\n              hostRef.$modeName$ = computeMode(elm);\n\n              if (hostRef.$modeName$) {\n                style = Cstr.style[hostRef.$modeName$];\n              }\n            }\n\n            scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);\n\n            if (!styles.has(scopeId2)) {\n              endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n              registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1\n              /* shadowDomEncapsulation */\n              ));\n              endRegisterStyles();\n            }\n          }\n\n        case 30:\n          ancestorComponent = hostRef.$ancestorComponent$;\n\n          schedule = function schedule() {\n            return scheduleUpdate(hostRef, true);\n          };\n\n          if (ancestorComponent && ancestorComponent[\"s-rc\"]) {\n            ancestorComponent[\"s-rc\"].push(schedule);\n          } else {\n            schedule();\n          }\n\n        case 33:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n\n  return function initializeComponent(_x4, _x5, _x6, _x7) {\n    return _ref12.apply(this, arguments);\n  };\n}();\n\nvar fireConnectedCallback = function fireConnectedCallback(instance) {\n  {\n    safeCall(instance, \"connectedCallback\");\n  }\n}; // src/runtime/connected-callback.ts\n\n\nvar _connectedCallback = function connectedCallback(elm) {\n  if ((plt.$flags$ & 1\n  /* isTmpDisconnected */\n  ) === 0) {\n    var hostRef = getHostRef(elm);\n    var cmpMeta = hostRef.$cmpMeta$;\n    var endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n\n    if (!(hostRef.$flags$ & 1\n    /* hasConnected */\n    )) {\n      hostRef.$flags$ |= 1\n      /* hasConnected */\n      ;\n      var hostId;\n      {\n        hostId = elm.getAttribute(HYDRATE_ID);\n\n        if (hostId) {\n          if (cmpMeta.$flags$ & 1\n          /* shadowDomEncapsulation */\n          ) {\n            var scopeId2 = addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute(\"s-mode\"));\n            elm.classList.remove(scopeId2 + \"-h\", scopeId2 + \"-s\");\n          }\n\n          initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n        }\n      }\n\n      if (!hostId) {\n        if ( // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field\n        cmpMeta.$flags$ & (4\n        /* hasSlotRelocation */\n        | 8\n        /* needsShadowDomShim */\n        )) {\n          setContentReference(elm);\n        }\n      }\n\n      {\n        var ancestorComponent = elm;\n\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          if (ancestorComponent.nodeType === 1\n          /* ElementNode */\n          && ancestorComponent.hasAttribute(\"s-id\") && ancestorComponent[\"s-p\"] || ancestorComponent[\"s-p\"]) {\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(function (_ref13) {\n          var _ref14 = _slicedToArray(_ref13, 2),\n              memberName = _ref14[0],\n              _ref14$ = _slicedToArray(_ref14[1], 1),\n              memberFlags = _ref14$[0];\n\n          if (memberFlags & 31\n          /* Prop */\n          && elm.hasOwnProperty(memberName)) {\n            var value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n\n      {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);\n\n      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {\n        fireConnectedCallback(hostRef.$lazyInstance$);\n      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n        hostRef.$onReadyPromise$.then(function () {\n          return fireConnectedCallback(hostRef.$lazyInstance$);\n        });\n      }\n    }\n\n    endConnected();\n  }\n};\n\nvar setContentReference = function setContentReference(elm) {\n  var contentRefElm = elm[\"s-cr\"] = doc.createComment(\"\");\n  contentRefElm[\"s-cn\"] = true;\n  insertBefore(elm, contentRefElm, elm.firstChild);\n};\n\nvar disconnectInstance = function disconnectInstance(instance) {\n  {\n    safeCall(instance, \"disconnectedCallback\");\n  }\n};\n\nvar _disconnectedCallback = /*#__PURE__*/function () {\n  var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(elm) {\n    var hostRef;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          if ((plt.$flags$ & 1\n          /* isTmpDisconnected */\n          ) === 0) {\n            hostRef = getHostRef(elm);\n            {\n              if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map(function (rmListener) {\n                  return rmListener();\n                });\n                hostRef.$rmListeners$ = void 0;\n              }\n            }\n\n            if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {\n              disconnectInstance(hostRef.$lazyInstance$);\n            } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n              hostRef.$onReadyPromise$.then(function () {\n                return disconnectInstance(hostRef.$lazyInstance$);\n              });\n            }\n          }\n\n        case 1:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n\n  return function disconnectedCallback(_x8) {\n    return _ref15.apply(this, arguments);\n  };\n}();\n\nvar patchPseudoShadowDom = function patchPseudoShadowDom(hostElementPrototype, descriptorPrototype) {\n  patchCloneNode(hostElementPrototype);\n  patchSlotAppendChild(hostElementPrototype);\n  patchSlotAppend(hostElementPrototype);\n  patchSlotPrepend(hostElementPrototype);\n  patchSlotInsertAdjacentElement(hostElementPrototype);\n  patchSlotInsertAdjacentHTML(hostElementPrototype);\n  patchSlotInsertAdjacentText(hostElementPrototype);\n  patchTextContent(hostElementPrototype);\n  patchChildSlotNodes(hostElementPrototype, descriptorPrototype);\n  patchSlotRemoveChild(hostElementPrototype);\n};\n\nvar patchCloneNode = function patchCloneNode(HostElementPrototype) {\n  var orgCloneNode = HostElementPrototype.cloneNode;\n\n  HostElementPrototype.cloneNode = function (deep) {\n    var srcNode = this;\n    var isShadowDom = srcNode.shadowRoot && supportsShadow;\n    var clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n\n    if (!isShadowDom && deep) {\n      var i2 = 0;\n      var slotted, nonStencilNode;\n      var stencilPrivates = [\"s-id\", \"s-cr\", \"s-lr\", \"s-rc\", \"s-sc\", \"s-p\", \"s-cn\", \"s-sr\", \"s-sn\", \"s-hn\", \"s-ol\", \"s-nr\", \"s-si\", \"s-rf\", \"s-scs\"];\n\n      for (; i2 < srcNode.childNodes.length; i2++) {\n        slotted = srcNode.childNodes[i2][\"s-nr\"];\n        nonStencilNode = stencilPrivates.every(function (privateField) {\n          return !srcNode.childNodes[i2][privateField];\n        });\n\n        if (slotted) {\n          if (clonedNode.__appendChild) {\n            clonedNode.__appendChild(slotted.cloneNode(true));\n          } else {\n            clonedNode.appendChild(slotted.cloneNode(true));\n          }\n        }\n\n        if (nonStencilNode) {\n          clonedNode.appendChild(srcNode.childNodes[i2].cloneNode(true));\n        }\n      }\n    }\n\n    return clonedNode;\n  };\n};\n\nvar patchSlotAppendChild = function patchSlotAppendChild(HostElementPrototype) {\n  HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n\n  HostElementPrototype.appendChild = function (newChild) {\n    var slotName = newChild[\"s-sn\"] = getSlotName(newChild);\n    var slotNode = getHostSlotNode(this.childNodes, slotName, this.tagName);\n\n    if (slotNode) {\n      var slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n      var appendAfter = slotChildNodes[slotChildNodes.length - 1];\n      var insertedNode = insertBefore(appendAfter.parentNode, newChild, appendAfter.nextSibling);\n      updateFallbackSlotVisibility(this);\n      return insertedNode;\n    }\n\n    return this.__appendChild(newChild);\n  };\n};\n\nvar patchSlotRemoveChild = function patchSlotRemoveChild(ElementPrototype) {\n  ElementPrototype.__removeChild = ElementPrototype.removeChild;\n\n  ElementPrototype.removeChild = function (toRemove) {\n    if (toRemove && typeof toRemove[\"s-sn\"] !== \"undefined\") {\n      var slotNode = getHostSlotNode(this.childNodes, toRemove[\"s-sn\"], this.tagName);\n\n      if (slotNode) {\n        var slotChildNodes = getHostSlotChildNodes(slotNode, toRemove[\"s-sn\"]);\n        var existingNode = slotChildNodes.find(function (n) {\n          return n === toRemove;\n        });\n\n        if (existingNode) {\n          existingNode.remove();\n          updateFallbackSlotVisibility(this);\n          return;\n        }\n      }\n    }\n\n    return this.__removeChild(toRemove);\n  };\n};\n\nvar patchSlotPrepend = function patchSlotPrepend(HostElementPrototype) {\n  var originalPrepend = HostElementPrototype.prepend;\n\n  HostElementPrototype.prepend = function () {\n    var _this2 = this;\n\n    for (var _len3 = arguments.length, newChildren = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      newChildren[_key3] = arguments[_key3];\n    }\n\n    newChildren.forEach(function (newChild) {\n      if (typeof newChild === \"string\") {\n        newChild = _this2.ownerDocument.createTextNode(newChild);\n      }\n\n      var slotName = newChild[\"s-sn\"] = getSlotName(newChild);\n      var slotNode = getHostSlotNode(_this2.childNodes, slotName, _this2.tagName);\n\n      if (slotNode) {\n        var slotPlaceholder = document.createTextNode(\"\");\n        slotPlaceholder[\"s-nr\"] = newChild;\n\n        slotNode[\"s-cr\"].parentNode.__appendChild(slotPlaceholder);\n\n        newChild[\"s-ol\"] = slotPlaceholder;\n        var slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n        var appendAfter = slotChildNodes[0];\n        return insertBefore(appendAfter.parentNode, newChild, appendAfter.nextSibling);\n      }\n\n      if (newChild.nodeType === 1 && !!newChild.getAttribute(\"slot\")) {\n        newChild.hidden = true;\n      }\n\n      return originalPrepend.call(_this2, newChild);\n    });\n  };\n};\n\nvar patchSlotAppend = function patchSlotAppend(HostElementPrototype) {\n  HostElementPrototype.append = function () {\n    var _this3 = this;\n\n    for (var _len4 = arguments.length, newChildren = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      newChildren[_key4] = arguments[_key4];\n    }\n\n    newChildren.forEach(function (newChild) {\n      if (typeof newChild === \"string\") {\n        newChild = _this3.ownerDocument.createTextNode(newChild);\n      }\n\n      _this3.appendChild(newChild);\n    });\n  };\n};\n\nvar patchSlotInsertAdjacentHTML = function patchSlotInsertAdjacentHTML(HostElementPrototype) {\n  var originalInsertAdjacentHtml = HostElementPrototype.insertAdjacentHTML;\n\n  HostElementPrototype.insertAdjacentHTML = function (position, text) {\n    if (position !== \"afterbegin\" && position !== \"beforeend\") {\n      return originalInsertAdjacentHtml.call(this, position, text);\n    }\n\n    var container = this.ownerDocument.createElement(\"_\");\n    var node;\n    container.innerHTML = text;\n\n    if (position === \"afterbegin\") {\n      while (node = container.firstChild) {\n        this.prepend(node);\n      }\n    } else if (position === \"beforeend\") {\n      while (node = container.firstChild) {\n        this.append(node);\n      }\n    }\n  };\n};\n\nvar patchSlotInsertAdjacentText = function patchSlotInsertAdjacentText(HostElementPrototype) {\n  HostElementPrototype.insertAdjacentText = function (position, text) {\n    this.insertAdjacentHTML(position, text);\n  };\n};\n\nvar patchSlotInsertAdjacentElement = function patchSlotInsertAdjacentElement(HostElementPrototype) {\n  var originalInsertAdjacentElement = HostElementPrototype.insertAdjacentElement;\n\n  HostElementPrototype.insertAdjacentElement = function (position, element) {\n    if (position !== \"afterbegin\" && position !== \"beforeend\") {\n      return originalInsertAdjacentElement.call(this, position, element);\n    }\n\n    if (position === \"afterbegin\") {\n      this.prepend(element);\n      return element;\n    } else if (position === \"beforeend\") {\n      this.append(element);\n      return element;\n    }\n\n    return element;\n  };\n};\n\nvar patchTextContent = function patchTextContent(hostElementPrototype) {\n  var descriptor = Object.getOwnPropertyDescriptor(Node.prototype, \"textContent\");\n  Object.defineProperty(hostElementPrototype, \"__textContent\", descriptor);\n  {\n    Object.defineProperty(hostElementPrototype, \"textContent\", {\n      // To mimic shadow root behavior, we need to return the text content of all\n      // nodes in a slot reference node\n      get: function get() {\n        var slotRefNodes = getAllChildSlotNodes(this.childNodes);\n        var textContent = slotRefNodes.map(function (node) {\n          var _a, _b;\n\n          var text = [];\n          var slotContent = node.nextSibling;\n\n          while (slotContent && slotContent[\"s-sn\"] === node[\"s-sn\"]) {\n            if (slotContent.nodeType === 3\n            /* TEXT_NODE */\n            || slotContent.nodeType === 1\n            /* ELEMENT_NODE */\n            ) {\n              text.push((_b = (_a = slotContent.textContent) == null ? void 0 : _a.trim()) != null ? _b : \"\");\n            }\n\n            slotContent = slotContent.nextSibling;\n          }\n\n          return text.filter(function (ref) {\n            return ref !== \"\";\n          }).join(\" \");\n        }).filter(function (text) {\n          return text !== \"\";\n        }).join(\" \");\n        return \" \" + textContent + \" \";\n      },\n      // To mimic shadow root behavior, we need to overwrite all nodes in a slot\n      // reference node. If a default slot reference node exists, the text content will be\n      // placed there. Otherwise, the new text node will be hidden\n      set: function set(value) {\n        var _this4 = this;\n\n        var slotRefNodes = getAllChildSlotNodes(this.childNodes);\n        slotRefNodes.forEach(function (node) {\n          var slotContent = node.nextSibling;\n\n          while (slotContent && slotContent[\"s-sn\"] === node[\"s-sn\"]) {\n            var tmp = slotContent;\n            slotContent = slotContent.nextSibling;\n            tmp.remove();\n          }\n\n          if (node[\"s-sn\"] === \"\") {\n            var textNode = _this4.ownerDocument.createTextNode(value);\n\n            textNode[\"s-sn\"] = \"\";\n            insertBefore(node.parentElement, textNode, node.nextSibling);\n          } else {\n            node.remove();\n          }\n        });\n      }\n    });\n  }\n};\n\nvar patchChildSlotNodes = function patchChildSlotNodes(elm, cmpMeta) {\n  var FakeNodeList = /*#__PURE__*/function (_Array) {\n    function FakeNodeList() {\n      _classCallCheck(this, FakeNodeList);\n\n      return _callSuper(this, FakeNodeList, arguments);\n    }\n\n    _inherits(FakeNodeList, _Array);\n\n    return _createClass(FakeNodeList, [{\n      key: \"item\",\n      value: function item(n) {\n        return this[n];\n      }\n    }]);\n  }( /*#__PURE__*/_wrapNativeSuper(Array));\n\n  if (cmpMeta.$flags$ & 8\n  /* needsShadowDomShim */\n  ) {\n    var childNodesFn = elm.__lookupGetter__(\"childNodes\");\n\n    Object.defineProperty(elm, \"children\", {\n      get: function get() {\n        return this.childNodes.map(function (n) {\n          return n.nodeType === 1;\n        });\n      }\n    });\n    Object.defineProperty(elm, \"childElementCount\", {\n      get: function get() {\n        return elm.children.length;\n      }\n    });\n    Object.defineProperty(elm, \"childNodes\", {\n      get: function get() {\n        var childNodes = childNodesFn.call(this);\n\n        if ((plt.$flags$ & 1\n        /* isTmpDisconnected */\n        ) === 0 && getHostRef(this).$flags$ & 2\n        /* hasRendered */\n        ) {\n          var result = new FakeNodeList();\n\n          for (var i2 = 0; i2 < childNodes.length; i2++) {\n            var slot = childNodes[i2][\"s-nr\"];\n\n            if (slot) {\n              result.push(slot);\n            }\n          }\n\n          return result;\n        }\n\n        return FakeNodeList.from(childNodes);\n      }\n    });\n  }\n};\n\nvar getAllChildSlotNodes = function getAllChildSlotNodes(childNodes) {\n  var slotRefNodes = [];\n\n  for (var _i5 = 0, _Array$from2 = Array.from(childNodes); _i5 < _Array$from2.length; _i5++) {\n    var childNode = _Array$from2[_i5];\n\n    if (childNode[\"s-sr\"]) {\n      slotRefNodes.push(childNode);\n    }\n\n    slotRefNodes.push.apply(slotRefNodes, _toConsumableArray(getAllChildSlotNodes(childNode.childNodes)));\n  }\n\n  return slotRefNodes;\n};\n\nvar getSlotName = function getSlotName(node) {\n  return node[\"s-sn\"] || node.nodeType === 1 && node.getAttribute(\"slot\") || \"\";\n};\n\nvar getHostSlotNode = function getHostSlotNode(childNodes, slotName, hostName) {\n  var i2 = 0;\n  var childNode;\n\n  for (; i2 < childNodes.length; i2++) {\n    childNode = childNodes[i2];\n\n    if (childNode[\"s-sr\"] && childNode[\"s-sn\"] === slotName && childNode[\"s-hn\"] === hostName) {\n      return childNode;\n    }\n\n    childNode = getHostSlotNode(childNode.childNodes, slotName, hostName);\n\n    if (childNode) {\n      return childNode;\n    }\n  }\n\n  return null;\n};\n\nvar getHostSlotChildNodes = function getHostSlotChildNodes(n, slotName) {\n  var childNodes = [n];\n\n  while ((n = n.nextSibling) && n[\"s-sn\"] === slotName) {\n    childNodes.push(n);\n  }\n\n  return childNodes;\n}; // src/runtime/bootstrap-lazy.ts\n\n\nvar bootstrapLazy = function bootstrapLazy(lazyBundles) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  var endBootstrap = createTime();\n  var cmpTags = [];\n  var exclude = options.exclude || [];\n  var customElements2 = win.customElements;\n  var head = doc.head;\n  var metaCharset = /* @__PURE__ */head.querySelector(\"meta[charset]\");\n  var dataStyles = /* @__PURE__ */doc.createElement(\"style\");\n  var deferredConnectedCallbacks = [];\n  var styles2 = /* @__PURE__ */doc.querySelectorAll(\"[\".concat(HYDRATED_STYLE_ID, \"]\"));\n  var appLoadFallback;\n  var isBootstrapping = true;\n  var i2 = 0;\n  Object.assign(plt, options);\n  plt.$resourcesUrl$ = new URL(options.resourcesUrl || \"./\", doc.baseURI).href;\n  {\n    plt.$flags$ |= 2\n    /* appLoaded */\n    ;\n  }\n  {\n    for (; i2 < styles2.length; i2++) {\n      registerStyle(styles2[i2].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles2[i2].innerHTML), true);\n    }\n  }\n  var hasSlotRelocation = false;\n  lazyBundles.map(function (lazyBundle) {\n    lazyBundle[1].map(function (compactMeta) {\n      var _a2;\n\n      var cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n        $members$: compactMeta[2],\n        $listeners$: compactMeta[3]\n      };\n\n      if (cmpMeta.$flags$ & 4\n      /* hasSlotRelocation */\n      ) {\n        hasSlotRelocation = true;\n      }\n\n      {\n        cmpMeta.$members$ = compactMeta[2];\n      }\n      {\n        cmpMeta.$listeners$ = compactMeta[3];\n      }\n      {\n        cmpMeta.$attrsToReflect$ = [];\n      }\n      {\n        cmpMeta.$watchers$ = (_a2 = compactMeta[4]) != null ? _a2 : {};\n      }\n      var tagName = cmpMeta.$tagName$;\n\n      var HostElement = /*#__PURE__*/function (_HTMLElement) {\n        // StencilLazyHost\n        function HostElement(self) {\n          var _this5;\n\n          _classCallCheck(this, HostElement);\n\n          _this5 = _callSuper(this, HostElement, [self]);\n          _this5.hasRegisteredEventListeners = false;\n          self = _this5;\n          registerHost(self, cmpMeta);\n\n          if (cmpMeta.$flags$ & 1\n          /* shadowDomEncapsulation */\n          ) {\n            {\n              if (!self.shadowRoot) {\n                {\n                  self.attachShadow({\n                    mode: \"open\",\n                    delegatesFocus: !!(cmpMeta.$flags$ & 16\n                    /* shadowDelegatesFocus */\n                    )\n                  });\n                }\n              } else {\n                if (self.shadowRoot.mode !== \"open\") {\n                  throw new Error(\"Unable to re-use existing shadow root for \".concat(cmpMeta.$tagName$, \"! Mode is set to \").concat(self.shadowRoot.mode, \" but Stencil only supports open shadow roots.\"));\n                }\n              }\n            }\n          }\n\n          return _this5;\n        }\n\n        _inherits(HostElement, _HTMLElement);\n\n        return _createClass(HostElement, [{\n          key: \"connectedCallback\",\n          value: function connectedCallback() {\n            var _this6 = this;\n\n            var hostRef = getHostRef(this);\n\n            if (!this.hasRegisteredEventListeners) {\n              this.hasRegisteredEventListeners = true;\n              addHostEventListeners(this, hostRef, cmpMeta.$listeners$);\n            }\n\n            if (appLoadFallback) {\n              clearTimeout(appLoadFallback);\n              appLoadFallback = null;\n            }\n\n            if (isBootstrapping) {\n              deferredConnectedCallbacks.push(this);\n            } else {\n              plt.jmp(function () {\n                return _connectedCallback(_this6);\n              });\n            }\n          }\n        }, {\n          key: \"disconnectedCallback\",\n          value: function disconnectedCallback() {\n            var _this7 = this;\n\n            plt.jmp(function () {\n              return _disconnectedCallback(_this7);\n            });\n          }\n        }, {\n          key: \"componentOnReady\",\n          value: function componentOnReady() {\n            return getHostRef(this).$onReadyPromise$;\n          }\n        }]);\n      }( /*#__PURE__*/_wrapNativeSuper(HTMLElement));\n\n      {\n        if (cmpMeta.$flags$ & 2\n        /* scopedCssEncapsulation */\n        ) {\n          patchPseudoShadowDom(HostElement.prototype, cmpMeta);\n        }\n      }\n      cmpMeta.$lazyBundleId$ = lazyBundle[0];\n\n      if (!exclude.includes(tagName) && !customElements2.get(tagName)) {\n        cmpTags.push(tagName);\n        customElements2.define(tagName, proxyComponent(HostElement, cmpMeta, 1\n        /* isElementConstructor */\n        ));\n      }\n    });\n  });\n\n  if (cmpTags.length > 0) {\n    if (hasSlotRelocation) {\n      dataStyles.textContent += SLOT_FB_CSS;\n    }\n\n    {\n      dataStyles.textContent += cmpTags.sort() + HYDRATED_CSS;\n    }\n\n    if (dataStyles.innerHTML.length) {\n      dataStyles.setAttribute(\"data-styles\", \"\");\n      var nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);\n\n      if (nonce != null) {\n        dataStyles.setAttribute(\"nonce\", nonce);\n      }\n\n      head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n  }\n\n  isBootstrapping = false;\n\n  if (deferredConnectedCallbacks.length) {\n    deferredConnectedCallbacks.map(function (host) {\n      return host.connectedCallback();\n    });\n  } else {\n    {\n      plt.jmp(function () {\n        return appLoadFallback = setTimeout(appDidLoad, 30);\n      });\n    }\n  }\n\n  endBootstrap();\n};\n\nvar addHostEventListeners = function addHostEventListeners(elm, hostRef, listeners, attachParentListeners) {\n  if (listeners) {\n    listeners.map(function (_ref16) {\n      var _ref17 = _slicedToArray(_ref16, 3),\n          flags = _ref17[0],\n          name = _ref17[1],\n          method = _ref17[2];\n\n      var target = getHostListenerTarget(elm, flags);\n      var handler = hostListenerProxy(hostRef, method);\n      var opts = hostListenerOpts(flags);\n      plt.ael(target, name, handler, opts);\n      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(function () {\n        return plt.rel(target, name, handler, opts);\n      });\n    });\n  }\n};\n\nvar hostListenerProxy = function hostListenerProxy(hostRef, methodName) {\n  return function (ev) {\n    var _a;\n\n    try {\n      {\n        if (hostRef.$flags$ & 256\n        /* isListenReady */\n        ) {\n          (_a = hostRef.$lazyInstance$) == null ? void 0 : _a[methodName](ev);\n        } else {\n          (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n        }\n      }\n    } catch (e) {\n      consoleError(e);\n    }\n  };\n};\n\nvar getHostListenerTarget = function getHostListenerTarget(elm, flags) {\n  if (flags & 4\n  /* TargetDocument */\n  ) return doc;\n  if (flags & 8\n  /* TargetWindow */\n  ) return win;\n  if (flags & 16\n  /* TargetBody */\n  ) return doc.body;\n  return elm;\n};\n\nvar hostListenerOpts = function hostListenerOpts(flags) {\n  return supportsListenerOptions ? {\n    passive: (flags & 1\n    /* Passive */\n    ) !== 0,\n    capture: (flags & 2\n    /* Capture */\n    ) !== 0\n  } : (flags & 2\n  /* Capture */\n  ) !== 0;\n}; // src/runtime/nonce.ts\n\n\nvar setNonce = function setNonce(nonce) {\n  return plt.$nonce$ = nonce;\n};\n\nexport { Build as B, H, setPlatformHelpers as a, bootstrapLazy as b, setMode as c, createEvent as d, readTask as e, Host as f, getMode as g, h, getElement as i, forceUpdate as j, getAssetPath as k, promiseResolve as p, registerInstance as r, setNonce as s, writeTask as w };","map":null,"metadata":{},"sourceType":"module"}